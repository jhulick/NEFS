<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
<!ENTITY __nef-starter-app-setup__dr4w0y2f SYSTEM "../nef-reusable-content/nef-starter-app-setup.xml">
<!ENTITY __nef-key-features__dr4qnp41 SYSTEM "../nef-reusable-content/nef-key-features.xml">
<!ENTITY __nef-project-file__dr4s5f91 SYSTEM "../nef-reusable-content/nef-project-file.xml">
<!ENTITY __web-file__dr4thoqz SYSTEM "../nef-reusable-content/web-file.xml">
]>
<article>
  <title>Books Application Tutorial</title>

  <section>
    <title>Objectives</title>

    <para>The Books Application is a project meant to get you familiar with
    the <acronym>NEF</acronym> development by creating a simple but complete
    and functional real world application. The Books Application deals with
    the user interface as well as the back end part of the application. This
    involves the database access and the implementation of business logic. The
    Books Application will lead you through everything it takes to get an
    actual application up and running with special focus on developing the SQL
    and data management layers of your application.</para>

    <section>
      <title>Learning Objectives Checklist</title>

      <para>At the end of this tutorial, you should be able to
      understand:</para>

      <itemizedlist>
        <listitem>
          <para>the NEF Application Directory Structure</para>
        </listitem>

        <listitem>
          <para>the NEF Project File</para>
        </listitem>

        <listitem>
          <para>how to set up the sample application</para>
        </listitem>

        <listitem>
          <para>use of NEF Starter Application</para>
        </listitem>

        <listitem>
          <para>creation and testing of Data Layer</para>
        </listitem>

        <listitem>
          <para>creation and testing of Presentation Layer</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Assumptions</title>

    <para>For the purpose of this tutorial, we will be assuming that you
    installed the following:</para>

    <itemizedlist>
      <listitem>
        <para>Java Developer Kit (JDK) 1.2, 1.3 or 1.4</para>
      </listitem>

      <listitem>
        <para>A Servlet Container (application server) supporting the Servlet
        2.2 or higher specification</para>
      </listitem>
    </itemizedlist>

    <para>We assume that you are using the default port
    <literal>8080</literal> for your web server. If you chose different values
    for the installation path andthe port number, you should substitute the
    paths and the URLs in our example with your values as needed. This
    tutorial also assumes your familiarity with XML, SQL, Java, Servlets and
    JDBC.</para>
  </section>

  &__nef-starter-app-setup__dr4w0y2f;

  <section>
    <title>Key Concepts</title>

    <para>This section outlines some of the important, global concepts that
    you should be familiar with before embarking on developing your own
    applications.</para>

    &__nef-key-features__dr4qnp41;

    &__nef-project-file__dr4s5f91;

    &__web-file__dr4thoqz;
  </section>

  <section>
    <title>Functionality</title>

    <para>The NEF Books Application is a small application meant to be used
    for a personal library of books. It allows you to track the books you have
    and add more books to your collection or edit information stored about
    existing books. It also allows you to search your collection for a
    particular book based on your own custom search criteria.</para>

    <para>The overall functionality of the application is limited but
    complete. As such it demonstrates a few of the main types of data
    manipulation that developers need to take care of in every application. In
    the end, the goal is to show you just how much power can be wielded with
    just a few lines of XML and Java code when armed with the strength of
    Sparx.</para>
  </section>

  <section>
    <title>Design</title>

    <section>
      <title>Application Design</title>

      <para>The Books Application is designed around the basic Sparx
      components. It will use static SQL and associated reports to help you
      track the books stored in the application. Searches, on the other hand,
      require a dynamically generated SQL in the form of a Query
      Definition.</para>

      <para>The last aspect to take care of is the data storage. It is
      possible to use expensive abd overkill (in all certainty) database like
      Oracle for this application. Instead, the data storage of choice is the
      Java-based embedded database that is included in the Sparx Starter
      Application: <productname>HypersonicSQL</productname><footnote>
          <para>To learn more about <productname>HypersonicSQL, please go to
          <ulink
          url="http://hsqldb.sourceforge.net/">http://hsqldb.sourceforge.net/</ulink></productname></para>
        </footnote>. All the application components are included in the
      <filename>project.xml</filename> file for the Books Application.</para>
    </section>

    <section>
      <title>Database Design</title>

      <para>The Books Application deals with books and only books. Therefore,
      the information that needs to be stored in the database will be about
      books. The four pieces of information that the Books Application will
      store for this example are its ID, name, author, genre and ISBN. Of
      these, the genre is the only one that can be common across multiple
      books. In database language, the genre (book type) has a one-to-many
      relationship with the books.<figure>
          <title>Basic E-R Diagram for Books Application Database</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="./resources/images/screen-books-app-schema.gif" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The figure shows the entity-relationship diagram for the data we
      will be using. The database for the Books Application will be designed
      to store each entity (and its attributes) in a separate table. As with
      the application design, the database design will become clearer when it
      is implemented later in this tutorial.</para>
    </section>
  </section>

  <section>
    <title>Renaming the Starter Application</title>

    <para>You can now build your Books Application upon the Starter
    Application's directory structure. Rename the Starter Application's root
    folder (<filename class="directory">nefs-starter-empty</filename>) to your
    application's name. This tutorial uses <filename
    class="directory">nefs-sample-books</filename> as the root folder name for
    the Books Application.</para>
  </section>

  <section>
    <title>Dissecting the project.xml</title>

    <para><example>
        <title>Project File of Starter Application</title>

        <programlisting>&lt;?xml version="1.0"?&gt; 

&lt;<emphasis>project xmlns:xdm</emphasis>="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt; <co
            id="declare-prj-file-tags-eg-1" />

    &lt;xdm:include resource="com/netspective/commons/conf/commons.xml"/&gt; <co
            id="declare-prj-file-tags-eg-2" />
    &lt;xdm:include resource="com/netspective/axiom/conf/axiom.xml"/&gt; <co
            id="declare-prj-file-tags-eg-3" />
    &lt;xdm:include resource="com/netspective/sparx/conf/sparx.xml"/&gt; <co
            id="declare-prj-file-tags-eg-4" />
    &lt;xdm:include resource="com/netspective/sparx/conf/console.xml"/&gt; <co
            id="declare-prj-file-tags-eg-5" />

    &lt;!-- Your application tags go here. --&gt; <co
            id="declare-prj-file-tags-eg-6" />

    &lt;xdm:include file="your/own/file.xml"/&gt; <co
            id="declare-prj-file-tags-eg-7" />

    &lt;!-- Your other application tags go here. --&gt;
&lt;/project&gt;</programlisting>

        <calloutlist>
          <callout arearefs="declare-prj-file-tags-eg-1">
            <para>The root tag is called <sgmltag>project</sgmltag> and should
            use the provided xdm namespace.</para>
          </callout>

          <callout arearefs="declare-prj-file-tags-eg-2">
            <para>Include the Netspective Commons default component
            declarations. It uses the resource attribute so it will be located
            by searching the classpath and will usually find the file in the
            JAR file and directly read it from there.</para>
          </callout>

          <callout arearefs="declare-prj-file-tags-eg-3">
            <para>Include the Netspective Axiom default component declarations
            and factory registrations. It uses the resource attribute so it
            will be located by searching the classpath and will usually find
            the file in the JAR file and directly read it from there.</para>
          </callout>

          <callout arearefs="declare-prj-file-tags-eg-4">
            <para>Include the Netspective Sparx default component declarations
            and factory registrations. It uses the resource attribute so it
            will be located by searching the classpath and will usually find
            the file in the JAR file and directly read it from there.</para>
          </callout>

          <callout arearefs="declare-prj-file-tags-eg-5">
            <para>Include the Netspective Enterprise Console servlet
            declarations and application components. If you are turning off
            the Console in your applications you may leave this line
            out.</para>
          </callout>

          <callout arearefs="declare-prj-file-tags-eg-6">
            <para>This is the location where your component declarations will
            be done. Unless otherwise specified, all the components are
            declared right under the <sgmltag>project</sgmltag> tag.</para>
          </callout>

          <callout arearefs="declare-prj-file-tags-eg-7">
            <para>This line demonstrates how you can include your own XML
            files using the file attribute. In this example, because the file
            is not absolute it will be treated as relative to the calling
            file. The <sgmltag>xdm:include</sgmltag> tag may be included
            anywhere in the file and simply takes items from the included file
            and places them into the calling file while parsing.</para>
          </callout>
        </calloutlist>
      </example></para>
  </section>

  <section>
    <title>Creating the Data Layer</title>

    <para>With the empty (Starter) application successfully created and
    running, it is time to work on the backbone of the Books Application: the
    database.</para>

    <section>
      <title>Setting up the Data Source</title>

      <para>To set up the Books Application database, you need to have a
      database connection (data source) pointing towards your database. This
      is accomplished by using the <sgmltag>connection-provider</sgmltag> tag
      in the Project File (<filename>project.xml</filename>). <example>
          <title>Setting up the Data Source for Books Application</title>

          <programlisting>&lt;project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;
...

&lt;<emphasis>connection-provider</emphasis> <emphasis>
                 class="com.netspective.axiom.connection.JakartaCommonsDbcpConnectionProvider"</emphasis>&gt; <co
              id="declare-conn-provider-tags-eg-1" />

 &lt;<emphasis>data-source</emphasis> name="<emphasis>jdbc/default</emphasis>"&gt; <co
              id="declare-conn-provider-tags-eg-2" />
  &lt;<emphasis>driver-class</emphasis>&gt;org.hsqldb.jdbcDriver&lt;/driver-class&gt; <co
              id="declare-conn-provider-tags-eg-3" />
  &lt;<emphasis>url</emphasis>&gt;vs-expr:jdbc:hsqldb:${servlet-context-path:/WEB-INF/database/instance/db}&lt;/url&gt; <co
              id="declare-conn-provider-tags-eg-4" />
  &lt;<emphasis>user</emphasis>&gt;sa&lt;/user&gt; <co
              id="declare-conn-provider-tags-eg-5" />
  &lt;<emphasis>password</emphasis>&gt;&lt;/password&gt; <co
              id="declare-conn-provider-tags-eg-6" />
 &lt;/data-source&gt;

&lt;/connection-provider&gt;</programlisting>
        </example><calloutlist>
          <callout arearefs="declare-conn-provider-tags-eg-1">
            <para>A <sgmltag>connection-provider</sgmltag> tag is used to
            declare the connection to your application's database. <note>
                <para>Note that data sources specified under this connection
                provider will be managed by the Jakarta Commons DBCP. If you
                wish to use JNDI, you simply have to specify the resource
                according to the server you're using.</para>
              </note></para>
          </callout>

          <callout arearefs="declare-conn-provider-tags-eg-2">
            <para>Each <sgmltag>connection-provider</sgmltag> tag may contain
            one or more <sgmltag>data-source</sgmltag> tags. The
            <sgmltag>data-source</sgmltag> tag is used to specify the data
            source for the application. Any data source called
            '<emphasis>jdbc/default</emphasis>' is automatically used as the
            default JDBC data source. That is why the name of the data source
            in the above example code is set to "<literal>jdbc/default".
            </literal><note>
                <para>If you wish to change the name of the default data
                source, you may specify it in <filename>project.xml</filename>
                using the <sgmltag>default-data-source</sgmltag> tag.</para>
              </note></para>
          </callout>

          <callout arearefs="declare-conn-provider-tags-eg-3">
            <para>The <sgmltag>driver-class</sgmltag> tag is used to provide
            the driver to be used for the specified database. Since the Books
            Application uses HSQL database, our sample code specifies the
            appropriate JDBC driver.</para>
          </callout>

          <callout arearefs="declare-conn-provider-tags-eg-4">
            <para>The url is the JDBC URL used to connect to the database. The
            JDBC driver uses it to point to a specific database on a specific
            server. The URL has three parts which are separated by a colon
            "<literal>:</literal>". The first part is always
            "<literal>jdbc</literal>" and the second part is usually the name
            of the driver. In the example code, <literal>hsqldb</literal> is
            the name of the driver that is used to connect to your
            <productname>HypersonicSQL</productname> database. The third part
            is the name of the database.</para>

            <para>It is important to note the
            <sgmltag>servlet-context-path</sgmltag> value source. Value
            sources allow dynamic data to be included in XML without creating
            a programming language inside XML. In the example code, the
            <sgmltag>servlet-context-path</sgmltag> value source creates the
            database named '<literal>db</literal>' in <filename
            class="directory">WEB-INF</filename>/<filename
            class="directory">database</filename>/<filename
            class="directory">instance</filename> folder.</para>
          </callout>

          <callout arearefs="declare-conn-provider-tags-eg-5">
            <para>The <sgmltag>user</sgmltag> tag defines a default user to
            log in to the database. The example code specifies
            '<literal>sa</literal>' which is the default user for System
            Administrator.</para>
          </callout>

          <callout arearefs="declare-conn-provider-tags-eg-6">
            <para>The <sgmltag>password </sgmltag>tag is used to provide the
            password for the log in user. The default '<literal>sa</literal>'
            user has no password.</para>
          </callout>
        </calloutlist><note>
          <para>Please see the NEF User's Manual or review Tag Documentation
          in the Console to get further details on the each tag.</para>
        </note></para>

      <para>The above sample code declares a data source for the Books
      Application database.</para>

      <section>
        <title>Unit Testing the Data Source</title>

        <para>You may test the data source by using <guimenu>Data
        Management</guimenu> | <guisubmenu>Data Sources</guisubmenu> section
        in the Console of your Books Application.</para>

        <para><screenshot>
            <graphic fileref="./resources/images/screen-console-datasource.gif" />
          </screenshot></para>
      </section>
    </section>

    <section>
      <title>Creating the Schema</title>

      <para>After analyzing the information that needs to be stored in the
      database and judging from the E-R diagram shown earlier, you can derive
      the database schema that is necessary for the Books Application. It is a
      very simple schema consisting of only two tables:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Book Type</emphasis>: This table is used to store
          information aboout the different genres (types) of books.</para>
        </listitem>

        <listitem>
          <para><emphasis>Book Info</emphasis>: This table stores all the
          attributes of the books.</para>
        </listitem>
      </itemizedlist>

      <para>The two tables are 1:n related by the <literal>genre</literal> (in
      Book Info) and type (in Book Type) fields. Once entered as XML, this
      schema is available for platform-independent database access from your
      application.<note>
          <para>The entire schema, and the other larger and more complex ones
          that you might develop for enterprise applications, can be
          represented entirely in <filename>project.xml</filename> file of
          your application.</para>
        </note></para>

      <para>Following is the code that creates the Books Application
      schema:</para>

      <example>
        <title>Creating the Books Application Schema</title>

        <programlisting>&lt;<emphasis>schema</emphasis> name="db"&gt; <co
            id="declare-schema-tags-eg-1" />
  &lt;<emphasis>xdm:include resource="com/netspective/axiom/conf/schema.xml"</emphasis>/&gt; <co
            id="declare-schema-tags-eg-2" />

  &lt;<emphasis>table</emphasis> name="Book_Info" abbrev="bkI" <emphasis>type="Presentation"</emphasis>&gt; <co
            id="declare-schema-tags-eg-3" />
   &lt;<emphasis>column</emphasis> name="id" type="text" size="10" <emphasis>primary-key="yes"</emphasis> 
                     descr="Unique ID for every book in the database"/&gt; <co
            id="declare-schema-tags-eg-4" />
   &lt;column name="name" type="text" size="64" descr="Name of the book"/&gt;
   &lt;column name="author" type="text" size="64" descr="Name of the author(s)"/&gt;
   &lt;column name="genre" <emphasis>lookup-ref="Book_Type"</emphasis>/&gt; <co
            id="declare-schema-tags-eg-5" />
   &lt;column name="isbn" type="text" size="10" <emphasis>unique="yes"</emphasis> descr="The 10 digit ISBN number"/&gt; <co
            id="declare-schema-tags-eg-6" />
  &lt;/table&gt;

  &lt;table name="Book_Type" abbrev="bkT" <emphasis>type="Enumeration"</emphasis>&gt; <co
            id="declare-schema-tags-eg-7" />
   <emphasis>&lt;enumerations&gt;</emphasis> <co id="declare-schema-tags-eg-8" />
    <emphasis>&lt;enum&gt;</emphasis>Science Fiction&lt;/enum&gt; 
    &lt;enum&gt;Mystery&lt;/enum&gt;
    &lt;enum&gt;Business&lt;/enum&gt;
    &lt;enum&gt;Information Technology&lt;/enum&gt;
    &lt;enum&gt;Nuclear Physics&lt;/enum&gt;
    &lt;enum&gt;Chemistry&lt;/enum&gt;
   &lt;/enumerations&gt;
  &lt;/table&gt;
&lt;/schema&gt;</programlisting>

        <calloutlist>
          <callout arearefs="declare-schema-tags-eg-1">
            <para>All schemas are declared using the <sgmltag
            class="starttag">schema</sgmltag> tag and are uniquely identified
            with a <sgmltag>name</sgmltag> (<literal>db</literal> in this
            case). You may define multiple schemas within the same
            project.</para>
          </callout>

          <callout arearefs="declare-schema-tags-eg-2">
            <para>The default
            <filename>com/netspective/axiom/conf/schema.xml</filename>
            resource file contains dozens of built-in data types and table
            types that may be extended or just used. Types such as
            <literal>text</literal>, <literal>integer</literal>,
            <literal>float</literal>, <literal>currency</literal>,
            <literal>date</literal>, and even composite types such as
            <literal>duration</literal> are built-into Axiom.</para>
          </callout>

          <callout arearefs="declare-schema-tags-eg-3">
            <para>Each schema may contain one or more <sgmltag>table</sgmltag>
            tags to define database tables. Each table has a
            <sgmltag>name</sgmltag> and <sgmltag>abbrev</sgmltag>(iation)
            attribute associated with it. The table also has a
            <sgmltag>type</sgmltag> attribute. Axiom supplies various built-in
            table types. The <sgmltag>type </sgmltag>attribute for the
            <literal>Book_Info</literal> table is set to
            '<sgmltag>presentation</sgmltag>' which gives it a default
            dialog.</para>
          </callout>

          <callout arearefs="declare-schema-tags-eg-4">
            <para>The <sgmltag>column</sgmltag> tag is used to define a field
            (column) in the table. Each column has <sgmltag>name</sgmltag>,
            <sgmltag>type</sgmltag>, <sgmltag>size</sgmltag> and
            <sgmltag>descr</sgmltag>(iption) attributes associated with it. To
            specify a field as the primary key of the table, set the
            <sgmltag>primary-key</sgmltag> attribute's value to
            '<literal>yes</literal>'.</para>
          </callout>

          <callout arearefs="declare-schema-tags-eg-5">
            <para>The <sgmltag>lookup-ref</sgmltag> attribute specifies a
            general foreign key relationship. The format is
            <varname>Table_X</varname>.<varname>Column_Y</varname>. This
            creates a 1:1 or 1:N relationship from the defining column which
            references the foreign <varname>Column_Y</varname> of
            <varname>Table_X</varname>. The example code only specifies the
            table name (<literal>Book_Type</literal>) for the
            <sgmltag>lookup-ref</sgmltag> attribute. This defines the foreign
            key relationship between the referncing column
            (<literal>genre</literal> in this case) and the primary key column
            (<literal>type</literal> in this case) of the referenced
            (<literal>Book_Type</literal>) table.<note>
                <para>If you use this attribute, the type attribute is not
                required. It is set to the same type as the referenced
                column.</para>
              </note></para>
          </callout>

          <callout arearefs="declare-schema-tags-eg-6">
            <para>The unique attribute specifies whether the column's values
            should be unique. This means that no two rows should share the
            same valuefor this column. When this value is set to 'yes', this
            attribute creates a unique index based on this single column.
            <note>
                <para>If more than one column need to be unique (as a
                composite), use the index child element of the table element
                to create a unique index based on multiple columns.</para>
              </note></para>
          </callout>

          <callout arearefs="declare-schema-tags-eg-7">
            <para>The second <sgmltag>table</sgmltag> tag block is used to
            define the <literal>Book Type</literal> table. This table is
            defined as an <sgmltag>Enumeration</sgmltag>. An
            <sgmltag>Enumeration</sgmltag> is a special type of table that is
            generated by Sparx. It consists of the following three fields per
            record:</para>

            <itemizedlist>
              <listitem>
                <para><sgmltag>id</sgmltag>: contains a unique value which is
                used to relate the enumeration table in a 1:n manner with
                other tables</para>
              </listitem>

              <listitem>
                <para><sgmltag>caption</sgmltag>: contains non-null value that
                is used to to provide a short description of each value in the
                enumeration</para>
              </listitem>

              <listitem>
                <para><sgmltag>abbrev</sgmltag>: an optional field containing
                the abbreviation for the caption.</para>
              </listitem>
            </itemizedlist>

            <para>The syntax of an enumeration table is unlike that of regular
            tables. However, once parsed and interpreted, enumeration tables
            are translated into a set of regular tables for relational
            integrity purposes.<note>
                <para>An enumeration table is used to established a 1:n
                relationship between an attribute of an object (e.g.
                <literal>genre</literal> of the book in this case) and the
                object itself (the <literal>book</literal> in this case). It
                does this by letting the <sgmltag>id</sgmltag> field of the
                attribute enumeration table be inserted as a foreign key in
                the table containing records for the object. In this
                particular scenario, the <sgmltag>lookup-ref</sgmltag>
                attribute of the <literal>genre</literal> field in the
                <literal>Book_Info </literal>table makes that happen.</para>
              </note></para>
          </callout>

          <callout arearefs="declare-schema-tags-eg-8">
            <para>Each enumeration type table contains an
            <sgmltag>enumerations</sgmltag> tag. The values for the
            enumeration table (book types in this case) are specified with the
            help of <sgmltag>enum</sgmltag> tag. Each value is enclose within
            <sgmltag>enum</sgmltag> and <sgmltag>/enum</sgmltag> tag.</para>
          </callout>
        </calloutlist>
      </example>

      <section>
        <title>Unit Testing the Schema</title>

        <para>You may view the newly defined schema by using <guimenu>Data
        Management</guimenu> | <guisubmenu>Schemas</guisubmenu> section in the
        Console of your Books Application.</para>

        <para><screenshot>
            <graphic fileref="./resources/images/screen-console-schemas.gif" />
          </screenshot></para>

        <para>There is a list of all the tables contained in the schema. It
        should list a total of 4 tables, of which the most important to you
        are the ones you explicitly created: <literal>Book_Info</literal> and
        <literal>Book_Type</literal>. Click on the Book_Info table to see more
        details about it.</para>

        <para><screenshot>
            <graphic fileref="./resources/images/screen-console-tabledoc.gif" />
          </screenshot></para>

        <para>As you can see, the detailed view of the Book_Info tables gives
        a lot of information about the table and the information stored in it.
        For each field in the table, you can see its name, data type, actual
        SQL data type it was created as, whether it is a field referencing
        other fields (e.g. genre field in the Book _Info table) abd the
        index(es) deined on this table.</para>

        <para>You can view the details for the Book_Info and other tables in
        the same manner.</para>
      </section>
    </section>

    <section>
      <title>Generating Data Definition Language (DDL)</title>

      <para>The DDL representation of your schema consists of the actual
      commands that you need to issue to a database to create the tables you
      specified in the schema and to populate them with any static data (such
      as the one stored in enumeration tables) if necessary. These commands
      are DBMS-specific.</para>

      <section>
        <title>Using the Ant Build in Console</title>

        <para>To create the HSQL database and its DDL, you can use the
        <guimenu>Project</guimenu> |<guisubmenu> Ant Build</guisubmenu>
        section in the Console. In order to create the HSQL database, you must
        run the "<literal>create-database-hsqldb</literal>" target.</para>

        <para><graphic
        fileref="./resources/images/screen-console-ant-build.gif" /></para>

        <para>This erases the existing default datasource (Hypersonic
        database), generates the SQL DDL for the default schema, loads the SQL
        DDL (effectively creating the Hypersonic SQL database) and finally
        loads the 'starter' from XML files using Sparx import from XML
        feature.</para>

        <para>TODO: Insert image of DDL and DB creation msgs displayed in
        Console (after resolution of issue with test data xml)</para>

        <note>
          <para>Please note that this target should be executed anytime the
          default schema is modified.</para>
        </note>

        <para>With this final step completed, you should be ready to add,
        update, delete and query data from the database using the Sparx
        Library. To do that, however, you need a user interface that will
        allow you to manipulate data as well as query what is stored in the
        database.</para>
      </section>

      <section>
        <title>Automating the HSQL Database Generation</title>

        <para>You may also edit the <filename>web.xml</filename> file to
        automatically create the database each time the servlet is run for the
        first time. to do this, you need to add a
        <sgmltag>--init-first-time-using-ant</sgmltag> servlet option in the
        Sparx navigation controller using the following steps:</para>

        <procedure>
          <step>
            <para>Open the APP_ROOT/WEB-INF/web.xml file and look for the
            following Code:</para>

            <programlisting>&lt;servlet&gt;
 &lt;servlet-name&gt;SparxNavigationController&lt;/servlet-name&gt;
 &lt;servlet-class&gt;com.netspective.sparx.navigate.NavigationControllerServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;</programlisting>
          </step>

          <step>
            <para>Add the <sgmltag>init-param</sgmltag> tag to the above block
            of code. The resulting code will look like this:</para>

            <programlisting>&lt;servlet&gt; 
 &lt;servlet-name&gt;SparxNavigationController&lt;/servlet-name&gt;
 &lt;servlet-class&gt;com.netspective.sparx.navigate.NavigationControllerServlet&lt;/servlet-class&gt;
 &lt;init-param&gt; 
  &lt;param-name&gt;com.netspective.sparx.navigate.CONTROLLER_SERVLET_OPTIONS&lt;/param-name&gt;
  &lt;param-value&gt;
  --init-first-time-using-ant=/WEB-INF/sparx/conf/ant-build-project.xml:create-database-hsqldb 
  &lt;/param-value&gt;
 &lt;/init-param&gt;
&lt;/servlet&gt;</programlisting>
          </step>
        </procedure>

        <para>The above approach works because when the navigation controller
        runs, it creates a file called
        <replaceable>APP_ROOT</replaceable>/<filename
        class="directory">WEB-INF</filename>/<filename
        class="directory">sparx</filename>/<filename
        class="directory">conf</filename>/<filename>execution.properties</filename>.
        This properties file contains the execution count of the servlet. If
        the execution count is less than one, the Ant file
        (<filename>ant-build-project.xml</filename>) and the target you
        requested (create-database-hsqldb) will be run.</para>

        <note>
          <para>This is the best method to create databases because it
          automatically creates the database the very first time the servlet
          is run. And, if you ever want the database recreated, you can simply
          erase the <filename>execution.properties</filename> file.</para>
        </note>
      </section>

      <section>
        <title>Populating the HSQL Database with Test Data</title>

        <para>TODO: describe WEB-INF/database/initial-and-test-data.xml and
        initial-and-test-data.xsl files</para>
      </section>

      <section>
        <title>DDL and HSQL Database Files</title>

        <para>The DDL generation process creates the <filename
        class="directory">WEB-INF</filename>/<filename
        class="directory">database</filename> folder. This folder contains
        further sub-folders: <filename class="directory">defn</filename> and
        <filename class="directory">instance</filename>.</para>

        <variablelist>
          <varlistentry>
            <term>defn</term>

            <listitem>
              <para>This folder contains the SQL files containing
              DBMS-specific database creation scripts.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>instance</term>

            <listitem>
              <para>This folder contains the HSQL database files:
              <filename>db.properties</filename>,
              <filename>db.script</filename>, <filename>db.data</filename> and
              <filename>db.backup</filename>.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section>
        <title>Unit Testing the HSQL Database</title>

        <para>You may test the newly created HSQL database through
        <guimenu>Data Management</guimenu> | <guisubmenu>Data
        Sources</guisubmenu> | <guimenuitem>SQL Explorer</guimenuitem> option
        in the Console. Enter a SQL query for the <literal>Book_Info</literal>
        table in the SQL Editor and execute the query by clicking the
        <command>OK </command>button.</para>

        <screenshot>
          <graphic fileref="./resources/images/screen-console-sql-explorer.gif" />
        </screenshot>

        <para>TODO: result of unit test (after the error is resolved at my
        end)</para>
      </section>
    </section>

    <section>
      <title>Creating the Data Management Layer</title>

      <para>The Books Application uses two types of queries for data
      management:</para>

      <variablelist>
        <varlistentry>
          <term>Static SQL</term>

          <listitem>
            <para>A static SQL statement is merely an encapsulation of a
            regular SQL statement within the XML definition required by Sparx
            to interpret it. Once defined, a single or multiple SQL statements
            may be used in reports, dialogs (forms), Servlets, templates, or
            JSP-pages. All the static SQL statements with the bind parameters
            are declared in the Books Application Project File.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Dynamic SQL (Query Definition)</term>

          <listitem>
            <para>One of Axiom's powerful features is to generate dynamic SQL
            statements based upon user input. The dynamic SQL generator can
            also generate different output formats such as pageable HTML
            reports with configurable rows per page or comma separated value
            (CSV) reports. The main component of the dynamic queries is the
            query definition dialog which is used to define bind parameters of
            the dynamic SQL statement. Thus, the dynamic query generator can
            be thought of as a combination of Dialog and Static Query
            features.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>All the static and dynamic SQL statements are declared in the
        Books Application Project File
        (<filename>project.xml</filename>)</para>
      </note>

      <section>
        <title>Declaring a Static Query</title>

        <para>The Books Application uses a simple join query to get
        information about all the books and their genres. Following is the xml
        declaration that performs this task:</para>

        <example>
          <title>Declaring a Static Query</title>

          <programlisting>&lt;queries package="books"&gt; <co
              id="declare-static-sql-tags-eg-1" />

 &lt;query name="get-all-books"&gt; <co id="declare-static-sql-tags-eg-2" />
  select id, name, author, book_type.caption, isbn <co
              id="declare-static-sql-tags-eg-3" />
         from book_info, book_type
         where genre = book_type.id
 &lt;/query&gt;

&lt;/queries&gt;</programlisting>

          <calloutlist>
            <callout arearefs="declare-static-sql-tags-eg-1">
              <para>All the static in Axiom must belong to a statement package
              represented by <sgmltag>queries</sgmltag> XML tag. The statement
              package is identified by its name (<literal>books</literal> in
              the above example)</para>
            </callout>

            <callout arearefs="declare-static-sql-tags-eg-2">
              <para>A static query is defined (with or without bind
              parameters) by using the <sgmltag>query</sgmltag> tag. Each
              query is identified by its name
              (<literal>get-all-books</literal> in the above example)</para>

              <para>TODO: Awaiting response to my query.</para>
            </callout>

            <callout arearefs="declare-static-sql-tags-eg-3">
              <para>The static SQL (with or without bind parameters) is
              declared under the query tag. The query in this example declares
              a join on the <literal>Book_Type</literal> and
              <literal>Book_Info</literal> tables using the
              <literal>genre</literal> (from <literal>Book_Info</literal>) and
              <literal>id</literal> (from <literal>Book_Type</literal>)
              fields.</para>
            </callout>
          </calloutlist>
        </example>
      </section>

      <section>
        <title>Presenting the Results of a Static Query</title>

        <example>
          <title>Presenting the Results of a Static Query</title>

          <programlisting>&lt;queries package="books"&gt; 

 &lt;query name="get-all-books"&gt; 
  select id, name, author, book_type.caption, isbn 
         from book_info, book_type
         where genre = book_type.id

  &lt;presentation&gt; <co id="declare-pres-tags-eg-1" />
    &lt;panel name="main" height="300"&gt; <co id="declare-pres-tags-eg-2" />
        &lt;frame heading="static:All available books"/&gt; <co
              id="declare-pres-tags-eg-3" />
        &lt;report&gt; <co id="declare-pres-tags-eg-4" />
                &lt;actions&gt; <co id="declare-pres-tags-eg-5" />
                    &lt;action type="add" caption="Add Book" redirect="page-id:/add"/&gt; <co
              id="declare-static-sql-tags-eg-6" />
                    &lt;action type="edit" redirect="page-id:/edit?id=${0}"/&gt; <co
              id="declare-static-sql-tags-eg-7" />
                    &lt;action type="delete" redirect="page-id:/delete?id=${0}"/&gt; <co
              id="declare-static-sql-tags-eg-8" />
                &lt;/actions&gt;
                &lt;column heading="ID" format="plain" redirect="page-id:/edit?id=${0}"/&gt; <co
              id="declare-static-sql-tags-eg-9" />
                &lt;column heading="Name" /&gt;
                &lt;column heading="Author"/&gt;
                &lt;column heading="Genre"/&gt;
                &lt;column heading="ISBN"/&gt;
        &lt;/report&gt;
    &lt;/panel&gt;
  &lt;/presentation&gt;
 &lt;/query&gt;

&lt;/queries&gt;</programlisting>

          <para></para>
        </example>
      </section>

      <section>
        <title>Unit Testing a Static SQL</title>

        <para></para>
      </section>

      <section>
        <title>Declaring a Dynamic Query (Query Definition)</title>

        <para></para>
      </section>

      <section>
        <title>Presenting the Results of a Dynamic Query (Query
        Definition)</title>

        <para></para>
      </section>

      <section>
        <title>Unit Testing a Query Definition</title>

        <para></para>
      </section>
    </section>
  </section>

  <section>
    <title>Creating the Presentation Layer</title>

    <para></para>

    <section>
      <title>Creating the Home Page</title>

      <para></para>

      <section>
        <title>Unit Testing the Home Page</title>

        <para></para>
      </section>
    </section>

    <section>
      <title>Creating the Add Books Page</title>

      <para></para>

      <section>
        <title>Unit Testing the Add Books Page</title>

        <para></para>
      </section>
    </section>

    <section>
      <title>Creating the Edit Book Page</title>

      <para></para>

      <section>
        <title>Unit Testing the Edit Book Page</title>

        <para></para>
      </section>
    </section>

    <section>
      <title>Creating the Delete Book Page</title>

      <para></para>

      <section>
        <title>Unit Testing the Delete Book Page</title>

        <para></para>
      </section>
    </section>

    <section>
      <title>Creating the Search Books Page</title>

      <para></para>

      <section>
        <title>Unit Testing the Search Books Page</title>

        <para></para>
      </section>
    </section>

    <section>
      <title>Creating the Console Page</title>

      <para></para>

      <section>
        <title>Unit Testing the Console Page</title>

        <para></para>
      </section>
    </section>

    <section>
      <title>Creating the Sample Apps Home Page</title>

      <para></para>

      <section>
        <title>Unit Testing the Sample Apps Home Page</title>

        <para></para>
      </section>
    </section>
  </section>

  <section>
    <title>Console Application</title>

    <para></para>
  </section>

  <section>
    <title>Moving to Another Database</title>

    <para></para>
  </section>
</article>