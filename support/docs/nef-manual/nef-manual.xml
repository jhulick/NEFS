<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
<!ENTITY include_nef_faq_non_tech SYSTEM "../nef-faq-non-tech-section.xml">
<!ENTITY __unit-test-dialog__du3yjpcw SYSTEM "../nef-reusable-content/unit-test-dialog.xml">
<!ENTITY __unit-test-sql-queries__du3wqiiz SYSTEM "../nef-reusable-content/unit-test-sql-queries.xml">
]>
<book>
  <title>Netspective Enterprise Frameworks (NEF) User's Manual</title>

  <bookinfo>
    <title>Netspective Enterprise Frameworks (NEF) User's Manual</title>

    <releaseinfo>Release 7.1 ($Date: 2004-05-11 13:44:59 $)</releaseinfo>

    <releaseinfo>This version is in DRAFT until May 25, 2004 when it's
    expected to be completed. Check back daily until then because material is
    being added regularly.</releaseinfo>

    <authorgroup>
      <author>
        <firstname>Shahid</firstname>

        <othername role="mi">N.</othername>

        <surname>Shah</surname>
      </author>
    </authorgroup>

    <copyright>
      <year>2000</year>

      <year>2001</year>

      <year>2002</year>

      <year>2003</year>

      <year>2004</year>

      <holder>Netspective Communications LLC</holder>
    </copyright>

    <legalnotice>
      <para>Netspective, Enterprise Console, Sparx, Axiom, Commons, Medigy,
      Junxion and their respective logos are trademarks of Netspective
      Communications LLC, and may be registered in some jurisdictions.</para>
    </legalnotice>

    <legalnotice>
      <para>Netspective and its suppliers assume no responsibility for any
      damage or loss resulting from the use of this developer’s guide.
      Netspective and its suppliers assume no responsibility for any loss or
      claims by third parties that may arise through the use of this software
      or documentation.</para>
    </legalnotice>

    <legalnotice>
      <para>For warranty information and a copy of the End User License
      Agreement (EULA), please see the Netspective web site at <ulink
      url="http://www.netspective.com">http://www.netspective.com</ulink>. If
      you would like a copy of these materials mailed to you, or if you have
      any questions, please contact Netspective. The information included on
      this web site sets forth Netspective’s sole and complete warranty and
      software licensing obligations with respect to your Netspective product.
      Use of the product indicates your acceptance of the terms of the
      warranty and the End User License Agreement.</para>
    </legalnotice>
  </bookinfo>

  <chapter>
    <title>Introduction</title>

    <para>The Netspective Enterprise Frameworks Suite
    (<acronym>NEFS</acronym>) is a comprehensive application frameworks suite
    which helps build secure data-driven web applications. Design and
    prototyping, implementation, unit tests, implementation documentation, and
    production logs and metrics are just some of the development deliverables
    and phases that the NEF helps accelerate and standardize.</para>

    <section>
      <title id="nef-features">Features</title>

      <para>The <acronym>NEF</acronym> has hundreds of features that support
      the development of sophisticated applications with exceptional ease.
      Some of the important ones include:</para>

      <section>
        <title>General Features</title>

        <itemizedlist>
          <listitem>
            <para>Instantly create sophisticated mission- and safety-critical
            web-based applications that run on <emphasis>any application
            server.</emphasis></para>
          </listitem>

          <listitem>
            <para>Declare components for the presentation and data management
            layers in XML and have NEF assemble up to 80% of your application
            for you with little or no Java code. All the Java code you write
            will be related to application functionality, not user interface
            (HTML) generation or database access.</para>
          </listitem>

          <listitem>
            <para>Write all your business logic using EJBs, rules processing
            systems, or plain Java objects and connect them to NEF components
            like dialogs, fields, and schemas easily.</para>
          </listitem>

          <listitem>
            <para>Use the automatically-generated web services that change as
            the rest of your application changes. As you add features, tables,
            forms, and functionality the web services will remain in
            sync.</para>
          </listitem>

          <listitem>
            <para>Declare your user interface forms, fields, validation rules,
            conditional logic, and security policies using simple XML tags and
            get fully functional theme- and skin-based HTML output
            automatically.</para>
          </listitem>

          <listitem>
            <para>Declare your database structures and relationships using
            simple XML tags and get fully functional SQL DDL, SQL DML, HTML
            documentation and XML import/export capabilities
            automatically.</para>
          </listitem>

          <listitem>
            <para>Declare your database SQL and parameters using simple XML
            tags and get fully functional reports and synchronized and
            validated input capabilities automatically.</para>
          </listitem>

          <listitem>
            <para>Automatically produce programmer artifacts like HTML
            documentation, unit tests, functional specifications, and
            requirements traceability maps just by using XML tags and the NEF
            API.</para>
          </listitem>

          <listitem>
            <para>Combine multiple "sub-applications" into a main application
            context -- share common themes, skins, navigation, security, and
            sessions across multiple applications.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Feature List</title>

        <section>
          <title>Global</title>

          <itemizedlist>
            <listitem>
              <para>Works with any IDE, editor, studio apps</para>
            </listitem>

            <listitem>
              <para>Works with but does not require EJBs</para>
            </listitem>

            <listitem>
              <para>Native J2EE API always available</para>
            </listitem>

            <listitem>
              <para>Uses normal Java inheritance and delegation for
              extensiblity</para>
            </listitem>

            <listitem>
              <para>Low learning curve</para>
            </listitem>

            <listitem>
              <para>Works well with other frameworks</para>
            </listitem>

            <listitem>
              <para>Source code available</para>
            </listitem>

            <listitem>
              <para>Ability to version-control components and apps</para>
            </listitem>

            <listitem>
              <para>Operating system independence</para>
            </listitem>

            <listitem>
              <para>App-server independence</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Architecture</title>

          <itemizedlist>
            <listitem>
              <para>J2EE Design/Architecture Patterns</para>
            </listitem>

            <listitem>
              <para>Application Integration Patterns</para>
            </listitem>

            <listitem>
              <para>Application Functionality Patterns</para>
            </listitem>

            <listitem>
              <para>Web-services</para>
            </listitem>

            <listitem>
              <para>Externalization of Resources</para>
            </listitem>

            <listitem>
              <para>Executable Specifications</para>
            </listitem>

            <listitem>
              <para>Logging and Performance Stats</para>
            </listitem>

            <listitem>
              <para>Business Values and Rules Repository</para>
            </listitem>

            <listitem>
              <para>Centralized Configuration Parameters</para>
            </listitem>

            <listitem>
              <para>Allows production, testing, development modes</para>
            </listitem>

            <listitem>
              <para>Code Generation</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Process &amp; Methodology</title>

          <itemizedlist>
            <listitem>
              <para>Administration Console</para>
            </listitem>

            <listitem>
              <para>Unit Testing of Common Components</para>
            </listitem>

            <listitem>
              <para>Unit Testing of Custom Components</para>
            </listitem>

            <listitem>
              <para>Integration Testing</para>
            </listitem>

            <listitem>
              <para>System Testing</para>
            </listitem>

            <listitem>
              <para>Functional Specifications</para>
            </listitem>

            <listitem>
              <para>Metrics (Function Points, SLOC)</para>
            </listitem>

            <listitem>
              <para>Implementation documentation</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Presentation Layer</title>

          <itemizedlist>
            <listitem>
              <para>Forms and Controls</para>
            </listitem>

            <listitem>
              <para>Client-side Validation</para>
            </listitem>

            <listitem>
              <para>Server-side Validation</para>
            </listitem>

            <listitem>
              <para>Template Language</para>
            </listitem>

            <listitem>
              <para>Automatic Form Reload on Error</para>
            </listitem>

            <listitem>
              <para>Dialog Data State Machine</para>
            </listitem>

            <listitem>
              <para>Complete HTML generation</para>
            </listitem>

            <listitem>
              <para>Data Binding to Presentation Layer</para>
            </listitem>

            <listitem>
              <para>Reports</para>
            </listitem>

            <listitem>
              <para>Navigation and Workflow</para>
            </listitem>

            <listitem>
              <para>Wireless, PDA, Browser Support</para>
            </listitem>

            <listitem>
              <para>Multiple skins support (with no code changes)</para>
            </listitem>

            <listitem>
              <para>Presentation Object Performance Statistics</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Data Management Layer</title>

          <itemizedlist>
            <listitem>
              <para>Schema Management</para>
            </listitem>

            <listitem>
              <para>Lightweight Data Access Objects</para>
            </listitem>

            <listitem>
              <para>Object-relational mapping and persistence</para>
            </listitem>

            <listitem>
              <para>Connection Pooling</para>
            </listitem>

            <listitem>
              <para>SQL DML Generation</para>
            </listitem>

            <listitem>
              <para>SQL DDL Generation</para>
            </listitem>

            <listitem>
              <para>Static SQL Queries Library</para>
            </listitem>

            <listitem>
              <para>Dynamic SQL Queries Library</para>
            </listitem>

            <listitem>
              <para>HTML Design Documentation</para>
            </listitem>

            <listitem>
              <para>Dynamic Data sources</para>
            </listitem>

            <listitem>
              <para>SQL performance statistics</para>
            </listitem>

            <listitem>
              <para>Transaction Management and Isolation</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Security and Personalization Layer</title>

          <itemizedlist>
            <listitem>
              <para>User Login Form</para>
            </listitem>

            <listitem>
              <para>User Management Objects</para>
            </listitem>

            <listitem>
              <para>Access Control Lists</para>
            </listitem>

            <listitem>
              <para>Permissions Management</para>
            </listitem>

            <listitem>
              <para>Roles Management</para>
            </listitem>

            <listitem>
              <para>Forms/Controls Conditional Security</para>
            </listitem>

            <listitem>
              <para>Reports Conditional Security</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
    </section>

    <section>
      <title>Benefits</title>

      <para>The NEF features provide the following benefits to technical
      managers and engineers of all levels:</para>

      <itemizedlist>
        <listitem>
          <para>Application developers spend time on real features significant
          to end-users instead of infrastructure issues.</para>
        </listitem>

        <listitem>
          <para>Technical managers can better manage their application
          development projects by utilizing the built-in project management,
          application documentation, unit-testing, and artifact-generation
          tools.</para>
        </listitem>

        <listitem>
          <para>Most of the user interface and database logic is coded in a
          declarative style using XML instead of a programmatic style using
          Java. This significantly reduces the amount of code (as much as
          50-75% of code can be eliminated), increases re-use, maintains
          consistency across multiple projects, and improves code
          quality.</para>
        </listitem>

        <listitem>
          <para>Analysts can use the declarative user interface features to
          create prototypes that can later be completed by programmers (no
          more throw-away prototypes).</para>
        </listitem>

        <listitem>
          <para>Applications are built by assembling declared user interface
          (forms/dialogs) and database (SQL) components combined with
          application-specific business logic using single or multiple
          distributed application tiers.</para>
        </listitem>

        <listitem>
          <para>NEF is not a templating system that simply generates HTML but
          a feature-rich framework that significantly reduces the time to
          produce high-quality data-intensive thin-client applications. It
          favors no specific templating system but comes bundle with support
          for both JSP and <ulink
          url="http://www.freemarker.org">FreeMarker</ulink>.</para>
        </listitem>

        <listitem>
          <para>NEF does not favor Servlets over JSPs or JSPs over Servlets
          and can work in one, the other, or both environments simultaneously
          with no loss of functionality in either environment.</para>
        </listitem>

        <listitem>
          <para>Implementation can be done using XML, Java, or both.</para>
        </listitem>

        <listitem>
          <para>Implements common design patterns like MVC and factories.
          Skins infrastructure allow identical business logic to be used
          across different user interfaces for a variety of browsers and
          platforms like hand-helds.</para>
        </listitem>

        <listitem>
          <para>NEF enhances and works equally well with all project
          development methodologies including waterfall, RAD, OOAD, and the
          agility of methodologies like Extreme Programming (XP).</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Alternative Frameworks</title>

      <para>Why use the Netspective Frameworks Suite instead of creating your
      own, using commercial embedded, commercial standalone, or other
      open-source frameworks. Because NEF is a comprehensive and easy to use
      J2EE architectural framework solution (whereas other products are only
      partial solutions).</para>

      <section>
        <title>Why not create your own custom framework?</title>

        <para>Due to the lack of robust commercial offerings, today most
        enterprises choose to build their own frameworks and platforms. Your
        In-house and home-grown solutions tend to have a great deal of
        momentum behind them because they may be favored internally by the
        experienced and senior engineers that construct them. However,
        home-grown solutions exhibit the following shortcomings:</para>

        <itemizedlist>
          <listitem>
            <para>They often have limited features (to compare, see <xref
            linkend="nef-features" />)</para>
          </listitem>

          <listitem>
            <para>They are usually poorly documented.</para>
          </listitem>

          <listitem>
            <para>They are notoriously difficult to extend because they are
            usually designed for special-purpose jobs.</para>
          </listitem>

          <listitem>
            <para>They are usually expensive to create and maintain and
            require engineering attention which is taken away from business
            requirements. Programmers often end up spending time on
            infrastructure issues instead of issues that directly affect
            end-users.</para>
          </listitem>
        </itemizedlist>

        <para>With its unique architecture, NEF can supplement in-house
        frameworks or replace them completely. We will be able to work
        alongside home-grown solutions and be extensible enough to allow
        enterprises to make a slow switch over to NEF.</para>

        <para>Even if all of your engineers are very experienced and your
        architecture is very sound, part of every J2EE application development
        process is spent in prototyping, technical writing, testing, and
        maintenance. Even if the code is completed on time, these other tasks
        take up to another 30 to 40% of the total project resources. NEF can
        take an experienced J2EE programmer and improve their productivity and
        in many cases eliminate the need for specialized resources for
        architecture and design, prototyping, documentation, logging,
        deployment, and maintenance.</para>
      </section>

      <section>
        <title>I have an application server, isn’t that sufficient for me to
        write my J2EE applications?</title>

        <para>Most J2EE application servers contain a great deal of common
        infrastructure code that helps <emphasis>contain</emphasis>,
        <emphasis>manage</emphasis>, <emphasis>deploy</emphasis>, and
        <emphasis>execute</emphasis> applications. They also have features the
        increase scalability, reliability, and availability of applications by
        providing features like clustering and failover. What they lack,
        because it’s not part of their product requirements, is the ability to
        help build the applications they contain. Just as an operating system
        is a container for executing applications written in any language but
        does not assist in the development of the applications, a J2EE
        application server is a container for executing Java and J2EE
        applications but does not assist in the development of the Java/J2EE
        applications. Sparx, as a J2EE framework, helps create the
        applications that you can then deploy onto any J2EE container or
        application server.</para>
      </section>

      <section>
        <title>Why not use the frameworks that come with my application
        server?</title>

        <para>Many commercial embedded frameworks are provided by application
        server vendors like WebLogic or WebSphere. The main issues you'll face
        with these frameworks are:</para>

        <itemizedlist>
          <listitem>
            <para>They are usually vendor-specific and tie you to a particular
            application server, operating system, or database server</para>
          </listitem>

          <listitem>
            <para>The frameworks are not designed for complete coverage of
            sophisticated applications and engineers end up having to do a
            great deal of infrastructure work on their own.</para>
          </listitem>

          <listitem>
            <para>Unlike NEF's feature list (see <xref
            linkend="nef-features" />) most embedded application server
            frameworks are very light on functionality.</para>
          </listitem>
        </itemizedlist>

        <para>With its unique architecture, NEF can supplement or replace your
        application server vendor's frameworks with a good mix of easy to use
        components for faster development and the sophistication that senior
        architects need to create robust applications. Also, keep in mind that
        all NEF-based applications are application-server, database-server,
        and operating-system independent.</para>
      </section>

      <section>
        <title>Why not use open source frameworks like Struts?</title>

        <para>There are many freely-available open source frameworks are quite
        good for certain types of applications. There are a number of good
        tools in this category like Struts, Enhydra, Expresso, and others;
        however, they all share the following issues:</para>

        <itemizedlist>
          <listitem>
            <para>None of these free products match NEF from a feature or
            functionality perspective (see <xref
            linkend="nef-features" />).</para>
          </listitem>

          <listitem>
            <para>Most of the open source tools cater to very talented Java
            engineers since they require a serious understanding of low-level
            computer science concepts, J2EE APIs, and Java programming.</para>
          </listitem>

          <listitem>
            <para>Most open source tools are written by experienced
            programmers <emphasis>for</emphasis> experienced programmers and
            as such depend on mutual understanding instead of heavy
            documentation.</para>
          </listitem>

          <listitem>
            <para>While they save money in the beginning (since they are free)
            they end up costing much more because they often require more
            experienced engineers, usually require a higher number of
            engineers, and don't have the quality management tools
            built-in.</para>
          </listitem>
        </itemizedlist>

        <para>NEF can complement or replace most frameworks like Struts or
        Expresso.</para>
      </section>

      <section>
        <title>What are the primary advantages of NEF versus other
        frameworks?</title>

        <para>There are two primary competitive advantages that Netspective's
        frameworks have over other frameworks.</para>

        <orderedlist>
          <listitem>
            <para>Simplification — we are focusing on pure reduction of time
            and effort for the engineer and the use of the technology by
            less-experienced staff members. If you're not an expert in Java,
            web development, persistence, or other topics then NEF is the
            perfect suite of frameworks because all the hard stuff is
            abstracted. If you're already an expert in many of the areas then
            you'll enjoy working on end-user and application domain tasks
            instead of grunt coding in the infrastructure.</para>
          </listitem>

          <listitem>
            <para>Holistic approach to engineering — which refers to our
            concentration not on just the coding aspects but the engineering
            aspects -- testing (quality), metrics (measurement), monitoring,
            performance), and documentation.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section>
      <title>Libraries and Components</title>

      <para>The NEF suite is comprised of multiple libraries and frameworks,
      all of which are designed to work together.</para>

      <figure>
        <title>Overview of NEF Components</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="./resources/images/nefs-overview.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Commons Core Library</title>

        <para>The <emphasis>Commons</emphasis> library contains general
        purpose classes for access control, configuration management, value
        sources, data validation, and XML parsing. The Commons library may be
        used in both web-based and non-web-based applications.</para>
      </section>

      <section>
        <title>Axiom Relational Data Management Service (Data Management
        Layer)</title>

        <para>The <emphasis>Axiom</emphasis> service provides static query,
        dynamic query (query definitions), and schema management
        functionality. Axiom is a sophisticated relational database management
        framework that provides the capability to completely manage schemas,
        SQL DDL, SQL DML, XML import/export, and vendor-independent
        persistence. The Axiom framework depends upon the Commons library and
        may be used in both web-based and non-web-based applications.</para>
      </section>

      <section>
        <title>Sparx Application Platform (Presentation and Application
        Layers)</title>

        <para>The <emphasis>Sparx</emphasis> application framework helps
        manage navigation, dialogs (forms), reports, and other complex user
        interface functionality. Sparx helps create sophisticated yet easy to
        use user interfaces on all common browsers including Microsoft
        Internet Explorer, Mozilla, and Opera. The Sparx framework is built
        using Commons and Axiom and is designed exclusively for creating
        web-based thin-client applications.</para>
      </section>

      <section>
        <title>Enterprise Console</title>

        <para>The NEF and all application components built with it can be
        viewed with the <emphasis>Netspective Enterprise Console</emphasis>
        servlet. The Console is an optional component for every application
        built with NEF and it is turned on by default. You may decide to turn
        it off completely for your applications or secure it differently. Each
        application has a private instance of the Console using
        <literal>http://<replaceable>server</replaceable>/<replaceable>appName</replaceable>/console</literal>.
        When you log into the Console for Application X
        (<literal>appX/console</literal>) versus Y
        (<literal>appY/console</literal>) you will only see components for the
        appropriate application.</para>

        <note>
          <para>The Enterprise Console is an excellent example of one of NEF's
          features called <emphasis>multiple sub-applications</emphasis>. It
          means that a primary application (in this case your custom app) can
          host and co-exist with other shared sub-applications that may be
          related. The sub-application scheme uses the standard servlet
          context mapping scheme of the URI paths used by servlet containers.
          Each sub-application is merely another servlet and can share (if it
          needs to) the main-application's themes, skins, and descriptors or
          may use it's own. For example, although the Console is a
          sub-application of your custom application, it has its own
          navigation tree, its own theme and skins but it knows about the
          objects in your application and may manipulate and use them.</para>
        </note>

        <section>
          <title>Console Login</title>

          <para>The Console's default user name is
          '<literal>console</literal>' and the default password is
          '<literal>console</literal>' (each without quotes) . Unless
          otherwise specified, that is the user name and password combination
          you should use if the Console prompts you to login.</para>
        </section>

        <section>
          <title>Accessing the Console in Applications</title>

          <para>As mentioned already, each application has a private instance
          of the Console using the
          <literal>http://<replaceable>server</replaceable>/<replaceable>appName</replaceable>/console</literal>
          pattern. Here are some examples of how to access the Console for
          some of the sample applications.</para>

          <variablelist>
            <varlistentry>
              <term>Hello World</term>

              <listitem>
                <para>The Hello World sample application is the most basic
                sample application and its application identifier is
                <literal>nefs-sample-hello-world</literal>. The URL for Hello
                World is http://www.netspective.com/nefs-sample-hello-world
                and its Console URL is
                http://www.netspective.com/nefs-sample-hello-world/console.
                Note that the Console is accessed simply by adding the
                <literal>/console</literal> path at the end of the
                application's URL.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Library</term>

              <listitem>
                <para>The Library sample application is the sample application
                that demonstrates how to create a complete database
                application and its application identifier is
                <literal>nefs-sample-library</literal>. The URL for Library is
                http://www.netspective.com/nefs-sample-library and its Console
                URL is http://www.netspective.com/nefs-sample-library/console.
                Note that the Console is accessed simply by adding the
                <literal>/console</literal> path at the end of the
                application's URL.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Your Application</term>

              <listitem>
                <para>When writing your own application you will simply append
                <literal>/console</literal> to the end of your own
                application's context identifier. If your app would be
                available at
                http://<replaceable>your-server</replaceable>/<replaceable>your-app-id</replaceable>
                then the Console for your application would be available at
                http://<replaceable>your-server</replaceable>/<replaceable>your-app-id</replaceable>/<literal>console</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>

      <section>
        <title>How NEF Libraries Fit In Your Application</title>

        <para>NEF components are pure Java libraries that reside
        <emphasis>inside your application</emphasis>, unlike other similar
        frameworks which are containers <emphasis>for your
        application</emphasis>. The main difference is interoperability of
        frameworks. Netspective Frameworks are designed as enterprise
        frameworks that can stand-alone or enhance other COTS or in-house
        frameworks. NEF consists of three JAR files containing the Commons,
        Axiom, and Sparx binaries and a set of HTML and XML resources like
        XSLT style sheets, icons and an extensive JavaScript library. This
        simple structure affords developers a great deal of flexibility in how
        they want to use any of the Netspective Frameworks. Therefore, you do
        not have to redesign or recode your application as you would to comply
        with the limitations of a framework container. Instead, you can start
        out by using a few Sparx features here and there and adopting more of
        the Sparx ease and speed of development as the need arises. And,
        because the frameworks all work like normal Java libraries, version
        control, debugging, and code management is not affected.</para>

        <figure>
          <title>NEF Position in J2EE Stack</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="./resources/images/nefs-relationship-to-app.gif" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <section>
      <title>NEF Artifacts</title>

      <para>Using simple XML declarations for the items on the left (schema,
      SQL, UI, etc.) NEF produces a variety of objects and artifacts. Many of
      the components that NEF produces are not generated but instantiated
      while others are both generated first then instanatiated. The <filename
      class="directory">WEB-INF/classes/auto</filename> directory contains all
      classes that are generated. So, if a class is found in directory other
      than <filename class="directory">WEB-INF/classes/auto</filename> (the
      auto-generation directory) then it's a custom or user class that was
      created or prepared outside of NEF. NEF loads most components using XML
      which is translated at the startup of the application into objects that
      are cached, shared, and executed. Unlike most code generators which
      create code that must be separately compiled, many of the NEF components
      automatically executed in memory with no compile/link/debug
      cycle.</para>

      <figure>
        <title>NEF Artifacts</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="./resources/images/nefs-outputs.gif" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>NEF Web Services</title>

      <para>The general topic of web services refers to the ability of
      applications and systems to speak to each other over Internet protocols.
      The "normal" case of web applications has a customer accessing a catalog
      site and making a purchase over a secure website. This interaction is
      quite common but sometimes its preferable to have a computer system
      automatically place an order with other computer systems. For example,
      suppliers could provide web services to large corporations so that
      corporations could automatically, without human intervention, place
      orders to the supplier when their inventory runs low. NEF supports both
      web applications (where a human being is interacting with an application
      or computer system) and web services (where a service is being created
      for use by other computers). NEF allows the web services to
      automatically become applications and applications to automatically
      become services with very little work on the part of analysts or
      programmers. For example, every Sparx form or dialog automatically
      provides the capability for becoming a web service. Additionally, any
      table or SQL query defined using Sparx automatically has the capability
      to run in both "application" and "service" modes.</para>
    </section>

    <section>
      <title>NEF System Requirements</title>

      <para>NEF contains pure Java libraries (no native code) and therefore
      should work on any platform that supports Java2. The Frameworks have
      been tested on and require one of the following platforms:</para>

      <itemizedlist>
        <listitem>
          <para>Microsoft Windows NT 4.0 Workstation/Server</para>
        </listitem>

        <listitem>
          <para>Microsoft Windows 2000 Professional/Server</para>
        </listitem>

        <listitem>
          <para>Microsoft Windows XP</para>
        </listitem>

        <listitem>
          <para>Microsoft Windows Server 2003</para>
        </listitem>

        <listitem>
          <para>Apple OS X</para>
        </listitem>

        <listitem>
          <para>SUN Solaris 7</para>
        </listitem>

        <listitem>
          <para>Red Hat Linux</para>
        </listitem>

        <listitem>
          <para>Slackware Linux</para>
        </listitem>
      </itemizedlist>

      <para>NEF has been tested on and requires one of the following Java
      Development Kits (JDKs):</para>

      <itemizedlist>
        <listitem>
          <para>Java JDK 1.2 or above</para>
        </listitem>

        <listitem>
          <para>Java JDK 1.3 or above</para>
        </listitem>

        <listitem>
          <para>Java JDK 1.4 or above (recommended)</para>
        </listitem>
      </itemizedlist>

      <para>NEF has been tested on and requires one of the following Java
      Application Servers:</para>

      <itemizedlist>
        <listitem>
          <para>BEA WebLogic</para>
        </listitem>

        <listitem>
          <para>IBM WebSphere</para>
        </listitem>

        <listitem>
          <para>ORACLE AS</para>
        </listitem>

        <listitem>
          <para>Caucho Resin</para>
        </listitem>

        <listitem>
          <para>Apache Tomcat</para>
        </listitem>
      </itemizedlist>

      <para>NEF has been tested on and requires one of the web
      browsers:</para>

      <itemizedlist>
        <listitem>
          <para>Microsoft Internet Explorer 4.0 or above</para>
        </listitem>

        <listitem>
          <para>Mozilla 1.0 or above include Firebird</para>
        </listitem>

        <listitem>
          <para>Opera 6.0 or above</para>
        </listitem>

        <listitem>
          <para>Apple Safari</para>
        </listitem>

        <listitem>
          <para>Most other modern web browsers</para>
        </listitem>
      </itemizedlist>
    </section>

    &include_nef_faq_non_tech;
  </chapter>

  <chapter>
    <title>Developing Applications with NEF</title>

    <para>There are several schools of thought when it comes to answering the
    "where do I start writing my application?" question. Two of the popular
    ones are:</para>

    <orderedlist>
      <listitem>
        <para>Define and prototype the entire user interface (presentation
        layer or UI) and wait until the UI is completed before starting the
        database management tasks. In this option, the user interface elements
        (forms, fields, etc.) drive the data model and schema.</para>
      </listitem>

      <listitem>
        <para>Define and prototype the entire data management layer first and
        then follow-up with the presentation layer. In this option, the data
        model and schema drive the user interface.</para>
      </listitem>
    </orderedlist>

    <para>Netspective does not assume either method to be correct so it
    supports both of them. Developing applications with NEF involves an
    interative process that includes (but is not limited to) the following
    steps:</para>

    <procedure>
      <step>
        <para>Define your requirements.</para>
      </step>

      <step>
        <para>Declare your requirements to Sparx using the XML tags.</para>
      </step>

      <step>
        <para>Use the Console to unit test your Sparx XML declarations and
        demonstrate them to your end users.</para>
      </step>

      <step>
        <para>Generate classes for presentation, data access, object
        identification, and persistence.</para>
      </step>

      <step>
        <para>Customize functionality using either inheritance or
        delegation.</para>
      </step>

      <step>
        <para>Run functional/integration and acceptance tests of your combined
        Sparx XML declarations and Java code customizations.</para>
      </step>

      <step>
        <para>Deploy your application once everything is working.</para>
      </step>
    </procedure>

    <figure>
      <title>NEF Application Development Process Overview</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="./resources/images/nefs-swdev-process.gif" />
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Define</title>

      <para>This definition phase is usually a mental exercise but it may
      involve formal requirements gathering (Waterfall style) or using
      customer stories (XP/Agile style). Normally. the more time you spend in
      the definition phase understanding your customer's requirements, the
      less time you'll spend changing code later on. However, using NEF's
      delcarative programming model allow you to change requirements and lets
      your customers change their minds without significant impact to your
      code.</para>

      <section>
        <title>Defining the Presentation Layer</title>

        <para>The NEF helps manage many portions of the presentation layer.
        You can simply declare a hierarchy of menus, menu items, captions,
        headings, and NEF manages the rendering of navigation. Likewise, once
        you define the rules for your forms like headings, fields, validation
        criteria, and field placements NEF will manage everything for you.
        And, all of the HTML generation is performed through delegated calls
        to skins and themes so that you can control all aspects of your
        application's appearance in one place instead of across dozens and
        hundreds of pages.</para>

        <mediaobjectco>
          <imageobjectco>
            <areaspec units="other">
              <area coords="1" id="screen-app-generic-components-co-1" />

              <area coords="2" id="screen-app-generic-components-co-2" />

              <area coords="3" id="screen-app-generic-components-co-3" />

              <area coords="4" id="screen-app-generic-components-co-4" />

              <area coords="5" id="screen-app-generic-components-co-5" />

              <area coords="6" id="screen-app-generic-components-co-6" />
            </areaspec>

            <imageobject>
              <imagedata fileref="./resources/images/screen-app-generic-components.gif" />
            </imageobject>
          </imageobjectco>
        </mediaobjectco>

        <calloutlist>
          <callout arearefs="screen-app-generic-components-co-1">
            <para>Consider how you want your application to be organized. The
            default theme, called <emphasis>slate</emphasis>, is a tabbed
            interface so the top level menus become tabs and the second level
            menus become buttons under their respective tabs. Other themes may
            render differently (such as pull-down menus or a tree) but the
            concepts are the same.</para>
          </callout>

          <callout arearefs="screen-app-generic-components-co-2">
            <para>NEF understands the concept of an active page (or an active
            tab/menu). You should consider this when you design your pages so
            that you properly define which pages have particular components.
            Of course, all navigation, selection, and rendering of the active
            page is automatic.</para>
          </callout>

          <callout arearefs="screen-app-generic-components-co-3">
            <para>NEF assigns unique identifiers, captions, headings, and
            titles to each page automatically and the themes render them
            consistently across all pages.</para>
          </callout>

          <callout arearefs="screen-app-generic-components-co-4">
            <para>Consider the type of data you will collect using forms. In
            NEF they are called input panels, dialogs, and forms (each term is
            synonymous in most cases). Rendering of forms once you declare the
            fields and validation criteria is handled by the themes and skins.
            So you worry about the functionality and NEF manages the
            HTML.</para>
          </callout>

          <callout arearefs="screen-app-generic-components-co-5">
            <para>Output panels like this may contain the output of SQL
            queries, arbitrary HTML, execution results from a web service or
            any other type of component. You should consider what you want to
            show on the screens along with your forms (if anything).</para>
          </callout>

          <callout arearefs="screen-app-generic-components-co-6">
            <para>You can collect data in multiple panels and show them on the
            same screen. Each panel, by the way, is an independent object and
            you can declare the component one time and use them on multiple
            pages with different display contexts and they will be
            consistently manageme</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title>Defining the Data Management Layer</title>

        <section>
          <title>Static SQL Queries</title>

          <para>Consider what SQL should be created manually.</para>
        </section>

        <section>
          <title>Dynamic SQL Queries</title>

          <para>Consider what type of searches your application should
          perform.</para>
        </section>

        <section>
          <title>Database Schema</title>

          <para>Define the structures (tables, columns, relationships) needed
          to store your data and consider where the data will be stored (the
          type of database, location of the database, etc.). You may skip this
          phase of database schema definition if you are connecting to a
          legacy database or an existing data source.</para>
        </section>
      </section>

      <section>
        <title>Defining the Security Layer</title>

        <para>Define the different security roles necessary and all the
        permissions that will be assigned to roles.</para>
      </section>
    </section>

    <section>
      <title>Declare</title>

      <para>Almost all facets of the software development process are covered
      by the Commons, Axiom, and Sparx XML tags and Java APIs, including but
      not limited to, forms declarations, data validation, page definition,
      template writing, navigation, dynamic and static SQL, and database
      schemas. All of the declarations are placed in the
      <literal><filename>APP_ROOT/WEB-INF/sparx/project.xml</filename></literal>
      file (see <xref linkend="nef-project-file" />).</para>

      <figure>
        <title>NEF Tags Overview</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="./resources/images/nefs-tags-overview.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <note>
        <para>For instructions on how to view all available NEF tags along
        with attributes and descriptions, see <xref
        linkend="xdm-tags-ref" />.</para>
      </note>

      <section>
        <title>Declaring the Presentation Layer</title>

        <para>The presentation layer tags are broken up into several groups:
        navigation, forms/fields, on-screen validation, and conditional
        processing. Almost all of the presentation layer tags are managed by
        Sparx.</para>

        <section>
          <title>Introduction to Navigation Declaration Tags</title>

          <para>The navigation tags are comprised primarily of the <sgmltag
          class="starttag">navigation-tree</sgmltag>, <sgmltag
          class="starttag">page</sgmltag>, and <sgmltag
          class="starttag">body</sgmltag> tags. These are very high-level tags
          that provide a great deal of functionality without requiring any
          HTML or JSP. However, if you need to customize the behavior you have
          full access to the APIs through both inheritance and delegation. You
          focus on the hierarchy, specify the structure and rules and NEF will
          do the rest. The Sparx navigation system fully implements MVC
          (model-view-controller) design pattern.</para>

          <example>
            <title>Navigation Tags in the Presentation Layer</title>

            <programlisting role="xml">&lt;project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;
...

&lt;<emphasis role="bold">navigation-tree</emphasis> name="app" default="yes"&gt; <co
                id="declare-nav-tags-eg-1" />

    &lt;<emphasis role="bold">page</emphasis> name="home" default="yes" caption="Hello" heading="Hello World!"&gt; <co
                id="declare-nav-tags-eg-2" />
        &lt;<emphasis role="bold">body</emphasis>&gt; <co
                id="declare-nav-tags-eg-3" />
            &lt;![CDATA[
            This is the 'Hello World' app. Click &lt;a href="next-steps"&gt;here&lt;/a&gt; to see what's next.
            ]]&gt;
        &lt;/body&gt;
    &lt;/page&gt;

    &lt;page name="next-steps" caption="Next Steps" heading="What's next?"&gt;
        &lt;body <emphasis role="bold">source</emphasis>="next-steps.ftl"/&gt; <co
                id="declare-nav-tags-eg-4" />
    &lt;/page&gt;

    &lt;page name="some-stuff" caption="Panels instead of Body"&gt;
        &lt;<emphasis role="bold">panels</emphasis>&gt; <co
                id="declare-nav-tags-eg-5" />
             &lt;panel type="command" command="query,org.get-sponsor-info-by-id,-,-,-,detail-compressed"/&gt;
             &lt;panel type="command" command="query,org.get-org-addresses-by-id,-,-,-,report-compressed" /&gt;
        &lt;/panels&gt;
    &lt;/page&gt;

    &lt;page name="sampler" caption="Sampler" <emphasis role="bold">redirect</emphasis>="vs-expr:${netspective-url:sampler}"/&gt; <co
                id="declare-nav-tags-eg-6" />
    &lt;page name="sampler" caption="Sampler" <emphasis role="bold">include</emphasis>="/some/file.jsp"/&gt; <co
                id="declare-nav-tags-eg-7" />
    &lt;page name="sampler" caption="Sampler" <emphasis role="bold">forward</emphasis>="/some/file.jsp"/&gt; <co
                id="declare-nav-tags-eg-8" />

    &lt;page name="add" caption="Add Book" <emphasis role="bold">command</emphasis>="dialog,schema.db.Book_Info,add"/&gt; <co
                id="declare-nav-tags-eg-9" />
    &lt;page name="edit" caption="Edit Book" command="dialog,schema.db.Book_Info,edit"
          require-request-param="id" retain-params="id"&gt;
        &lt;<emphasis role="bold">missing-params-body</emphasis>&gt; <co
                id="declare-nav-tags-eg-10" />
           Please choose a book to edit from the &amp;lt;a href='home'&amp;gt; books list&amp;lt;/a&amp;gt;.
        &lt;/missing-params-body&gt;
    &lt;/page&gt;</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-nav-tags-eg-1">
              <para>The <sgmltag class="starttag">navigation-tree</sgmltag>
              tag starts out the definition of a tree. You may declare as many
              navigation trees as your application needs. Consider different
              trees for different users (based on personalization) or a
              different tree for each access-control role (for security) or
              any other criteria required by your application. Each tree has a
              name and may be marked with <sgmltag
              class="attribute">default</sgmltag>=<sgmltag
              class="attvalue">yes</sgmltag> if it is to be the default tree.
              Which tree is actually used by the application may be specfied
              as a servlet parameter or chosen dynamically at runtime based on
              some processing rules.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-2">
              <para>Each <sgmltag class="starttag">navigation-tree</sgmltag>
              tag one or more <sgmltag class="starttag">page</sgmltag> tags
              that define what pages should be visible to the user. Each
              <sgmltag class="starttag">page</sgmltag> tag supports common
              things like the page's name (unique identifier), a caption (what
              might show up in a tab or menu), a heading, and title.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-3">
              <para>Each <sgmltag class="starttag">page</sgmltag> tag may have
              an optional <sgmltag class="starttag">body</sgmltag> tag with
              contents directly specified as XML content. You can use the
              CDATA XML element to escape HTML tags. The content of the
              <sgmltag class="starttag">body</sgmltag> tag is treated as a
              <ulink url="http://www.freemarker.org">FreeMarker</ulink>
              template by default.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-4">
              <para>The <sgmltag class="starttag">page</sgmltag> tag's
              <sgmltag class="starttag">body</sgmltag> tag may instead specify
              a <sgmltag class="attribute">source</sgmltag> attribute that
              indicates the given file is a a <ulink
              url="http://www.freemarker.org">FreeMarker</ulink> template
              relative to the APP_ROOT directory. Other template engines like
              JSP are also supported.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-5">
              <para>The <sgmltag class="starttag">page</sgmltag> tag's
              <sgmltag class="starttag">body</sgmltag> tag may be replaced
              with the <sgmltag class="starttag">panels</sgmltag> tag to have
              automatic layouts of mutliple panels.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-6">
              <para>The <sgmltag class="starttag">page</sgmltag> tag may
              specify a <sgmltag class="attribute">redirect</sgmltag>
              attribute to automatically redirect to another page whenever it
              is chosen.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-7">
              <para>The <sgmltag class="starttag">page</sgmltag> tag may
              specify an <sgmltag class="attribute">include</sgmltag>
              attribute to simply insert the contents of another web resource
              directly into the body.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-8">
              <para>The <sgmltag class="starttag">page</sgmltag> tag may
              specify a <sgmltag class="attribute">forward</sgmltag> attribute
              to forward the request to another web resource (this is the same
              as Servlet forwarding not HTTP forwarding).</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-9">
              <para>The <sgmltag class="starttag">page</sgmltag> tag may
              specify a <sgmltag class="attribute">command</sgmltag> attribute
              to use the Command pattern and delegate the body to a
              <classname>com.netspective.commons.command.Command</classname>
              interface. These are very high-level commands like interacting
              with a dialog and displaying the results of a query that can be
              defined elsewhere and called on different pages.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-10">
              <para>The <sgmltag class="starttag">page</sgmltag> tag may
              specify required request parameters and optionally produce
              automatic error messages when they are not provided.</para>
            </callout>
          </calloutlist>

          <note>
            <para>Almost all <sgmltag class="starttag">page</sgmltag> tag
            attributes support Value Sources for their values so the values
            may be static or dynamic (see <xref
            linkend="section-value-sources" />). This allows, for example the
            captions, headings, and all user-visible values to be properly
            placed in property files or other external resources and mapped in
            a language-specific manner for internationlization purposes. The
            important thing to understand is that even though the declarations
            are in a static XML file, the values of the descriptors are
            capable of being dynamic.</para>
          </note>

          <note>
            <para>Please see <xref linkend="xdm-tags-ref" /> for instructions
            on how to use the Console to review tag documentation and use the
            Tags Tree to get further details on the <sgmltag
            class="starttag">navigation-tree</sgmltag> and <sgmltag
            class="starttag">page</sgmltag> tags.</para>
          </note>
        </section>

        <section>
          <title>Introduction to Forms Declaration Tags</title>

          <para>The forms tags are comprised primarily of the <sgmltag
          class="starttag">dialogs</sgmltag>, <sgmltag
          class="starttag">dialog</sgmltag>, and <sgmltag
          class="starttag">field</sgmltag> tags. These are very high-level
          tags that provide a great deal of functionality without requiring
          any HTML or JSP custom tags. You focus on the rules and validatoin
          createria and NEF will do the rest. NEF ships with many common
          controls and gives you the capability to add your own at any
          time.</para>

          <example>
            <title>Form Tags in Presentation Layer</title>

            <programlisting role="xml">&lt;project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;
...

&lt;<emphasis role="bold">dialogs</emphasis> package="test"&gt; <co
                id="declare-form-tags-eg-1" />
    &lt;<emphasis role="bold">dialog</emphasis> name="DialogTest_01_A" retain-params="*" hide-hints-until-focus="yes"&gt; <co
                id="declare-form-tags-eg-2" />
        &lt;<emphasis role="bold">frame</emphasis> heading="Test String Fields"/&gt; <co
                id="declare-form-tags-eg-3" />

        &lt;<emphasis role="bold">field</emphasis> name="text_field_hidden" <emphasis
                role="bold">type="text"</emphasis> hidden="yes" default="request:id"/&gt; <co
                id="declare-form-tags-eg-4" />
        &lt;field name="text_field" type="text" caption="Text" hint="Text field optional (max-length=5, uppercase=yes)"
               max-length="5" uppercase="yes"/&gt;
        &lt;field name="text_field_regex" type="text" caption="Text Email" hint="Text field with regular expression validation"
               display-pattern="/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/"
               invalid-reg-ex-message="Invalid email format."/&gt;

               <co id="declare-form-tags-eg-5" />
        &lt;field <emphasis role="bold">type="boolean"</emphasis> name="bool_field_radio" caption="Boolean Field (Radio)" style="radio" /&gt;
        &lt;field name="email_field" <emphasis role="bold">type="e-mail"</emphasis> caption="Email" hint="Email field"/&gt;
        &lt;field name="masked_field" <emphasis role="bold">type="text"</emphasis> caption="Masked Field" mask-entry="yes" hint="e.g password"/&gt;
        &lt;field <emphasis role="bold">type="integer"</emphasis> name="integer_field" caption="Integer Field" hint="Integer field" <emphasis
                role="bold">persist="yes"</emphasis>/&gt;
        &lt;field <emphasis role="bold">type="float"</emphasis> name="float_field" caption="Float Field" hint="Float field"/&gt;
        &lt;field <emphasis role="bold">type="currency"</emphasis> name="currency_field1" caption="Currency" decimals-required="2" default="123.45"
               negative-pos="after-symbol" hint="Currency field (US) with negative sign after the symbol"/&gt;
        &lt;field <emphasis role="bold">type="phone"</emphasis> name="phone_field1" caption="Phone Field (dash format)" strip-brackets="yes" style="dash"
               hint="Phone field" default="8001234567"/&gt;
        &lt;field <emphasis role="bold">type="zip-code"</emphasis> name="zip_field" caption="Zip Field" hint="Zip code field" default="12345"/&gt;
        &lt;field <emphasis role="bold">type="ssn"</emphasis> name="ssn_field" caption="SSN" strip-dashes="yes" default="999999999"/&gt;

        &lt;field <emphasis role="bold">type="select"</emphasis> name="sel_field_combo_xml_items" caption="Select Field (Combo with XML Items)"
               style="combo" default="A" prepend-blank="yes"&gt;
            &lt;items&gt;
                &lt;item value="A" caption="Choice 1 (in XML Item)"/&gt;
                &lt;item value="B" caption="Choice 2 (in XML Item)"/&gt;
                &lt;item value="C" caption="Choice 3 (in XML Item)"/&gt;
                &lt;item value="D" caption="Choice 4 (in XML Item)"/&gt;
                &lt;item value="E" caption="Choice 5 (in XML Item)"/&gt;
            &lt;/items&gt;
        &lt;/field&gt;

        &lt;field name="text_field_required" type="text" caption="Text Required"
            hint="Text field is required when req param 'abc' has value"
            default="conditional Required Text" required="no"&gt;
            &lt;<emphasis role="bold">conditional</emphasis> action="apply-flags" flags="required" has-value="request:abc"/&gt; <co
                id="declare-form-tags-eg-6" />
        &lt;/field&gt;

        &lt;field name="properties" <emphasis role="bold">type="html"</emphasis> caption="HTML Template Field"&gt;
            &lt;<emphasis role="bold">body</emphasis>&gt; <co
                id="declare-form-tags-eg-7" />
                &lt;![CDATA[
                &lt;div class='textbox'&gt;
                This is a FreeMarker template inside a dialog (1 + 1 = ${1 + 1}).
                &lt;/div&gt;]]&gt;
            &lt;/body&gt;
        &lt;/field&gt;

        &lt;<emphasis role="bold">director</emphasis> submit-caption="Submit" style="acknowledge"/&gt; <co
                id="declare-form-tags-eg-8" />
    &lt;/dialog&gt;
</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-form-tags-eg-1">
              <para>All dialogs are placed into packages using the <sgmltag
              class="starttag">dialogs</sgmltag> tag so that they may be
              organized appropriately.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-2">
              <para>Each dialog is declared using a <sgmltag
              class="starttag">dialog</sgmltag> tag and is uniquely identified
              with a name. The fully qualfied name of the dialog becomes
              <replaceable>packageName</replaceable>.<replaceable>dialogName</replaceable>.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-3">
              <para>Dialogs may contain a <sgmltag
              class="starttag">frame</sgmltag> tag so that it can have an
              appropriate heading and borders if desired.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-4">
              <para>Dialogs must contain one or more <sgmltag
              class="starttag">field</sgmltag> tags that declare the input
              that needs to be obtained. All <sgmltag
              class="starttag">field</sgmltag> tags must specify a <sgmltag
              class="attribute">type</sgmltag> attribute that indicates the
              type of data that should be allowed along with one or more other
              attributes that control validation, data entry, and other
              rules.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-5">
              <para>NEF ships with many different high-level field types, all
              of which know how to render and validate themselves.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-6">
              <para>The <sgmltag class="starttag">field</sgmltag> tags may
              contain <sgmltag class="starttag">conditional</sgmltag> tags
              that allow some of the behavior of the field to change at
              runtime based on other field values, the request/response cycle,
              session information, or other arbitrary rules.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-7">
              <para>A special <sgmltag class="starttag">field</sgmltag>
              <sgmltag class="attribute">type</sgmltag>=<sgmltag
              class="attvalue">html</sgmltag> is provided so that the content
              of the field may be completely customized using a templating
              system or other means.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-8">
              <para>A <sgmltag class="starttag">director</sgmltag> tag is used
              for forms submission and to control navigation out of a dialog
              after processing is completed. Different directors may be
              created and reused for various purposes such as having a
              different set of buttons for confirm dialogs versus data entry
              dialogs.</para>
            </callout>
          </calloutlist>

          <note>
            <para>Almost all <sgmltag class="starttag">dialog</sgmltag> and
            <sgmltag class="starttag">field</sgmltag> tag attributes support
            Value Sources for their values so the values may be static or
            dynamic (see <xref linkend="section-value-sources" />). This
            allows, for example the captions, headings, and all user-visible
            values to be properly placed in property files or other external
            resources and mapped in a language-specific manner for
            internationlization purposes. Also, it means that the values of
            fields and select choices may be bound to database values,
            request/response values, or other dynamic sources. The important
            thing to understand is that even though the declarations are in a
            static XML file, the values of the descriptors are capable of
            being dynamic.</para>
          </note>

          <note>
            <para>Please see <xref linkend="xdm-tags-ref" /> for instructions
            on how to use the Console to review tag documentation and use the
            Tags Tree to get further details on the <sgmltag
            class="starttag">dialogs</sgmltag>, <sgmltag
            class="starttag">dialog</sgmltag>, <sgmltag
            class="starttag">field</sgmltag>, and related tags.</para>
          </note>
        </section>
      </section>

      <section>
        <title>Declaring the Data Management Layer</title>

        <para>The data manager layer tags are broken up into several groups:
        static queries, dynamic queries, schema management, and connection
        management, and database vendor management. Almost all of the data
        management layer tags are managed by Axiom.</para>

        <section>
          <title>Introduction to Static Query Declarations (Static Data Access
          Objects)</title>

          <para>That static query and data access objects (DAOs) declarations
          are comprised of the <sgmltag class="starttag">queries</sgmltag>,
          <sgmltag class="starttag">query</sgmltag>, and <sgmltag
          class="starttag">params</sgmltag> tags.</para>

          <example>
            <title>Query Tags in the Data Management Layer</title>

            <programlisting role="xml">&lt;project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;
...

&lt;<emphasis role="bold">queries</emphasis> package="test"&gt; <co
                id="declare-data-query-static-eg-1" />

    &lt;<emphasis role="bold">query</emphasis> <co
                id="declare-data-query-static-eg-2" /> name="get-asset-loans" <emphasis
                role="bold">data-src</emphasis>="jdbc/default"&gt; <co
                id="declare-data-query-static-eg-3" />

        select <co id="declare-data-query-static-eg-4" />
            asset_loan_id, last_name + ', ' + first_name, Loan_Type.caption, loan_begin_date, loan_end_date, returned
        from
            Asset_Loan, Loan_Type, Borrower
        where
            loan_type = Loan_Type.id and
            Asset_Loan.borrower_id = Borrower.borrower_id and
            Asset_Loan.asset_id = ?
        order
            by loan_begin_date desc

        &lt;<emphasis role="bold">params</emphasis>&gt; <co
                id="declare-data-query-static-eg-5" />
            <emphasis role="bold">&lt;param value="request:asset_id"/&gt;</emphasis> <co
                id="declare-data-query-static-eg-6" />
        &lt;/params&gt;
    &lt;/query&gt;
</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-data-query-static-eg-1">
              <para>All queries are placed into packages using the <sgmltag
              class="starttag">queries</sgmltag> tag so that they may be
              organized appropriately.</para>
            </callout>

            <callout arearefs="declare-data-query-static-eg-2">
              <para>Each query is declared using a <sgmltag
              class="starttag">query</sgmltag> tag and is uniquely identified
              with a name. The fully qualfied name of the query becomes
              <replaceable>packageName</replaceable>.<replaceable>queryName</replaceable>
              and may be treated as a read-only database-indendent DAO (data
              access object).</para>
            </callout>

            <callout arearefs="declare-data-query-static-eg-3">
              <para>A query may be assigned a <sgmltag>data-src</sgmltag>
              attribute which may be dynamically calculated to connect to
              different data sources or may default to a common data
              source.</para>
            </callout>

            <callout arearefs="declare-data-query-static-eg-4">
              <para>The SQL for the query is placed in the XML. This way, all
              SQL is external from Java code and may be tuned, optimized, and
              modified separate from the code that calls it. Notice that the
              perferred method of creating static query objects to to not use
              SQL injection (replaceable SQL) and instead rely on bind
              parameters. If SQL Injection (or SQL rewriting) is required,
              then portions of actual SQL may be made replaceable using Value
              Sources as well.</para>
            </callout>

            <callout arearefs="declare-data-query-static-eg-5">
              <para>Each query that requires parameters may have a <sgmltag
              class="starttag">params</sgmltag>.</para>
            </callout>

            <callout arearefs="declare-data-query-static-eg-6">
              <para>Each <sgmltag class="starttag">params</sgmltag> tag must
              have one or more <sgmltag class="starttag">param</sgmltag> tags
              along with <sgmltag class="attribute">value</sgmltag>
              attributes. The <sgmltag class="attribute">value</sgmltag>
              attribute supports Value Sources for its value so the value may
              be static or dynamic (see <xref
              linkend="section-value-sources" />). This allows, for example,
              the parameter to a query to be obtained dynamically from the
              runtime environment. Every <sgmltag
              class="starttag">query</sgmltag> tag also becomes a real Java
              object so parameters may be passed into Java methods for the
              object as well (which would override what was specified in the
              XML).</para>
            </callout>
          </calloutlist>

          <note>
            <para>A single <sgmltag class="starttag">query</sgmltag> tag may
            actually contain various SQL texts, each for a different database.
            For example, the <sgmltag class="starttag">query</sgmltag> tag
            supports defining multiple SQL statements for any given name so
            that the programmer only calls the right object and the SQL for
            the proper database will be called.</para>
          </note>

          <note>
            <para>Please see <xref linkend="xdm-tags-ref" /> for instructions
            on how to use the Console to review tag documentation and use the
            Tags Tree to get further details on the <sgmltag
            class="starttag">queries</sgmltag> and <sgmltag
            class="starttag">query</sgmltag> tags.</para>
          </note>
        </section>

        <section>
          <title>Introduction to Stored Procedure Declarations (Remote Data
          Access Objects)</title>

          <para>The stored procedure and data access objects (DAOs)
          delcarations are comprised of the <sgmltag
          class="starttag">stored-procedures</sgmltag>, <sgmltag
          class="starttag">stored-procedure</sgmltag>, and <sgmltag
          class="starttag">params</sgmltag> tags.</para>

          <example>
            <title>Stored Procedure Tags in the Data Management Layer</title>

            <programlisting role="xml">project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;
...

&lt;<emphasis role="bold">stored-procedures</emphasis> package="pkg_test"&gt; <co
                id="declare-data-sp-eg-1" />

    &lt;stored-procedure name="getVersion" data-src="jdbc/oracle"&gt;

        { ? = call pkg_test.getVersion() }

        &lt;params&gt;
            &lt;param type="out" sql-type="varchar" value="session:pkg_return_value"/&gt;
        &lt;/params&gt;
    &lt;/stored-procedure&gt;

    &lt;<emphasis role="bold">stored-procedure</emphasis> <co
                id="declare-data-sp-eg-2" /> name="appendString" data-src="jdbc/oracle"&gt; <co
                id="declare-data-sp-eg-3" />

        { call pkg_test.doSomeAction(?, ?, ?) }  <co id="declare-data-sp-eg-4" />

        &lt;params&gt; <co id="declare-data-sp-eg-5" />
            &lt;param type="in-out" sql-type="varchar" value="request-attr:string1"/&gt; <co
                id="declare-data-sp-eg-6" />
            &lt;param type="in" sql-type="varchar" value="request-attr:string2"/&gt;
            &lt;param type="in" sql-type="integer" value="request-attr:tab"/&gt;
        &lt;/params&gt;
    &lt;/stored-procedure&gt;</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-data-sp-eg-1">
              <para>All stored procedures are placed into packages using the
              <sgmltag class="starttag">stored-procedures</sgmltag> tag so
              that they may be organized appropriately.</para>
            </callout>

            <callout arearefs="declare-data-sp-eg-2">
              <para>Each stored procedure is declared using a <sgmltag
              class="starttag">stored-procedure</sgmltag> tag and is uniquely
              identified with a name. The fully qualfied name of the callable
              procedure becomes
              <replaceable>packageName</replaceable>.<replaceable>storeProcedureName</replaceable>
              and may be treated as a database-indendent remote DAO (data
              access object).</para>
            </callout>

            <callout arearefs="declare-data-sp-eg-3">
              <para>A stored procedure may be assigned a
              <sgmltag>data-src</sgmltag> attribute which may be dynamically
              calculated to connect to different data sources or may default
              to a common data source.</para>
            </callout>

            <callout arearefs="declare-data-query-static-eg-4">
              <para role="xml">The SQL, using standard JDBC syntax, for the
              stored procedure call is placed in the XML. This way, all the
              JDBC call statements are external from Java code. If some
              portion of the stored procedure call is dynamic (such as the
              procedure name), then portions of the JDBC call statement may be
              made replaceable using Value Sources.</para>
            </callout>

            <callout arearefs="declare-data-sp-eg-5">
              <para>Each stored procedure must have a <sgmltag
              class="starttag">params</sgmltag> tag for declaration of
              parameters.</para>
            </callout>

            <callout arearefs="declare-data-query-static-eg-6">
              <para>Each <sgmltag class="starttag">params</sgmltag> tag must
              have one or more <sgmltag class="starttag">param</sgmltag> tags
              along with <sgmltag class="attribute">value</sgmltag>
              attributes. All <emphasis>in</emphasis> parameters and
              <emphasis>out</emphasis> parameters must be sequentially defined
              to match the stored procedure's signature and the
              <emphasis>flow</emphasis> of the parameter is defined using the
              <sgmltag class="attribute">type</sgmltag> attribute. There are
              only three values available for <sgmltag
              class="attribute">type</sgmltag> attribute: <sgmltag
              class="attvalue">in</sgmltag>, <sgmltag
              class="attvalue">out</sgmltag>, and <sgmltag
              class="attvalue">in-out</sgmltag>. Also, the attribute <sgmltag
              class="attribute">sql-type</sgmltag> must be defined to reflect
              what kind of object is being returned or bound. The <sgmltag
              class="attribute">value</sgmltag> attribute is used to currently
              hold either the input for the bind variables or the return value
              of the registered out variables. The <sgmltag
              class="attribute">value</sgmltag> attribute supports Value
              Sources for its value so the value may be static or dynamic (see
              <xref linkend="section-value-sources" />). This allows, for
              example, the parameter to a stored procedure to be obtained
              dynamically from the runtime environment. Every <sgmltag
              class="starttag">stored-procedure</sgmltag> tag also becomes a
              real Java object so parameters may be passed into Java methods
              for the object as well (which would override what was specified
              in the XML).</para>
            </callout>
          </calloutlist>

          <note>
            <para>Please see <xref linkend="xdm-tags-ref" /> for instructions
            on how to use the Console to review tag documentation and use the
            Tags Tree to get further details on the <sgmltag
            class="starttag">stored-procedures</sgmltag> and <sgmltag
            class="starttag">stored-procedure</sgmltag> tags.</para>
          </note>
        </section>

        <section>
          <title>Introduction to Dynamic Query Declarations (Dynamic Data
          Access Objects)</title>

          <para>The dynamic queries data access objects (DAOs) declarations
          are comprised of the <sgmltag class="starttag">query-defn</sgmltag>,
          <sgmltag class="starttag">field</sgmltag>, and <sgmltag
          class="starttag">join</sgmltag> tags. Once declared, the query
          definition supports completely automatic generation of SQL based on
          user selections.</para>

          <example>
            <title>Query Definition Tags in the Data Management Layer</title>

            <programlisting role="xml">&lt;project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;
...

&lt;<emphasis role="bold">query-defn</emphasis> name="books"&gt; <co
                id="declare-data-query-defn-eg-1" />

    &lt;<emphasis role="bold">field</emphasis> name="book_id" caption="Book ID" <emphasis
                role="bold">join="BookInfo"</emphasis> column="id"/&gt; <co
                id="declare-data-query-defn-eg-2" />
    &lt;field name="name" caption="Name" join="BookInfo" column="name"/&gt;
    &lt;field name="author" caption="Author" join="BookInfo" column="author"/&gt;
    &lt;field name="genre_id" caption="Genre ID" join="BookInfo" column="genre"/&gt;
    &lt;field name="genre_caption" caption="Genre" join="BookType" column="caption"/&gt;
    &lt;field name="isbn" caption="ISBN" join="BookInfo" column="isbn"/&gt;

    &lt;<emphasis role="bold">join</emphasis> name="BookInfo" table="book_info"/&gt; <co
                id="declare-data-query-defn-eg-3" />
    &lt;join name="BookType" table="book_type" condition="BookType.id = BookInfo.genre"/&gt;
</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-data-query-defn-eg-1">
              <para>All query definitions are declared using the <sgmltag
              class="starttag">query-defn</sgmltag> tag and are uniquely
              identified with a name.</para>
            </callout>

            <callout arearefs="declare-data-query-defn-eg-2">
              <para>Each query definition contains one ore more <sgmltag
              class="starttag">field</sgmltag> tags that declare the universe
              of selectable fields. The <sgmltag
              class="starttag">field</sgmltag> tags are specified so that
              Axiom knows what fields the user should be allowed to select.
              Query definition fields may come from a mix of tables so long as
              they have appropriately defined <sgmltag
              class="attribute">join</sgmltag> attribute values.</para>
            </callout>

            <callout arearefs="declare-data-query-defn-eg-3">
              <para>Each query definition contains one ore more <sgmltag
              class="starttag">join</sgmltag> tags that declare the source
              table for fields. The <sgmltag class="starttag">join</sgmltag>
              tags are specified so that Axiom knows which tables to connect
              to which fields.</para>
            </callout>
          </calloutlist>

          <note>
            <para>Please see <xref linkend="xdm-tags-ref" /> for instructions
            on how to use the Console to review tag documentation and use the
            Tags Tree to get further details on the <sgmltag
            class="starttag">query-defn</sgmltag>, <sgmltag
            class="starttag">field</sgmltag> and <sgmltag
            class="starttag">join</sgmltag> tags.</para>
          </note>
        </section>

        <section>
          <title>Introduction to Schema Management Declarations</title>

          <para>The schema management descriptors are specified using the
          <sgmltag class="starttag">schema</sgmltag>, <sgmltag
          class="starttag">table</sgmltag>, and <sgmltag
          class="starttag">column</sgmltag> tags. Once declared, the schema
          descriptor supports completely automatic generation of SQL DML
          (insert/updates/removes), SQL DDL (create tables, objects, etc), and
          XML import/export. Schema tags support full relational integrity and
          may actually be used to define meta data to support Java-based
          relational integrity for existing and legacy databases that may not
          be built with fully relational integrity.</para>

          <example>
            <title>Schema Tags in the Data Management Layer</title>

            <programlisting role="xml">&lt;project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;
...

&lt;<emphasis role="bold">schema</emphasis> name="db"&gt; <co
                id="declare-data-schema-eg-1" />
    <emphasis role="bold">&lt;xdm:include resource="com/netspective/axiom/conf/schema.xml"/&gt;</emphasis> <co
                id="declare-data-schema-eg-2" />

    &lt;<emphasis role="bold">data-type</emphasis> name="text" <emphasis
                role="bold">class="com.netspective.axiom.schema.column.type.TextColumn"</emphasis>&gt; <co
                id="declare-data-schema-eg-3" />
        &lt;size&gt;32&lt;/size&gt;
        &lt;<emphasis role="bold">sql-ddl</emphasis>&gt; <co
                id="declare-data-schema-eg-4" />
            &lt;define dbms="ansi" xdm:replace-template-expressions="no"&gt;varchar(${column.getSize()})&lt;/define&gt;
            &lt;define dbms="oracle" xdm:replace-template-expressions="no"&gt;varchar2(${column.getSize()})&lt;/define&gt;
        &lt;/sql-ddl&gt;
    &lt;/data-type&gt;

    &lt;<emphasis role="bold">table-type</emphasis> name="Entity" <emphasis
                role="bold">class="my.base.TableClass"</emphasis>&gt; <co
                id="declare-data-schema-eg-5" />
        &lt;column <emphasis role="bold">name="${owner.name.toLowerCase()}_id"</emphasis> <co
                id="declare-data-schema-eg-6" /> <emphasis role="bold">type="auto-inc"</emphasis> <co
                id="declare-data-schema-eg-7" />
                <emphasis role="bold">primary-key="yes" </emphasis>descr="Unique identifier for ${owner.name}"/&gt;
    &lt;/table-type&gt;

    &lt;table-type name="Person" <emphasis role="bold">type="Entity"</emphasis>&gt; <co
                id="declare-data-schema-eg-8" />
        &lt;column name="first_name" <emphasis role="bold">type="text"</emphasis> size="64" descr="The person's first name"/&gt;
        &lt;column name="last_name" type="text" size="64" descr="The person's last name"/&gt;
    &lt;/table-type&gt;

    &lt;<emphasis role="bold">table</emphasis> name="Borrower" <emphasis
                role="bold">type="Person"</emphasis>&gt; <co
                id="declare-data-schema-eg-9" />
        &lt;!-- no columns are being added, it's just first name and last name --&gt;
    &lt;/table&gt;

    &lt;table name="Asset" abbrev="asset" type="Entity,Presentation"&gt;
        &lt;column name="type" lookup-ref="Asset_Type" required="yes" descr="The type of asset"/&gt;
        &lt;column name="name" type="text" size="64" required="yes" descr="Name of the asset"/&gt;
        &lt;column name="quantity" type="integer" required="yes"/&gt;
    &lt;/table&gt;

    &lt;table name="Asset_Type" abbrev="atype" <emphasis role="bold">type="Enumeration"</emphasis>&gt; <co
                id="declare-data-schema-eg-10" />
        &lt;enumerations&gt;
            &lt;enum&gt;Other&lt;/enum&gt;
            &lt;enum&gt;Software&lt;/enum&gt;
            &lt;enum&gt;Periodical&lt;/enum&gt;
            &lt;enum&gt;Book&lt;/enum&gt;
        &lt;/enumerations&gt;
    &lt;/table&gt;</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-data-schema-eg-1">
              <para>All schemas are declared using the <sgmltag
              class="starttag">schema</sgmltag> tag and are uniquely
              identified with a name. You may define multiple schemas within
              the same project.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-2">
              <para>Schemas components like <sgmltag
              class="starttag">data-types</sgmltag> and <sgmltag
              class="starttag">table-types</sgmltag> that comprise a data
              dictionary may be externalized and shared across projects. The
              default
              <filename>com/netspective/axiom/conf/schema.xml</filename>
              resource file contains dozens of built-in data types and table
              types that may be extended or just used. Type such as text,
              integer, float, currency, date, and even composite types such as
              duration are built-into Axiom.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-3">
              <para>Each schema may define <sgmltag
              class="starttag">data-type</sgmltag> tags that act as column
              templates. Each data type may specify a special handler class as
              well so that actual functionality may be placed into Java
              classes.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-4">
              <para>Each <sgmltag class="starttag">data-type</sgmltag> tag may
              contain <sgmltag class="starttag">sql-ddl</sgmltag> tags that
              describe what a logical data type declaration should be
              physically constructed as when the SQL DDL is generated. Support
              for complete database independence is built-in.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-5">
              <para>Each schema may define <sgmltag
              class="starttag">table-type</sgmltag> tags that act as templates
              templates. Each table type may specify a special handler class
              as well so that actual functionality may be placed into Java
              classes. Any number of columns may be defined in a table type
              and automatically placed into tables that consume the table
              type.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-6">
              <para>In table type templates the names of columns may be
              auto-generated so that they follow a consistent scheme. In this
              case we're saying that all Entity tables should have an
              auto-incrementing primary key that is named the same name as the
              table plus '_id'.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-7">
              <para>Full support for database-independent auto-generated
              columns is provided. If a column is defined as an <sgmltag
              class="attvalue">auto-inc</sgmltag> column that column will
              automatically use sequences for its implementation in Oracle and
              an IDENTITY type in SQL *Server (Axiom will figure out the
              proper database at runtime). Support for a database-neutral GUID
              type is also available if non-numeric auto increment
              capabilities are required.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-8">
              <para>Type inheritance is supported in both data types and table
              types. A <sgmltag class="starttag">table-type</sgmltag> tag may
              use the <sgmltag class="attribute">type</sgmltag> attribute to
              extend other table types which would declare that the
              <literal>Person</literal> table type extends the
              <literal>Entity</literal> table type so that when the
              <literal>Person</literal> table type is assigned to a table it
              will get the contents of both table types.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-9">
              <para>A <sgmltag class="starttag">table</sgmltag> tag may use
              the <sgmltag class="attribute">type</sgmltag> attribute to
              consume the contents of table-types. The
              <literal>Borrower</literal> table in this case declares that
              it's a Person type so it obtains the contents of the
              <literal>Person</literal> table type (and by inheritance the
              <literal>Entity</literal> table type as well).</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-10">
              <para>Special support is included for lookup tables. A <sgmltag
              class="starttag">table</sgmltag> tag may use the <sgmltag
              class="attribute">type</sgmltag> attribute specify that it's an
              <literal>Enumeration</literal> table and with that simple
              declaration the table will be treated as a static table meaning
              any retrievals for rows necessary in the table will be done
              purely Java-side and will not require any database calls. Also,
              the static data defined in the <sgmltag
              class="starttag">table</sgmltag> tag will automatically be
              populated into the database when the DDL is loaded.</para>
            </callout>
          </calloutlist>
        </section>
      </section>

      <section>
        <title>Declaring the Security Layer</title>

        <para>The security layer is declared using the <sgmltag
        class="starttag">login-manager</sgmltag>, <sgmltag
        class="starttag">access-control</sgmltag>, <sgmltag
        class="starttag">permission</sgmltag> and <sgmltag
        class="starttag">roles</sgmltag> tags.</para>

        <section>
          <title>Introduction to Login Management and User Authentication
          Tags</title>

          <para>All sophisticated applications require logins based on
          appropriate privileges so NEF has built-in support for such user
          authentication using the <sgmltag
          class="starttag">login-manager</sgmltag>, <sgmltag
          class="starttag">login-authenticator</sgmltag>, <sgmltag
          class="starttag">authenticated-user-class</sgmltag>, <sgmltag
          class="starttag">password-query</sgmltag>, and <sgmltag
          class="starttag">login-dialog</sgmltag> tags.</para>

          <example>
            <title>Login an Authentication Tags in the Security Layer</title>

            <programlisting role="xml">&lt;project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;
...

&lt;<emphasis role="bold">login-manager</emphasis> name="app" default="yes"&gt; <co
                id="declare-security-login-mgr-eg-1" />
    &lt;<emphasis role="bold">login-authenticator</emphasis> class="com.netspective.sparx.security.authenticator.DatabaseLoginAuthenticator"&gt; <co
                id="declare-security-login-mgr-eg-2" />
        &lt;<emphasis role="bold">authenticated-user-class</emphasis>&gt;app.cts.AppAuthenticatedUser&lt;/authenticated-user-class&gt; <co
                id="declare-security-login-mgr-eg-3" />
        &lt;<emphasis role="bold">password-query</emphasis>&gt; <co
                id="declare-security-login-mgr-eg-4" />
            select
                password
            from
                person_login
            where
                user_id = ?
        &lt;/password-query&gt;
        &lt;<emphasis role="bold">role-query</emphasis>&gt; <co
                id="declare-security-login-mgr-eg-5" />
            select
                role_id
            from
                person_role
            where
                user_id = ?
        &lt;/password-query&gt;
    &lt;/login-authenticator&gt;

    &lt;<emphasis role="bold">login-dialog</emphasis> retain-params="*"&gt; <co
                id="declare-security-login-mgr-eg-6" />
        &lt;frame heading="Welcome to the Clinical Trial System"/&gt;
        &lt;field name="user-id" type="text" caption="Login ID" required="yes" persist="yes" initial-focus="yes"/&gt;
        &lt;field name="password" type="text" caption="Password" mask-entry="yes" required="yes"/&gt;
    &lt;/login-dialog&gt;
&lt;/login-manager&gt;</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-security-login-mgr-eg-1">
              <para>A login manager is defined using the <sgmltag
              class="starttag">login-manager</sgmltag> tag and is uniquely
              identified with a name. You may define multiple login managers
              for different areas of your application or for multiple
              servlets. If no default login manager is specified no user
              authentication is required to enter an application.</para>
            </callout>

            <callout arearefs="declare-security-login-mgr-eg-2">
              <para>A <sgmltag class="starttag">login-authenticator</sgmltag>
              tag is used to specify all the options that will be used to
              actually perform the authentication. The
              DatabaseLoginAuthenticator class is built-in and is suitable for
              most uses. If you need alternate authentication schemes such as
              JAAS or your own custom routines those are also
              supported.</para>
            </callout>

            <callout arearefs="declare-security-login-mgr-eg-3">
              <para>The <sgmltag
              class="starttag">authenticated-user-class</sgmltag> tag is used
              to specify a class that will be used to manage an authenticated
              user. There are routines for managing the user id, the user's
              roles, permissions, and other attributes.</para>
            </callout>

            <callout arearefs="declare-security-login-mgr-eg-4">
              <para>The <sgmltag class="starttag">password-query</sgmltag> tag
              is used to specify the SQL that should be executed to obtain a
              valid passoword. This query is sent a single parameter (the user
              id typed into the dialog) and if it returns a single value it is
              considered the password. That password is then matched against
              what the user types in. Support for encrypted passwords is also
              built-in.</para>
            </callout>

            <callout arearefs="declare-security-login-mgr-eg-5">
              <para>The <sgmltag class="starttag">role-query</sgmltag> tag is
              used to specify the SQL that should be executed to obtain a list
              of access control list roles assigned to an authenticated user.
              This query is sent a single parameter (the user id typed into
              the dialog) and it should return the list of roles assigned to
              the user.</para>
            </callout>

            <callout arearefs="declare-security-login-mgr-eg-6">
              <para>The <sgmltag class="starttag">login-dialog</sgmltag> tag
              is used to declare the contents of the dialog that will be used
              to get the username and password.</para>
            </callout>
          </calloutlist>
        </section>

        <section>
          <title>Introduction to Access Control and User Authorization
          Tags</title>

          <para>Once a user has been authenticated they may still require
          authorization to perform certain activities. NEF has built-in
          support for building user authorization rules and declartively
          controlling access to application components based on authorization
          rules such as roles and permissions.</para>

          <example>
            <title>Access Control and Authorization Tags in the Security
            Layer</title>

            <programlisting role="xml">&lt;project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;
...

&lt;<emphasis role="bold">access-control-list</emphasis> name="acl"&gt; <co
                id="declare-security-acl-eg-1" />
    &lt;<emphasis role="bold">permission</emphasis> name="app"&gt; <co
                id="declare-security-acl-eg-2" />
        &lt;<emphasis role="bold">permission</emphasis> name="orders"&gt; <co
                id="declare-security-acl-eg-3" />
            &lt;permission name="order_list"/&gt;
            &lt;permission name="create_order"/&gt;
            &lt;permission name="edit_order"/&gt;
            &lt;permission name="view_order"/&gt;
            &lt;permission name="delete_order"/&gt;
        &lt;/permission&gt;
    &lt;/permission&gt;

    &lt;<emphasis role="bold">role</emphasis> name="role"&gt; <co
                id="declare-security-acl-eg-4" />
        &lt;<emphasis role="bold">role</emphasis> name="super-user"&gt; <co
                id="declare-security-acl-eg-5" />
            &lt;grant permission="/acl/app/orders"/&gt;
        &lt;/role&gt;
        &lt;role name="normal-user"&gt;
            &lt;<emphasis role="bold">grant</emphasis> permission="/acl/app/orders"/&gt; <co
                id="declare-security-acl-eg-6" />
            &lt;<emphasis role="bold">revoke</emphasis> permission="/acl/app/orders/delete_order"/&gt; <co
                id="declare-security-acl-eg-7" />
        &lt;/role&gt;
    &lt;/role&gt;
&lt;/access-control-list&gt;</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-security-acl-eg-1">
              <para>An access control list is defined using the <sgmltag
              class="starttag">access-control-list</sgmltag> tag and is
              uniquely identified with a name. You may define multiple access
              control list managers for different areas of your application or
              for multiple servlets.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-2">
              <para>The <sgmltag class="starttag">permission</sgmltag> tag
              defines a feature or function that needs to be protected.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-3">
              <para>The <sgmltag class="starttag">permission</sgmltag> tag may
              be defined hierarchically.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-4">
              <para>The <sgmltag class="starttag">role</sgmltag> tag defines a
              user role.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-5">
              <para>The <sgmltag class="starttag">role</sgmltag> tag may be
              defined hierarchically.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-6">
              <para>Each <sgmltag class="starttag">role</sgmltag> tag may
              grant one or more permissions.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-7">
              <para>Each <sgmltag class="starttag">role</sgmltag> tag may
              revoke one or more permissions.</para>
            </callout>
          </calloutlist>

          <note>
            <para>Roles may be permissive or restrictive. This means you can
            define a role to start out a very permissive and restrict only
            particular permissions or let it start out as very restrive and
            only grant specific permissions. Roles and permissions are also
            hierarchical so that if you allow a high-level role or permission
            you will also be assigning all its children.</para>
          </note>
        </section>
      </section>
    </section>

    <section>
      <title>Unit Test and User Demonstrations</title>

      <para>Unit testing, in case you are not familiar with the terminology,
      refers to testing individual components of an application thoroughly
      before they are integrated with the rest of the application. This allows
      a developer to run the component through many series of tests to ensure
      it performs as expected and desired before integrating it into a
      finished application.</para>

      <para>Every NEF XML tag you use to declare your application's
      requirements has an automated means to verify and test the declaration
      within the Console or your application. At this point you may begin to
      involve your customers by demonstrating the forms, validation, pages,
      etc within the Console or application -- before you start writing or
      customizing any Java code.</para>

      <section>
        <title>Unit Testing and Demonstrating the Presentation Layer</title>

        <para>NEFS enables you to unit test your application's presentation
        layer through the <guimenu>Presentation </guimenu>tab within the
        Console.</para>

        &__unit-test-dialog__du3yjpcw;
      </section>

      <section>
        <title>Unit Testing the Data Management Layer</title>

        <para>NEFS enables you to unit test your application's data management
        layer through the Console. To unit test different components of the
        data management layer, go to <guimenu>Data Management</guimenu> tab
        within the Console.</para>

        &__unit-test-sql-queries__du3wqiiz;
      </section>

      <section>
        <title>Unit Testing the Security Layer</title>

        <para>TODO: documentation coming soon...</para>
      </section>
    </section>

    <section>
      <title id="section-generate-code">Generate Code</title>

      <para>Although NEF prefers to use <emphasis>instantiated</emphasis> code
      directly from class files for most objects there are many cases when
      generating code is more convenient. This section describes the types of
      code that NEF generates <filename>.java</filename> files for (as opposed
      to just instantiating dynamic objects using Java class loading). All
      code is generated using Ant build tool and the Ant build project files,
      which are also XML, may be run within the Console or from the command
      command line. If you are running the Ant scripts from Console, you can
      access the list of targets by going to Console's <menuchoice>
          <guimenu>Project</guimenu>

          <guimenuitem>Ant Build</guimenuitem>
        </menuchoice> page.</para>

      <example>
        <title>How to Generate Code using the Console</title>

        <screenshot>
          <graphic fileref="./resources/images/screen-console-project-ant-build.gif" />
        </screenshot>

        <para>As you can see in the screen shot above, you simply choose a
        target and click Ok to run it. If you need information on what each
        target does, the descriptions below the dialog provide the
        details.</para>
      </example>

      <section>
        <title>Location of Generated Code</title>

        <para>By default, all code that NEF generates uses the package called
        <literal>auto</literal> and is placed in <filename
        class="directory">APP_ROOT/WEB-INF/classes/auto</filename> directory.
        The <filename
        class="directory">APP_ROOT/WEB-INF/classes/auto</filename> directory
        may be destroyed and recreated as necessary and you should not place
        any custom source files into that directory. If this directory is not
        convenit (or if the package name is already in use) you may change it
        by modifying the
        <filename>APP_ROOT/WEB-INF/sparx/conf/ant-build-project.xml</filename>
        Ant build file.</para>
      </section>

      <section>
        <title id="section-generate-code-types">Generating ID
        Constants</title>

        <para>NEF generates typed Java constants for all dialog, field, query,
        stored procedure, and schema identifiers in your project's XML files.
        The ID constants are generated by using the
        <literal>generate-id-constants</literal> target in the Ant build file.
        Instead of accessing identifiers by strings programmers can access the
        identifiers using Java constants. Using Java constants to access
        identifiable objects in your Java code is highly desirable so that if
        names of items change your project, the compiler will identify
        problems in your code that might otherwise not be found until
        runtime.<mediaobjectco>
            <imageobjectco>
              <areaspec>
                <area coords="1" id="genarate-id-constants-co-1" />

                <area coords="2" id="genarate-id-constants-co-2" />

                <area coords="3" id="genarate-id-constants-co-3" />

                <area coords="4" id="genarate-id-constants-co-4" />

                <area coords="5" id="genarate-id-constants-co-5" />

                <area coords="6" id="genarate-id-constants-co-6" />

                <area coords="7" id="genarate-id-constants-co-7" />

                <area coords="8" id="genarate-id-constants-co-8" />
              </areaspec>

              <imageobject>
                <imagedata fileref="./resources/images/screen-generate-code-id-constants-folders.gif" />
              </imageobject>

              <calloutlist>
                <callout arearefs="genarate-id-constants-co-1">
                  <para>All of the presentation tag identifiers in tags like
                  <sgmltag class="starttag">navigation-tree</sgmltag>,
                  <sgmltag class="starttag">page</sgmltag>, <sgmltag
                  class="starttag">dialogs</sgmltag>, <sgmltag
                  class="starttag">dialog</sgmltag>, and <sgmltag
                  class="starttag">field</sgmltag> tags are placed in the
                  <literal>auto.id.pres</literal> (short for
                  <emphasis>presentation</emphasis>) package.</para>
                </callout>

                <callout arearefs="genarate-id-constants-co-2">
                  <para>The identifiers specific to the <sgmltag
                  class="starttag">dialogs</sgmltag>, <sgmltag
                  class="starttag">dialog</sgmltag>, and <sgmltag
                  class="starttag">field</sgmltag> tags are placed in the
                  <literal>auto.id.pres.form</literal> package.</para>
                </callout>

                <callout arearefs="genarate-id-constants-co-3">
                  <para>The identifiers specific to the <sgmltag
                  class="starttag">navigation-tree</sgmltag> and <sgmltag
                  class="starttag">page</sgmltag> tags are placed in the
                  <literal>auto.id.pres.navigation</literal> package.</para>
                </callout>

                <callout arearefs="genarate-id-constants-co-4">
                  <para>All of the different tree names are placed in the
                  <literal>auto.id.pres.navigation.Navigation</literal>
                  package.</para>
                </callout>

                <callout arearefs="genarate-id-constants-co-5">
                  <para>All of the SQL (data management) tag identifiers like
                  <sgmltag class="starttag">queries</sgmltag>, <sgmltag
                  class="starttag">query</sgmltag>, <sgmltag
                  class="starttag">schema</sgmltag>, <sgmltag
                  class="starttag">table</sgmltag>, and <sgmltag
                  class="starttag">column</sgmltag> tags are placed in the
                  <literal>auto.id.sql</literal> package.</para>
                </callout>

                <callout arearefs="genarate-id-constants-co-6">
                  <para>The identifiers specific to the <sgmltag
                  class="starttag">queries</sgmltag> and <sgmltag
                  class="starttag">query</sgmltag> tags are placed in the
                  <literal>auto.id.sql.query</literal> package.</para>
                </callout>

                <callout arearefs="genarate-id-constants-co-7">
                  <para>The identifiers specific to the <sgmltag
                  class="starttag">schema</sgmltag>, <sgmltag
                  class="starttag">table</sgmltag>, and <sgmltag
                  class="starttag">column</sgmltag> tags are placed in the
                  <literal>auto.id.sql.schema</literal> package.</para>
                </callout>

                <callout arearefs="genarate-id-constants-co-8">
                  <para>One of the most useful features of the ID constant
                  generators is that it creates Java constants for enumerated
                  values in the database. So, if you have many tables that
                  have static lookup values those static values can become
                  actual Java constants using the <emphasis>Schema Enumeration
                  Tables</emphasis> feature.</para>
                </callout>
              </calloutlist>
            </imageobjectco>
          </mediaobjectco></para>
      </section>

      <section>
        <title>Generating Presentation Layer Code</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Generating Data Management Layer Code</title>

        <para>Generate SQL DDL (data definition language) for creating
        database schemas and generate the data access objects (DAOs) that
        become the Data Access Layer (DAL) for reading and writing content
        from the database. Each schema generated by Axiom automatically
        includes the ability to import data using XML (either for testing
        purposes or for production usage).</para>
      </section>

      <section>
        <title>Generating Security Layer code</title>

        <para>TODO: documentation coming soon...</para>
      </section>
    </section>

    <section>
      <title>Customize Code</title>

      <para>Use Java class inheritance, composition, or listeners to Customize
      your Sparx XML declarations. The Sparx XML declarations basically create
      common functionality. By adding Java code you will customize the
      declarations to execute customized business logic.</para>

      <section>
        <title>Customization Styles</title>

        <para>NEF supports code customization using either inheritance or
        delegation. Although both methods are supported, the delegation model
        is recommended to help ensure that changes in the NEF APIs do not
        affect your code. Inheritance is used for large-scale customizations
        and enhancing the framework itself while delegation is used to
        implement listeners and event processing customizations.</para>
      </section>

      <section>
        <title>Customizing Presentation Layer Code</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Customizing Data Management Layer Code</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Customizing Security Layer Code</title>

        <para>TODO: documentation coming soon...</para>
      </section>
    </section>

    <section>
      <title>Acceptance, Regression, and Load/Stress Testing</title>

      <para>Run functional/integration and acceptance tests of your combined
      Sparx XML declarations and Java code customizations. The actual style of
      tests and structural requirements of your tests will be
      application-dependent but the NEF includes numerous examples of how to
      perform automated acceptance testing of your applications using a tool a
      Canoo WebTest. WebTest is a Ant-based testing utility that fully
      automates the acceptance testing and regression testing process.</para>

      <section>
        <title>Acceptance Testing</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Multi-user and Thread-safety Testing</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Regression Testing</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Load/Stress Testing</title>

        <para>TODO: documentation coming soon...</para>
      </section>
    </section>

    <section>
      <title>Deploy</title>

      <para>Deploy your application once everything is working.</para>
    </section>
  </chapter>

  <chapter>
    <title>Key NEF Concepts</title>

    <para>This chapter outlines some of the important, global, concepts that
    you should be familiar with before embarking on developing your own
    applications.</para>

    <section>
      <title>Application Directory Structure</title>

      <para>Every NEF application shares the benefit of a standard directory
      structure. To see the structure of an empty application (one with only
      the basic files required for all applications), view the Project Folders
      tab of the <ulink
      url="http://www.netspective.com/nefs-starter-empty/console/project/folders">starter
      application</ulink>.</para>

      <figure>
        <title>NEF Standard Project Directory Structure</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="./resources/images/screen-starter-folders.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <variablelist>
        <varlistentry>
          <term>APP_ROOT</term>

          <listitem>
            <para>The root directory (in this case
            <literal>nefs-starter-empty</literal>) contains all the
            browser-accessible files for the application. This is commonly
            referred to as the <emphasis>Document Root</emphasis> for a
            website because it is the root directory visible to web browsers.
            It also contains a private directory, called
            <literal>WEB-INF</literal>, for the application to store NEF and
            Java servlet related files (it's called private because none of
            its contents will ever be served to end users). As already
            mentioned, all files in the application’s root directory are
            accessible through a web browser. All subdirectories in the
            application root other than <literal>WEB-INF</literal> will also
            be directly accessible through a browser. Therefore, if you put an
            index.jsp file in this directory, you should be able to access it
            using a URL of the form http://host:port/appName/index.jsp.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>APP_ROOT/resources</term>

          <listitem>
            <para>If present this directory tree contains all of the
            application's shared files that need to be served to end users of
            your applications. Web browser resources that your application
            needs such as images and scripts are placed here and will be
            served to your end users by their browser.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>APP_ROOT/sparx</term>

          <listitem>
            <para>This directory tree contains all of the Sparx shared files
            that need to be served to end users of your applications. Web
            browser resources that Sparx needs such as style sheets,
            JavaScript sources, images, and Console files are placed here and
            will be served to your end users by their browser. You should not
            modify files in this directory because it does not contain any
            programmer-modifiable files.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>APP_ROOT/resources/sparx</term>

          <listitem>
            <para>This directory tree (which is not present in the starter
            application or the diagram above) contains optional Sparx shared
            files and resources that usually belong in
            <literal>APP_ROOT/sparx</literal> but are being overridden by your
            application. For example, if you have your own stylesheets or
            images that need to replace something in Sparx, they would be
            placed in this directory. Because the
            <literal>APP_ROOT/sparx</literal> directory contents should never
            be modified, the <literal>APP_ROOT/resources/sparx</literal>
            directory gives you the opportunity to override Sparx resources
            without worrying about files being overwritten when Sparx is
            upgrade.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>APP_ROOT/WEB-INF</term>

          <listitem>
            <para>The <literal>WEB-INF</literal> directory is required by the
            J2EE Servlet Specification. It contains all files private to the
            application, meaning none of the files in this directory will be
            accessible to an end-user’s web-browser (except through the
            Netspective Console which optionally allows secure browsing of
            source files in <literal>WEB-INF</literal>).</para>

            <para>The <literal>APP_ROOT/WEB-INF/web.xml</literal> file
            configures your application for your J2EE Servlet container and
            you should refer to your application server’s documentation for
            how to configure the contents of that file. For Resin (the
            application server included in the NEF Evaluation Kit) you can
            refer to the documentation available at <ulink
            url="http://www.caucho.com">http://www.caucho.com</ulink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>WEB-INF/classes</term>

          <listitem>
            <para>This directory, which is a part of the J2EE Servlet
            Specification, holds all the custom Java source code written for
            the application. After the application is built, each Java source
            file in this directory contains a corresponding compiled version
            in the same location as the source.</para>

            <para>All Java classes in WEB-INF/classes are automatically
            included in the classpath of the application. Therefore if you
            have declared a dialog (in the project.xml file) to have a custom
            Java handler for complete or partial dialog processing, the Java
            source and compiled versions should be located somewhere in this
            directory structure. Any auxiliary Java classes that you might
            need should also be placed here.</para>

            <para>By default, you should place all of your Java classes in the
            directory <literal>WEB-INF/classes/app</literal> (or another
            appropriate subdirectory) because certain application servers will
            not work with Java classes that are not in a package.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>WEB-INF/classes/auto</term>

          <listitem>
            <para>Although this directory is not found in the starter package,
            it is automatically created by NEF when it generates classes for
            use by your application. It is called <literal>auto</literal>
            because the classes in there are auto-generated and should not be
            modified. You may refer to the <xref
            linkend="section-generate-code" /> to take a look at the types of
            generated code stored in this directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>WEB-INF/lib</term>

          <listitem>
            <para>This directory, which is a part of the J2EE Servlet
            Specification, holds all the Java Archive (JAR) files needed by
            your application. These include not only JAR files needed for
            Sparx but also extra JAR files needed by your own Java
            classes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>WEB-INF/sparx</term>

          <listitem>
            <para>Sparx uses the <literal>WEB-INF/sparx</literal> directory to
            store its project component descriptors. There is usually at least
            one <literal>project.xml</literal> file and may contain
            subdirectories if you wish to split up your application component
            declarations. The <emphasis
            role="bold">APP_ROOT/WEB-INF/sparx/project.xml</emphasis> is the
            file that drives all of the Sparx functionality in your
            application (see <xref linkend="nef-project-file" />).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>WEB-INF/sparx/conf</term>

          <listitem>
            <para>This directory contains sample <literal>web.xml</literal>
            configuration files for different application servers like
            WebLogic, WebSphere, Resin and Tomcat. It also contains Ant build
            files for compiling your application's classes.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title id="nef-project-file">The NEF Project File</title>

      <para>All of the NEF (Sparx, Axiom, and Commons) components are declared
      in an <emphasis>input source</emphasis> file known as the
      <emphasis>Project File</emphasis>. The Project File may be either a
      single file with all components or may be broken up into multiple files
      and pulled into the main Project File by using <sgmltag
      class="starttag">xdm:include</sgmltag> tags.</para>

      <example>
        <title>Basic NEF Project File</title>

        <programlisting role="xml">&lt;?xml version="1.0"?&gt;

&lt;<emphasis role="bold">project</emphasis> <emphasis role="bold">xmlns:xdm</emphasis>="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt; <co
            id="project-file-basic-eg-1" />

    &lt;xdm:include resource="com/netspective/commons/conf/commons.xml"/&gt; <co
            id="project-file-basic-eg-2" />
    &lt;xdm:include resource="com/netspective/axiom/conf/axiom.xml"/&gt; <co
            id="project-file-basic-eg-3" />
    &lt;xdm:include resource="com/netspective/sparx/conf/sparx.xml"/&gt; <co
            id="project-file-basic-eg-4" />
    &lt;xdm:include resource="com/netspective/sparx/conf/console.xml"/&gt; <co
            id="project-file-basic-eg-5" />

    <replaceable>&lt;!-- Your application tags go here. --&gt;</replaceable> <co
            id="project-file-basic-eg-6" />

    &lt;xdm:include file="your/own/file.xml"/&gt; <co
            id="project-file-basic-eg-7" />

    <replaceable>&lt;!-- Your other application tags go here. --&gt;</replaceable>
&lt;/project&gt;</programlisting>

        <calloutlist>
          <callout arearefs="project-file-basic-eg-1">
            <para>The root tag is called <sgmltag
            class="starttag">project</sgmltag> and should use the provided
            <literal>xdm</literal> namespace.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-2">
            <para>Include the Netspective Commons default component
            declarations. It uses the <literal>resource</literal> attribute so
            it will be located by searching the classpath and will usually
            find the file in the JAR file and directly read it from
            there.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-3">
            <para>Include the Netspective Axiom default component declarations
            and factory registrations. It uses the <literal>resource</literal>
            attribute so it will be located by searching the classpath and
            will usually find the file in the JAR file and directly read it
            from there.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-4">
            <para>Include the Netspective Sparx default component declarations
            and factory registrations. It uses the <literal>resource</literal>
            attribute so it will be located by searching the classpath and
            will usually find the file in the JAR file and directly read it
            from there.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-5">
            <para>Include the Netspective Enterprise Console servlet
            declarations and application components. If you are turning off
            the Console in your applications you may leave this line
            out.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-6">
            <para>This is the location where your component declarations will
            be done. Unless otherwise specified, all the components are
            declared right under the <sgmltag
            class="starttag">project</sgmltag> tag.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-7">
            <para>This line demonstrates how you can include your own XML
            files using the <literal>file</literal> attribute. In this
            example, because the file is not absolute it will be treated as
            relative to the calling file. The <sgmltag
            class="starttag">xdm:include</sgmltag> tag may be included
            anywhere in the file and simply takes items from the included file
            and places them into the calling file while parsing.</para>
          </callout>
        </calloutlist>
      </example>

      <note>
        <para>The <sgmltag class="starttag">xdm:include</sgmltag> tag is
        explained further in <xref linkend="section-xdm-include" />.</para>
      </note>

      <section>
        <title>Input Source</title>

        <para>The default Project File is
        <filename>APP_ROOT/WEB-INF/sparx/project.xml</filename> but may be
        configured to be a different file. Although you may choose an
        alternate location for the Project File, the remainder of this
        document assumes that the Project File is
        <filename>APP_ROOT/WEB-INF/sparx/project.xml</filename>. The project
        file may be either a physical file or be provided as a resource (URL)
        if desired. While looking at an NEF application, you can always find
        the Project File location by opening the Console for the given
        application and looking at the Console <menuchoice>
            <guimenu>Home</guimenu>
          </menuchoice> Page.</para>

        <screenshot>
          <graphic fileref="./resources/images/screen-console-home-project-file-highlight.gif" />
        </screenshot>

        <para>If you would like more information about where your Project File
        is and how it's being loaded, you will want to go to the Console's
        <menuchoice>
            <guimenu>Project</guimenu>

            <guimenuitem>Source</guimenuitem>
          </menuchoice> menu. That page will show not only the main file but
        all included resources, components, and files (all of the final paths
        of any <sgmltag class="starttag">xdm:include</sgmltag> tags).</para>

        <screenshot>
          <graphic fileref="./resources/images/screen-console-project-source.gif" />
        </screenshot>

        <para>If you would like to specify an alternate name for the Project
        File you may change the location in the application's
        <filename>WEB-INF/web.xml</filename> file.</para>

        <example>
          <title>Specifying a different location for the NEF Project
          File</title>

          <programlisting role="xml">&lt;web-app&gt;
      ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;SparxNavigationController&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.netspective.sparx.navigate.NavigationControllerServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;com.netspective.sparx.navigate.CONTROLLER_SERVLET_OPTIONS&lt;/param-name&gt;
            &lt;param-value&gt;<emphasis role="bold">--project=/WEB-INF/other/path/project.xml</emphasis>&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
      ...
&lt;/web-app&gt;</programlisting>
        </example>

        <note>
          <para>To learn more about the other controller servlet options
          allowed by Sparx, visit Console's <menuchoice>
              <guimenu>Project</guimenu>

              <guimenuitem>Configuration</guimenuitem>
            </menuchoice> page.</para>
        </note>
      </section>

      <section>
        <title>Errors and Warnings</title>

        <para>Because the NEF manages literally hundreds of objects and
        classes and allows you to use XML to declare some sophisticated object
        relationships, many errors and warnings may be displayed. Errors are
        always highlighted within your applications, the Console, and
        <literal>stdout</literal>. A few contrived errors have been created
        for the Hello World application and the following screen shots
        demonstrate how you will be able to tell if there are errors in your
        application.</para>

        <para><example>
            <title>NEF Error Reporting Samples</title>

            <para>The following screenshot highlights the line that will
            appear at the top of your application if there are any NEF
            errors.</para>

            <screenshot>
              <graphic fileref="./resources/images/screen-hello-world-error-line.gif" />
            </screenshot>

            <para>When you click on the Console link in the error message (or
            go to the application's Console <menuchoice>
                <guimenu>Project</guimenu>

                <guimenuitem>Source</guimenuitem>
              </menuchoice> tab) you will see something like the following.
            Notice that if there are any errors and you are viewing the
            Console you will see an error highlight at the top of the Console
            window. Once you're in the Console <menuchoice>
                <guimenu>Project</guimenu>

                <guimenuitem>Source</guimenuitem>
              </menuchoice> menu you will be presented with a listing of the
            errors in the middle of the page.</para>

            <screenshot>
              <graphic fileref="./resources/images/screen-console-error-highlight.gif" />
            </screenshot>
          </example></para>
      </section>

      <section>
        <title>The <classname>com.netspective.sparx.Project</classname>
        class</title>

        <para>All of the tags that are processed in the NEF Project file are
        managed by Java classes. The class that manages the XML root <sgmltag
        class="starttag">project</sgmltag> tag is called
        <classname>com.netspective.sparx.ProjectComponent</classname>. The
        <classname>ProjectComponent</classname> class owns an instance of the
        <classname>com.netspective.sparx.Project</classname> class. The
        <classname>Project</classname> class then has ownership of all of the
        tags contained within the <sgmltag class="starttag">project</sgmltag>
        tag.</para>

        <figure>
          <title>Overview of Classes Involved in Parsing and Processing the
          <sgmltag class="starttag">project</sgmltag> tag.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="resources/images/nefs-uml-class-project-overview.gif" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <section>
      <title>The XML Data Model (XDM)</title>

      <para>The eXtensible Markup Language (XML) plays an important role in
      NEF's ease of use, extensibility, and code generation. NEF declarations
      are performed using XML -- all dialogs, fields, validation rules, some
      conditional processing, all SQL statements, dynamic queries,
      configuration files, database schemas, and many other resources are
      stored in XML files that are re-usable across applications. Although XML
      is the preferred method for creating resource files, almost anything
      that can be specified in XML can also be specified using the NEF Java
      APIs. If you are not familiar with XML, please visit <ulink
      url="http://www.xml.com/">http://www.xml.com/</ulink> for some training
      materials. NEF uses the JAXP and SAX standards for parsing and
      processing XML files.</para>

      <para>NEF utilizes XML in a declarative, not imperative manner. What
      this means is that XML is not used as yet another imperative programming
      or expression language like Java, C/C++, or Pascal. Instead, it is
      simply used to declare classes, rules, specifications, and other
      application requirements that are automatically parsed, read, cached,
      and executed by one or more NEF components. The dynamic aspects of NEF
      applications comes from Java through the use of <literal>Value
      Source</literal> and <literal>Command</literal> interfaces, not a new
      programming language.</para>

      <section>
        <title>XDM Overview</title>

        <para>XDM is an acronym for "XML Data Model" and is designed to help
        Java programmers construct and configure Java objects using XML files
        without worrying about parsing and error checking. The
        <filename>APP_ROOT/WEB-INF/sparx/project.xml</filename> file uses XDM
        to declare all project components. The primary objective is to declare
        your object's data and structure in XML and have XDM automatically
        construct the objects and assign the data provided in an XML file with
        almost no performance penalties. XDM does not introduce a new language
        nor does it replace Java classes, methods, or business logic. The main
        use for XDM is to allow you to use resource files (XML) to declare the
        hierarchy and initial data model (state) of your objects. The reason
        there is almost no performance penalty is that the XDM simply reads
        the XML and invokes the exact same constructors and methods in your
        classes exactly as if you had done so by manually writing Java code
        (including inheritance and composition).</para>
      </section>

      <section>
        <title>XDM Features</title>

        <itemizedlist>
          <listitem>
            <para>XDM automatically translates XML tags and attributes to your
            object hierarchy and data model with no manual mapping or
            configuration.</para>
          </listitem>

          <listitem>
            <para>XDM uses simple JavaBeans naming standards and the Java
            Reflection API to instantiate and initialize the objects declared
            in the XML resource files.</para>

            <itemizedlist>
              <listitem>
                <para>XML elements (tags) are instantiated into runtime
                objects exactly as if you called the object constructor in
                Java code.</para>
              </listitem>

              <listitem>
                <para>XML attributes invoke Java class mutator (setter)
                methods exactly as if you called the set method in Java
                code.</para>
              </listitem>

              <listitem>
                <para>XML element text (PCDATA) may be automatically appended
                using configurable method calls.</para>
              </listitem>

              <listitem>
                <para>XML child elements that have element content can be
                configured to create child objects or call mutator (setter)
                methods. This allows you to use the element or attribute style
                of XML resource files.</para>
              </listitem>

              <listitem>
                <para>Automatic type conversion validates and translates text
                from XML attributes into the proper object's mutator (setter)
                method parameter types: boolean, int, float, String, etc.
                Automatic error checking will ensure that when your class
                setter method parameter type changes, the XDM will
                automatically validate the new parameter type.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>The translation process is configurable so that you can
            create element or attribute aliases (so that you can create XML
            tag and attribute names that may be mapped to different method
            names in Java than what the JavaBean standards would
            imply).</para>
          </listitem>

          <listitem>
            <para>XDM templates provide object composition and inheritance
            behavior exactly as Java code.</para>
          </listitem>

          <listitem>
            <para>XDM include files provide the capability to break out large
            object construction tasks into multiple resource files.</para>
          </listitem>

          <listitem>
            <para>XDM transformers provide the capability to filter XML files
            through XSLT or other transformations before object construction
            takes place.</para>
          </listitem>

          <listitem>
            <para>Using the factory design pattern, the XML traversal is
            separated from the object instantiation and method
            invocation.</para>
          </listitem>

          <listitem>
            <para>Custom handlers allow portions of XML to be handled
            manually.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="xdm-tags-ref">
        <title>XDM Tag Reference</title>

        <para>Because the NEF supports dozens of tags and hundreds of
        attributes spread across dozens of classes, the Enterprise Console has
        an automated tag reference to help you learn about the tags. The
        Console can even provide online documentation for your own classes and
        custom XDM elements. To view the online XDM tag reference, go to your
        applications' Console and click the <guimenu>XDM Tags
        Reference</guimenu> tab. If you'd like to see the reference in the NEF
        Sampler application, go to <ulink
        url="http://www.netspective.com/nefs-sampler/console/reference/tags">http://www.netspective.com/nefs-sampler/console/reference/tags</ulink>.
        The <guimenu>XDM Tags Reference</guimenu> pages provide three
        different views:</para>

        <variablelist>
          <varlistentry>
            <term>Tags Tree</term>

            <listitem>
              <para>The Tags Tree is a convenient way of looking at all the
              tags on one screen. There is a dynamic tree that allows you to
              get a sense of all the tags' hierarchy and when you click on any
              tag it will show the documentation for a particular tag in a
              window next to the tree.</para>

              <screenshot>
                <graphic fileref="./resources/images/screen-console-xdm-tags-ref-tree.gif" />
              </screenshot>

              <note>
                <para>The tags that are <emphasis>italicized</emphasis> in the
                Tags Tree are template producers (meaning they don't actually
                perform any actions they mere record information for later
                use). See <xref linkend="xdm-templates" /> for more
                information on templates.</para>
              </note>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Tags Documentation</term>

            <listitem>
              <para>The Tags Documentation pages provide detailed listings of
              all support attributes and elements for any tag you choose. This
              tag documentation page is the same page that appears within the
              Tags Tree except there is more room to view the documentation
              because the Tags Tree is not shown.</para>

              <screenshot>
                <graphic fileref="./resources/images/screen-console-xdm-tags-ref-doc.gif" />
              </screenshot>

              <para>The tag documentation pages include a great deal of
              information, including but not limited to:</para>

              <orderedlist>
                <listitem>
                  <para>A tag's ancestors (hierarchy in the tag tree).</para>
                </listitem>

                <listitem>
                  <para>The tag's name.</para>
                </listitem>

                <listitem>
                  <para>The class which handles the tag. Every tag is handled
                  by a plain old Java object (POJO).</para>
                </listitem>

                <listitem>
                  <para>The tag's attributes (all attributes are simply
                  mutator/setter methods like setXXX).</para>
                </listitem>

                <listitem>
                  <para>The attribute type (which class or Java primitive is
                  used to hold a value) and choices associated with the
                  attribute type (if any).</para>
                </listitem>

                <listitem>
                  <para>The tag's child elements (these are simply methods of
                  the form createXXX() and addXXX()).</para>
                </listitem>

                <listitem>
                  <para>The class which handles the child method. If there is
                  a check mark in the "Text" column it means that the class
                  allows PCDATA in the XML.</para>
                </listitem>

                <listitem>
                  <para>If the tag is a template producer or template
                  consumer, the names of the available templates it has either
                  produced or consumed is displayed here.</para>
                </listitem>

                <listitem>
                  <para>Shows the declaring class. If a checkmark is present
                  in the "D" column, then the attribute or child element is
                  declared in the class being shown. If a check mark is not
                  present it means the attribute/element is inherited and you
                  can hover in the empty box and the Console will show you
                  which class the attribute or child element is declared
                  in.</para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Template Catalog</term>

            <listitem>
              <para>The template catalog shows all the templates defined by
              template producers.</para>

              <screenshot>
                <graphic fileref="./resources/images/screen-console-xdm-tags-ref-tmpl-catalog.gif" />
              </screenshot>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section>
        <title>XDM Tag Handlers and Extensibility</title>

        <para>One of the principal goals of the XML Data Model is to allow
        complete extensibility through normal Java inheritance and delegation.
        Every XDM tag, with no exceptions, will be handled either by a
        built-in or custom Java class or method. For example, the <sgmltag
        class="starttag">project</sgmltag> tag is handled by the
        <classname>com.netspective.sparx.Project</classname> class. If you
        wanted to subclass the <classname>Project</classname> class and have
        the <sgmltag class="starttag">project</sgmltag> tag instead use your
        class as the tag handler all you would do is the following:</para>

        <programlisting role="xml">&lt;project <emphasis role="bold">class="my.own.ProjectHandler"</emphasis>&gt;
  ...</programlisting>

        <para>The example above shows how can, for any tag, simply subclass a
        built-in class and replace an existing tag with a new handler. What
        this allows you to do is to use the power of Java's OOP-based
        inheritance and extend it to XML tags. Although you would rarely
        replace the project tag with your own handler, it's very common to
        replace things like navigation pages, dialogs, execution handlers,
        validators, etc.</para>

        <para>To replace a navigation page with your own (presumably to do
        something that's no already built-in) you would simply create a class
        that extends the
        <classname>com.netspective.sparx.navigate.NavigationPage</classname>
        class and then add a <sgmltag class="attribute">class</sgmltag>
        attribute to the <sgmltag class="starttag">page</sgmltag> tag. As long
        as the class is located using the default Java class loading
        mechanism, all the attributes, children, etc of the <sgmltag
        class="starttag">page</sgmltag> tag will now be handled by your custom
        class instead of the default class.</para>

        <programlisting role="xml">&lt;project&gt;
   &lt;navigation-tree name="myTree" default="yes"&gt;
     &lt;page name="page1" <emphasis role="bold">class="your.own.PageClass"</emphasis> ...&gt;
     ...</programlisting>

        <para>To replace a dialog with your own you would simply create a
        class that extends the
        <classname>com.netspective.sparx.form.Dialog</classname> class and
        then add a <sgmltag class="attribute">class</sgmltag> attribute to the
        <sgmltag class="starttag">dialog</sgmltag> tag. As long as the class
        is located using the default Java class loading mechanism, all the
        attributes, children, etc of the <sgmltag
        class="starttag">dialog</sgmltag> tag will now be handled by your
        custom class instead of the default class.</para>

        <programlisting role="xml">&lt;project&gt;
   &lt;dialogs package="myDialogs"&gt;
     &lt;dialog name="dialog1" <emphasis role="bold">class="your.own.DialogClass"</emphasis> ...&gt;
     ...</programlisting>

        <note>
          <para>Every XDM tag is handled by a particular (usually unique) Java
          class. Because every tag is handled by a Java class, every tag
          allows the <sgmltag class="attribute">class</sgmltag> attribute to
          override which class will handle that particular tag. So, if you see
          any tag in any framework (Commons, Axiom, Sparx) that you want to
          enhance, extend, or replace you may do so simply by supplying a
          <sgmltag class="attribute">class</sgmltag> attribute to the
          tag.</para>
        </note>
      </section>

      <section>
        <title>XDM Performance</title>

        <para>When engineers first learn about XML and the amount of
        flexibility it affords in both application and data management, they
        jump at the chance to include XML features within their projects.
        However, soon they learn that dealing with XML sometimes means
        sacrificing performance. With NEF, all XML data is cached and only
        read when it changes. Basically, all NEF XML files are read using
        lazy-read approach; meaning, they are read only when needed and even
        then only once. So, the majority of all NEF XML performance impacts
        (if any) occur at the startup of a server-based application. Once the
        application starts all data is cached and shared across users and
        XML-related performance issues are eliminated. Also, NEF relies on the
        SAX programming interface for XML parsing and processing thus
        requiring far less memory and performance overhead than frameworks
        that rely on the DOM interface.</para>
      </section>

      <section>
        <title>XDM Tags versus JSP Tags</title>

        <para>JSP tag libraries are usually used for emitting HTML. They are
        commonly used in the view component of the MVC paradigm. NEF XML tags
        are used to describe and declare all aspects of your application (UI,
        database, security, etc). NEF can use existing JSP tag libraries but
        they are seldom needed because NEF's Sparx framework will handle most
        tasks within its own, much simpler, and much more powerful XML
        tags.</para>
      </section>

      <section>
        <title>How XDM Tags Become Java Class Instances and Mutator Method
        Calls</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title id="section-xdm-include">Including XML Files into Other XML
        Files</title>

        <para>The <sgmltag class="starttag">xdm:include</sgmltag> tag allows
        you to import to include the contents of other XML files into the
        Project File. The <sgmltag class="starttag">xdm:include</sgmltag> tag
        may also be called recursively. This means that the one file can
        include another file which can include another file and so on.</para>

        <example>
          <title>How to use the <sgmltag
          class="starttag">xdm:include</sgmltag> tag</title>

          <programlisting role="xml">&lt;project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;

    &lt;xdm:include file="/some/absolute/file.name"/&gt; <co
              id="xdm-include-file-abs" />
    &lt;xdm:include file="a/relative/file.name"/&gt; <co
              id="xdm-include-file-rel" />

    &lt;xdm:include resource="a/relative/file.name"/&gt; <co
              id="xdm-include-res-abs" />
    &lt;xdm:include resource="a/relative/file.name" relative-to="my.custom.ClassName"/&gt; <co
              id="xdm-include-res-rel" />

    &lt;xdm:include template="template-name"/&gt; <co
              id="xdm-include-template" /></programlisting>
        </example>

        <calloutlist>
          <callout arearefs="xdm-include-file-abs">
            <para>Include the contents of the given file using an absolute
            path.</para>
          </callout>

          <callout arearefs="xdm-include-file-rel">
            <para>Include the contents of the given file using a relative
            path. When relative paths are provided, the path is relative to
            the parent file.</para>
          </callout>

          <callout arearefs="xdm-include-res-abs">
            <para>Include the contents of the given file name but locate it
            using Java's resource loading mechanism. Since no <sgmltag
            class="attribute">relative-to</sgmltag> attribute is provided, the
            resource will be located relative to the
            <classname>com.netspective.sparx.Project</classname> class.</para>
          </callout>

          <callout arearefs="xdm-include-res-rel">
            <para>Include the contents of the given file name but locate it
            using Java's resource loading mechanism. Since the <sgmltag
            class="attribute">relative-to</sgmltag> attribute is provided, the
            resource will be located relative to the class called
            <classname>my.custom.ClassName</classname>.</para>
          </callout>

          <callout arearefs="xdm-include-template">
            <para>See <xref linkend="xdm-templates" />.</para>
          </callout>
        </calloutlist>

        <note>
          <para>The <sgmltag class="attribute">file</sgmltag>, <sgmltag
          class="attribute">resource</sgmltag>, and <sgmltag
          class="attribute">template</sgmltag> attributes are all mutually
          exclusive meaning if you include a file you may not, within the same
          tag, also include resources or templates. However, you can separate
          them into multiple <sgmltag class="starttag">xdm:include</sgmltag>
          tags.</para>
        </note>
      </section>

      <section>
        <title>Pre-processing XDM Files</title>

        <para>Because most XDM files contain descriptors for classes to be
        instantiated, there are times when an XML file should be pre-processed
        or somehow transformed before NEF processes the file. This allows XSLT
        and other transformations to occur on an XML file before NEF processes
        the files so that objects may be constructed on the fly or allow some
        other automation to occur.</para>

        <example>
          <title>How to Pre-process an XDM file</title>

          <programlisting role="xml">&lt;?xml version="1.0"?&gt;
&lt;?transform --xslt /an/absolute/file.xsl?&gt; <co
              id="xdm-pre-process-pi-file-abs" />
&lt;?transform --xslt a/relative/file.xsl?&gt; <co
              id="xdm-pre-process-pi-file-rel" />
&lt;?transform --resource --xslt com/netspective/commons/xdm/DataModelSchemaTestTransform.xsl?&gt; <co
              id="xdm-pre-process-pi-res-abs" />

&lt;project ...&gt;
    ....
&lt;/project&gt;</programlisting>

          <calloutlist>
            <callout arearefs="xdm-pre-process-pi-file-abs">
              <para>The XDM pre-processing occurs with a processing
              instruction called <sgmltag class="pi">transform</sgmltag>. The
              main parameter, called <literal>--xslt</literal>, provides the
              name of the XSLT file to send the XML file through before
              processing as XDM. In this example it's an absolute file.</para>
            </callout>

            <callout arearefs="xdm-pre-process-pi-file-rel">
              <para>You can specify relative files for the pre-processor as
              well. If the file is not absolute then it is relative to the
              parent file (the file containing the <sgmltag
              class="pi">transform</sgmltag> instruction.</para>
            </callout>

            <callout arearefs="xdm-pre-process-pi-res-abs">
              <para>Specify <literal>the --resource</literal> parameter If the
              XSLT file should be located using Java's resource loading
              mechanism then the --resource flag may be specified.</para>
            </callout>
          </calloutlist>
        </example>
      </section>

      <section>
        <title id="xdm-templates">XDM Templates</title>

        <para>XDM Templates are very powerful but easy to use alternatives to
        pre-processing using XSLT. They basically allow defining custom tags
        that are not actually instantiated into objects; instead they are
        stored as a template to be reused by other objects. An example should
        clarify how to create (produce) and use (consume) templates:</para>

        <example>
          <title>How to Use Global XDM Templates</title>

          <programlisting role="xml">&lt;xdm:template name="test-template-1"&gt; <co
              id="xdm-template-define" /> <co id="xdm-template-name" />
    &lt;xdm:template-param name="param1" default="4234"/&gt; <co
              id="xdm-template-param-optional" />
    &lt;xdm:template-param name="param2" required="yes"/&gt; <co
              id="xdm-template-param-required" />

    &lt;nested1 text="TestNested1Template" integer="100"&gt;
        PCDATA in TestNested1Template.
        &lt;nested11 text="<emphasis role="bold">${params.param1}</emphasis>" integer="<emphasis
              role="bold">${params.param2}</emphasis>"/&gt; <co
              id="xdm-template-param-use" />
        &lt;nested11 type="type-A" text="TestText12" integer="12"/&gt;
        &lt;nested11 class="com.netspective.commons.xdm.DataModelSchemaTest$CustomNested11Test"
                  text="CustomTestText12"
                  integer="122"/&gt;
    &lt;/nested1&gt;
&lt;/xdm:template&gt;

<emphasis role="bold">&lt;xdm:include template="test-template-1" xdm:param-param1="param1-value"/&gt; </emphasis><co
              id="xdm-template-consume-generic" /></programlisting>
        </example>

        <calloutlist>
          <callout arearefs="xdm-template-define">
            <para>A template is created (or <emphasis>produced</emphasis>)
            using the <sgmltag class="starttag">xdm:template</sgmltag> tag or
            with custom tags defined by <emphasis>template
            producers</emphasis> (see <xref
            linkend="xdm-template-producers" />). Every template is contained
            within a <emphasis>template namespace</emphasis>. If a template is
            <emphasis>produced</emphasis> (defined) using the <sgmltag
            class="starttag">xdm:template</sgmltag> tag, it is considered a
            <emphasis>global</emphasis> template (in the
            <emphasis>global</emphasis> namespace). A template may be defined
            and used within the same files or separated across files (meaning
            defined in one file and used later in another file).</para>
          </callout>

          <callout arearefs="xdm-template-name">
            <para>A template has a name.</para>
          </callout>

          <callout arearefs="xdm-template-param-optional">
            <para>A templates may contain optional parameters that can act as
            simple variable replacements. They are not as powerful as XSLT
            parameters but are much easier to define and use. Parameters must
            specify a <sgmltag>name</sgmltag> attribute and optionally specify
            a <sgmltag class="attribute">default</sgmltag> attribute. Template
            parameter names must be valid Java identifiers because they are
            treated as Java expressions.</para>
          </callout>

          <callout arearefs="xdm-template-param-required">
            <para>A template may contain parameters which are <sgmltag
            class="attribute">required</sgmltag>.</para>
          </callout>

          <callout arearefs="xdm-template-param-use">
            <para>Template parameters are used by enclosing them like this:
            <literal>${params.<replaceable>paramName</replaceable>}</literal>.
            Variable replacements only occur within attribute values and
            PCDATA. The text within <literal>${</literal> and
            <literal>}</literal> may be an expression. So,
            <literal>${params.param1 + ' ' + params.param2}</literal> would be
            valid.</para>
          </callout>

          <callout arearefs="xdm-template-consume-generic">
            <para>A template is <emphasis>consumed</emphasis> or used by
            supplying the <sgmltag class="starttag">xdm:include</sgmltag> tag
            with an appropriate <sgmltag
            class="attribute">template</sgmltag>=<sgmltag
            class="attvalue">template-name</sgmltag> attribute or with custom
            tags defined by <emphasis>template consumers </emphasis>(see <xref
            linkend="xdm-template-producers" />). The actual action taken by
            the XDM processor when it encounters a template consumption
            request is to simply take the contents of the template producer,
            perform parameter replacements, and then replace the <sgmltag
            class="starttag">xdm:include</sgmltag> tag with the contents of
            the template producer so that the NEF never even encounters the
            <sgmltag class="starttag">xdm:include</sgmltag> tag.</para>
          </callout>
        </calloutlist>

        <section>
          <title id="xdm-template-producers">Template Producer and Consumer
          Tags</title>

          <para>Although the combination of the <sgmltag
          class="starttag">xdm:template</sgmltag> tag and the <sgmltag
          class="starttag">xdm:include</sgmltag> tag with an appropriate
          <sgmltag class="attribute">template</sgmltag>=<sgmltag
          class="attvalue">template-name</sgmltag> attribute for
          <emphasis>producing</emphasis> and <emphasis>consuming</emphasis>
          templates works quite well, it's not very elegant. If you use many
          templates in your XDM source files there may be a great deal of line
          noise and it may lead to unreadable code. For this reason, XDM
          provides two special purpose and customizable tags called
          <emphasis>Template Producers</emphasis> and <emphasis>Template
          Consumers</emphasis>.</para>

          <variablelist>
            <varlistentry>
              <term>Template Producers</term>

              <listitem>
                <para>Template Producers are custom tags that define (or
                <emphasis>produce</emphasis>) templates by providing a
                easier-to-read and understand tag instead of using the
                <sgmltag class="starttag">xdm:include</sgmltag> tag. Template
                Producers have the exact same features and provide the same
                functionality as if defined with the <sgmltag
                class="starttag">xdm:include</sgmltag> tag but custom Template
                Producers each have their own <emphasis>namespace</emphasis>.
                In the NEF the <sgmltag class="starttag">page-type</sgmltag>,
                <sgmltag class="starttag">panel-type</sgmltag>, <sgmltag
                class="starttag">field-type</sgmltag>, <sgmltag
                class="starttag">dialog-type</sgmltag>, <sgmltag
                class="starttag">data-type</sgmltag>, and <sgmltag
                class="starttag">table-type</sgmltag> tags are all examples of
                Template Producer custom tags. They provide no functionality
                other than defining some type-specific template and not useful
                until they are <emphasis>consumed</emphasis> by a Template
                Consumer.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Template Consumers</term>

              <listitem>
                <para>Template Consumers are custom tags that
                <emphasis>consume</emphasis> (or use) templates by providing
                an easier-to-read and understand tag instead of using the
                <sgmltag class="starttag">xdm:include</sgmltag> tag with an
                appropriate <sgmltag
                class="attribute">template</sgmltag>=<sgmltag
                class="attvalue">template-name</sgmltag> attribute. Template
                Consumers have the same features and functionality as the
                <sgmltag class="starttag">xdm:include</sgmltag> tag including
                the ability to pass in parameters but Template Consumers point
                to specific Template Producer
                <emphasis>namespaces</emphasis>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>
    </section>

    <section>
      <title id="section-value-sources">Value Sources</title>

      <para>Value sources are implementations of the
      <classname>com.netspective.commons.value.ValueSource</classname>
      interface that allows dynamic data to be included in XML without
      creating a programming language inside XML. There are many locations in
      the Project where value sources are used: configuration variables,
      forms/dialogs, form fields, form conditionals, SQL statements, and SQL
      bind parameters. Value sources allow common business logic and
      <emphasis>business values</emphasis> to be stored in shareable instance
      and then used either in XML or Java files where necessary. Value sources
      can be either single or multiple (list context) and are used anywhere
      dynamic data is required. The format of a value source is similar to a
      URL (<literal>name:params</literal>).</para>

      <figure>
        <title>Value Sources Overview</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="./resources/images/project-value-sources-overview.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Using Value Sources</title>

        <para>The best way to learn about Value Sources is to consider some
        examples. Although value sources are used throughout the NEF, some of
        the most common usage patterns will occur in the Sparx presentation
        layer (like Navigation pages and Dialogs) so the following examples
        focus on that layer.</para>

        <programlisting role="xml">&lt;dialog heading="<replaceable>session:myHeading</replaceable>"&gt; <co
            id="value-source-eg-1" />
    &lt;field type="text" name="text-field" caption="staticCaption" default="<replaceable>request:varname</replaceable>"/&gt; <co
            id="value-source-eg-2" />
    &lt;field type="integer" name="int-field" caption="<replaceable>request:myCaption</replaceable>" default="<replaceable>my-rule:some-value</replaceable>"/&gt; <co
            id="value-source-eg-3" />
    &lt;field type="select" name="files" caption="Files" choices="<replaceable>filesystem-entries:/home/all</replaceable>"/&gt; <co
            id="value-source-eg-4" />
&lt;/dialog&gt;

&lt;navigation-tree name="abc"&gt;
    &lt;page name="def" caption="something" heading="<replaceable>session:someVar</replaceable>"/&gt; <co
            id="value-source-eg-5" /></programlisting>

        <calloutlist>
          <callout arearefs="value-source-eg-1">
            <para>A dialog specification is defined to have a heading which
            will be dynamically generated at run-time from the value of the
            'myHeading' session attribute.</para>
          </callout>

          <callout arearefs="value-source-eg-2">
            <para>The text field will have a static caption, but its default
            value will come from a request parameter called 'varname'.</para>
          </callout>

          <callout arearefs="value-source-eg-3">
            <para>In the integer field example, the caption and default will
            both be dynamic and the default value will actually come from a
            class that has been registered as 'my-rule'.</para>
          </callout>

          <callout arearefs="value-source-eg-4">
            <para>In the select field example, this select field fills its
            choices with the files contained in the directory
            /home/all.</para>
          </callout>

          <callout arearefs="value-source-eg-5">
            <para>In the navigation-tree page example, the caption is static
            but the heading attribute will be dynamically retrieved from a
            session variable called someVar.</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title>Catalog and Documentation of Value Sources</title>

        <para>The NEF ships with many built-in value sources and you can
        create as many value sources as you need on your own. To view a list
        of all of the value sources available to your project (including all
        built-in value sources and your own custom value sources) just go to
        Console's <menuchoice>
            <guimenu>Project</guimenu>

            <guimenuitem>Value Sources</guimenuitem>
          </menuchoice> page.<screenshot>
            <graphic fileref="./resources/images/screen-console-value-sources-catalog.gif" />
          </screenshot></para>
      </section>

      <section>
        <title id="value-contexts">Value Contexts</title>

        <para>Since values are specified as static text (like within an XML
        file) but their content is actually dynamic, a <emphasis>Value
        Context</emphasis> is necessary to determine what the value of any
        value source will be at the time when it's called. For example, a
        static value source (described below) whose value never changes
        doesn't really care what context it's in: it's very will remain the
        same at all time. However, if you have a value source that is
        specified as "request:XXX" (the value of a request parameter called
        XXX) then it's important to have the value context know the Servlet
        request object at the time. Put another way, the Value Context is sort
        of an <emphasis>Environment</emphasis> within which a value is
        evaluated and returned.</para>

        <section>
          <title>Value Contexts you will most commonly use</title>

          <variablelist>
            <varlistentry>
              <term>ValueContext interface</term>

              <listitem>
                <para>The
                <classname>com.netspective.commons.value.ValueContext</classname>
                interface is used to define the common methods required in all
                value contexts.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>TabularReportValueContext class</term>

              <listitem>
                <para>The
                <classname>com.netspective.commons.report.tabular.TabularReportValueContext</classname>
                class</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>DialogContext class</term>

              <listitem>
                <para>The
                <classname>com.netspective.sparx.form.DialogContext</classname>
                class</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>NavigationContext class</term>

              <listitem>
                <para>The
                <classname>com.netspective.navigate.NavigationContext</classname>
                class</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>

      <section>
        <title>Static Values</title>

        <para>The simplest value source is known as the static value source –
        which is simply a wrapper for the Java String object. So, if an
        attribute accepts a value source, you can always supply a static
        string and it will be wrapped inside a
        <classname>com.netspective.commons.value.source.StaticValueSource</classname>
        class. For example, the following examples all produce the same
        results:</para>

        <programlisting role="xml">&lt;field type="text" caption="ABC"/&gt;
&lt;field type="text" caption="static:ABC"/&gt;
&lt;field type="text" caption="string:ABC"/&gt;
&lt;field type="text" caption=”<classname>com.netspective.commons.value.source.StaticValueSource</classname>:ABC"/&gt;</programlisting>
      </section>

      <section>
        <title>Parsing name:params Value Source Specifications</title>

        <para>The
        <classname>com.netspective.commons.value.ValueSources</classname>
        factory class is responsible for parsing value source specifications.
        The "name" portion of the value source refers to either a value source
        identifier (like "session" or "request") or the full name of a class
        that exists in your classpath. You can escape a value source by using
        the <literal>\</literal> character in front of the
        <literal>:</literal> token. For example, if you’d like to create a
        string called "<literal>name:params</literal>" and not have it treated
        as a value source, use <literal>"name\:params</literal>". Given a
        string of the format <literal>name:params</literal>, Sparx performs
        the following steps during the parse:</para>

        <procedure>
          <step>
            <para>Using the "<literal>name</literal>" portion of the
            declaration, check the
            <classname>com.netspective.commons.value.ValueSources</classname>
            factory class in the to see if it’s a built-in value source or has
            been registered separately by an application (it doesn’t matter if
            it’s a built-in source or one that you create and register
            yourself -- every value source is treated the same way).</para>
          </step>

          <step>
            <para>If the value source identifier ("<literal>name</literal>")
            is found in the
            <classname>com.netspective.commons.value.ValueSources</classname>
            factory, get the associated class name (which must be a class that
            implements the
            <classname>com.netspective.commons.value.ValueSource</classname>
            interface). We will refer to this as the <emphasis>Value Source
            Class</emphasis>.</para>
          </step>

          <step>
            <para>If the value source identifier is not found in
            <classname>com.netspective.commons.value.ValueSources</classname>
            factory check to see if "<literal>name</literal>" is a class name
            by using the <function>Class.forName("name")</function> method.
            Assuming a class is found, we will refer to this as the
            <emphasis>Value Source Class</emphasis>.</para>
          </step>

          <step>
            <para>Using the <emphasis>Value Source Class</emphasis> found from
            either step 2 or step 3, check to see if there is already an
            instance created for the class. If there is an existing instance,
            use that instance (so that value sources may be shared). If there
            is no existing instance, instantiate a new object by constructing
            the <emphasis>Value Source Class</emphasis>, calling its
            <function>initializeSource()</function> method and passing in the
            "<literal>params</literal>" portion of the value source
            declaration and cache the object for future use.</para>
          </step>
        </procedure>
      </section>

      <section>
        <title>Registering a Value Source</title>

        <para>The following example shows how you can use the <sgmltag
        class="element">value-source</sgmltag> tag create your own value
        sources and register them so that the NEF will be able to use them.
        Assuming that you have created a class called
        <literal>MyValueSource</literal> that implements the
        <classname>com.netspective.commons.value.ValueSource</classname>
        interface and have placed your class in the package
        <literal>my.value.source</literal> you can use the following
        declaration in your
        <filename>APP_ROOT/WEB-INF/sparx/project.xml</filename> file.</para>

        <programlisting role="xml">&lt;project&gt;
    &lt;value-source class="<replaceable>my.value.source.MyValueSource</replaceable>"/&gt;</programlisting>
      </section>
    </section>

    <section>
      <title id="section-commands">Commands</title>

      <para>Commands are Java classes that implement the
      <classname>com.netspective.commons.command.Command</classname> interface
      and execute arbitrary tasks defined either by you or the framework. They
      are used to encapsulate common logic and reuse that logic across pages
      and dialogs/forms.</para>
    </section>

    <section>
      <title id="section-ant-build-scripts">Ant Build Scripts</title>

      <para>NEF provides a series of scripts that, among other functions,
      allow you to compile your application, generate code, and upgrade NEF
      libraries and components. All of the scripts are built to be executed in
      the industry-standard <ulink url="http://ant.apache.org">Apache
      Ant</ulink> tool. Apache Ant is included in the NEF distribution.</para>

      <section>
        <title>Executing Ant Scripts through Console</title>

        <para>To execute an Ant script through the Console, login to the
        Console and go to Project -&gt; Ant Build tab. A list of Ant script
        targets are available for execution. You can easily run a script by
        selecting it from the list. Complete description of each Ant target is
        also provided there for your reference.</para>

        <para><screenshot>
            <graphic fileref="./resources/images/nefs-console-ant-build-scripts.gif" />
          </screenshot></para>
      </section>

      <section>
        <title>Executing Ant Scripts From the Command Line</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Executing Ant Scripts from within your IDE</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Automatically Executing Ant Scripts in Navigation
        Controller</title>

        <para>TODO: documentation coming soon...</para>
      </section>
    </section>

    <section>
      <title>Runtime Environments</title>

      <para>NEF supports the notion of <emphasis>runtime
      environments</emphasis> like <literal>Development</literal>,
      <literal>Testing</literal>, and <literal>Production</literal>. When in
      the <literal>Development</literal> environment, XML-based resource files
      like dialogs, schemas, SQL, and others are automatically reloaded. In
      <literal>Testing</literal> and <literal>Production</literal>
      environments automatic reloading is not enabled. Your applications can
      use the environment setting to make appropriate decisions about data
      sources and other environment-specific settings (like throwing
      exceptions in a development environment but e-mailing errors in testing
      or production). The following environment flags are available (they can
      be mixed but some mixtures won't make sense):</para>

      <variablelist>
        <varlistentry>
          <term>DEVELOPMENT</term>

          <listitem>
            <para>This is the default environment in which all components like
            dialogs, queries, and such are reloaded when their sources change.
            This is the only runtime environment in which files are
            reloaded.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>TESTING</term>

          <listitem>
            <para>Specifies a test environment.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>TRAINING</term>

          <listitem>
            <para>Specifies a training environment.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>PRODUCTION</term>

          <listitem>
            <para>Specifies a production environment.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>DEMONSTRATION</term>

          <listitem>
            <para>Specifies a demonstration environment.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>UNDERGOING_MAINTENANCE</term>

          <listitem>
            <para>Specifies that whichever environment is currently the active
            one is undergoing maintenance. This is useful so that controller
            servlets don't allow use of application resources while the app is
            undergoing maintenance.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <section>
        <title>Viewing the Active Runtime Environment</title>

        <para>The active runtime environment may be viewed by going to the
        Console Home Page for the application in question. The current runtime
        environment is available within your Java applications by using the
        <function>ValueContext.getRuntimeEnvironmentFlags()</function> method
        from any value context instance like NavigationContext or
        DialogContext (see <xref linkend="value-contexts" xreflabel="" /> for
        more information).<screenshot>
            <graphic fileref="./resources/images/screen-console-home-runtime-env-highlight.gif" />
          </screenshot></para>
      </section>

      <section>
        <title>Changing the Runtime Environment</title>

        <para>If you'd like to modify the runtime environment flags, do the
        following:</para>

        <procedure>
          <step>
            <para>Open your application's web.xml file
            (<filename>WEB-INF/web.xml</filename>).</para>
          </step>

          <step>
            <para>Add or modify the
            <literal>com.netspective.sparx.navigate.CONTROLLER_SERVLET_OPTIONS</literal>
            servlet init parameter for your application's navigation
            controller. The parameter may be set to a single value or may
            contain multiple flags separated using the '|' character.</para>

            <example>
              <title>Changing Application Runtime Environment Flags to
              Production</title>

              <programlisting role="xml">&lt;web-app&gt;
      ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;SparxNavigationController&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.netspective.sparx.navigate.NavigationControllerServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;com.netspective.sparx.navigate.CONTROLLER_SERVLET_OPTIONS&lt;/param-name&gt;
            &lt;param-value&gt;<emphasis role="bold">--runtime-environment=PRODUCTION</emphasis>&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
      ...
&lt;/web-app&gt;</programlisting>
            </example>

            <example>
              <title>Changing Application Runtime Environment Flags to
              Production Maintenance</title>

              <programlisting role="xml">&lt;web-app&gt;
      ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;SparxNavigationController&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.netspective.sparx.navigate.NavigationControllerServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;com.netspective.sparx.navigate.CONTROLLER_SERVLET_OPTIONS&lt;/param-name&gt;
            &lt;param-value&gt;<emphasis role="bold">--runtime-environment="PRODUCTION | UNDERGOING_MAINTENANCE"</emphasis>&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
      ...
&lt;/web-app&gt;</programlisting>
            </example>

            <note>
              <para>To learn more about the other controller servlet options
              allowed by Sparx, visit Console's <menuchoice>
                  <guimenu>Project</guimenu>

                  <guimenuitem>Configuration</guimenuitem>
                </menuchoice> page.</para>
            </note>
          </step>
        </procedure>
      </section>
    </section>

    <section>
      <title>Sharing of NEF Objects Across Threads</title>

      <para>The NEF is designed for complex multi-user and multi-threaded
      applications and is thread-safe. In order to help ensure that a large
      number of users of a large application don't end up using too many
      system resources many objects and instances are shared across users and
      threads. In fact, almost any object that does not end in "Context" is
      generally shared. For example, navigation trees, navigation pages, forms
      (dialogs), queries, schemas, etc. are all shared across users. To help
      protect users from modifying each other's data, specific state classes
      are used to manage per-user interactions with the frameworks. Here are
      some examples:</para>

      <variablelist>
        <varlistentry>
          <term>Navigation</term>

          <listitem>
            <para>All navigation trees and navigation pages (<sgmltag
            class="starttag">navigation-tree</sgmltag>, <sgmltag
            class="starttag">page</sgmltag>, <sgmltag
            class="starttag">body</sgmltag> etc.) are shared. The
            <classname>com.netspective.navigate.NavigationContext</classname>
            class manages the per-user interaction. For every request/response
            cycle of the web application process, users will use the same
            instances of the structural elements (trees, pages, bodies, etc)
            but will have their own state object (the
            <classname>NavigationContext</classname>) which manages a
            particular the individual user's navigation state (like what page
            they are on). If there are any value sources defined for page
            captions, headings or other values then the
            <classname>NavigationContext</classname> is the Value Context that
            is used for resolving the value source expressions. This way,
            value source <emphasis>values</emphasis> may be dynamic per-user
            yet they can share the definition in the XML files.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Forms and Dialogs</term>

          <listitem>
            <para>All forms (dialogs), form fields, validation rules and
            criteria (<sgmltag class="starttag">dialog</sgmltag>, <sgmltag
            class="starttag">field</sgmltag>, <sgmltag
            class="starttag">validation</sgmltag> etc.) are shared. The
            com.netspective.sparx.form.DialogContext class manages the
            per-user interaction. For every request/response cycle of the web
            application process, users will use the same instances of the
            structural elements (dialogs, fields, etc) but will have their own
            state object (the <classname>DialogContext</classname>) which
            manages a particular the individual user's form state (like what
            values were typed in, if there are any validation errors, etc). If
            there are any value sources defined for dialog headings, field
            captions, message text, or other values then the
            <classname>DialogContext</classname> is the Value Context that is
            used for resolving the value source expressions. This way, value
            source <emphasis>values</emphasis> may be dynamic per-user yet
            they can share the definition in the XML files.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </chapter>

  <chapter>
    <title>Project Presentation Layer Declarations</title>

    <para>The NEF's Sparx Application Platform is responsible for managing the
    presentation layer of your application. The complete thin-client user
    experience including navigation, forms management, visual validation, and
    themes/skins are handled by Sparx.</para>

    <section>
      <title>Navigation</title>

      <para>In Sparx, <emphasis>Navigation</emphasis> refers to the handling
      of pages that an end user will see and the transforming the control from
      one page to another using URIs and URLs. Once declared using XML, Sparx
      can automatically manage the visual and operational end-user control of
      the navigation from one area of your application to another. You simply
      define the rules for what happens when a user visits a page and Sparx
      takes care of the rest.</para>

      <section>
        <title>MVC</title>

        <para>Most enterprise applications need to support multiple types of
        users with varying content in pages/applications and with multiple
        types interfaces. To help support complex applications, Sparx
        implements the core components of Model-View-Controller (MVC<footnote>
            <para>The Model-View-Controller design pattern has been covered
            extensively in periodicals, books, and online articles. Please
            visit one of the following sites if you would like further
            information on the pattern.</para>

            <itemizedlist>
              <listitem>
                <para><ulink
                url="http://java.sun.com/blueprints/patterns/MVC-detailed.html">Java
                BluePrints: Model-View-Controller (Sun)</ulink></para>
              </listitem>

              <listitem>
                <para><ulink
                url="http://st-www.cs.uiuc.edu/users/smarch/st-docs/mvc.html">How
                to use Model-View-Controller (Steve Burbeck)</ulink></para>
              </listitem>
            </itemizedlist>
          </footnote>) and Model-View-Presenter (MVP<footnote>
            <para>The Model_View-Presenter is a more modern design pattern
            which probably more closely follows MVC for web-based
            applications. Please visit one of the following sites if you like
            further information on the pattern.</para>

            <itemizedlist>
              <listitem>
                <para><ulink
                url="http://www.object-arts.com/EducationCentre/Patterns/MVP.htm">Pattern:
                Model-View-Presenter</ulink></para>
              </listitem>

              <listitem>
                <para><ulink
                url="http://www.object-arts.com/EducationCentre/Overviews/ModelViewPresenter.htm">Model-View-Presenter
                Framework</ulink></para>
              </listitem>
            </itemizedlist>
          </footnote>) design patterns for isolating the display of
        information (the view) from its control (the manner in which the user
        got to the view) and its model (the business logic associated with the
        view). Sparx provides the capability to fully separate the Model,
        View, and Controller for sophisticated applications yet it also
        supports the ability to loosely integrate them for smaller or more
        modest applications where speed of delivery is paramount.</para>

        <figure>
          <title>MVC Pattern Overview</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="./resources/images/sparx-mvc-pattern.gif" />
            </imageobject>
          </mediaobject>
        </figure>

        <section>
          <title>Sparx Controller</title>

          <para>In the MVC paradigm for web-based applications, there is
          always a Controller that manages the redirection of pages from one
          URL to another which ultimately provides the capabilities for the
          user to manipulate the application. When a menu item is chosen, it
          is the Controller's job to parse the URL and find the proper page
          object that will handle the work. In Sparx, the class that handles
          that work is called
          <classname>com.netspective.sparx.navigate.NavigationControllerServlet</classname>.
          This servlet is the starting point for all Sparx user interface and
          application actions.</para>
        </section>

        <section>
          <title>Sparx Views</title>

          <para>The Views in the MVC pattern are the user interface which
          displays information about the model to the user. In Sparx, the base
          class that manages all user interface pages is called
          <classname>com.netspective.sparx.navigate.NavigationPage</classname>.
          All page rendering is managed by this NavigationPage class but the
          actual rendering actions are delegated. Any given page may either
          handle the rendering itself, may call a JSP page, a FreeMarker
          template, or any other custom body handler.</para>
        </section>

        <section>
          <title>Your Model</title>

          <para>The Model in the MVC pattern is determined by your
          application.</para>
        </section>
      </section>

      <section>
        <title>Navigation Tag Descriptions</title>

        <para>The following tags are used in the
        <filename>APP_ROOT/WEB-INF/sparx/project.xml</filename> file to
        declare navigation rules and actions.</para>

        <variablelist>
          <varlistentry>
            <term><sgmltag class="starttag">navigation-tree</sgmltag></term>

            <listitem>
              <para>The <sgmltag class="starttag">navigation-tree</sgmltag>
              tag starts out the definition and appears as a child of the
              <sgmltag class="starttag">project</sgmltag> tag. The <sgmltag
              class="attribute">name</sgmltag> attribute is required and must
              be unique across all navigation trees. The <sgmltag
              class="attribute">default</sgmltag> attribute may be set to
              <sgmltag class="attvalue">yes</sgmltag> to make it the default
              tree. Each <sgmltag class="starttag">navigation-tree</sgmltag>
              tag ends up as an instance of the
              <classname>com.netspective.sparx.navigate.NavigationTree</classname>
              class. There is only one instance of each navigation tree that
              you define and the definition is shared across all users and
              threads.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><sgmltag class="starttag">page</sgmltag></term>

            <listitem>
              <para>The <sgmltag class="starttag">page</sgmltag> tag begins a
              definition of a single page and appears under the <sgmltag
              class="starttag">navigation-tree</sgmltag> tag. The <sgmltag
              class="attribute">name</sgmltag> attribute is required and must
              be unique within the navigation tree in which it is defined.
              Each <sgmltag class="starttag">page</sgmltag> tag ends up as an
              instance of the
              <classname>com.netspective.sparx.navigate.NavigationPage</classname>
              class. There is only one instance of each page that you define
              and the definition is shared across all users and
              threads.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><sgmltag class="starttag">body</sgmltag></term>

            <listitem>
              <para>The <sgmltag class="starttag">body</sgmltag> tag starts a
              definition of a page body and appears under the <sgmltag
              class="starttag">page</sgmltag> tag. Its contents are handled by
              the FreeMarker templating engine. Each <sgmltag
              class="starttag">body</sgmltag> tag ends up as an instance of
              the
              <classname>com.netspective.commons.template.TemplateProcessor</classname>
              interface. The default implementation is the
              <classname>com.netspective.sparx.template.freemarker.FreeMarkerTemplateProcessor</classname>
              class. So, unless you override the <sgmltag
              class="starttag">body</sgmltag> tag's <sgmltag
              class="attribute">class</sgmltag> attribute the body will be
              processed as a FreeMarker template.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><sgmltag class="starttag">panels</sgmltag></term>

            <listitem>
              <para>The <sgmltag class="starttag">panels</sgmltag> tag starts
              a definition of a page body and appears under the <sgmltag
              class="starttag">page</sgmltag> tag. Its contents are handled by
              Sparx by laying out pre-defined panels similar to the way
              portals lay out their content. The <sgmltag
              class="starttag">panels</sgmltag> tag ends up as an instance of
              the
              <classname>com.netspective.sparx.panel.HtmlLayoutPanel</classname>
              class.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <programlisting role="xml">&lt;project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;
...

&lt;<emphasis role="bold">navigation-tree</emphasis> name="app" default="yes"&gt;

    &lt;<emphasis role="bold">page</emphasis> name="home" default="yes" caption="Hello" heading="Hello World!"&gt;
        &lt;<emphasis role="bold">body</emphasis>&gt;
            &lt;![CDATA[
            This is the 'Hello World' app. Click &lt;a href="next-steps"&gt;here&lt;/a&gt; to see what's next.
            ]]&gt;
        &lt;/body&gt;
    &lt;/page&gt;

    &lt;page name="next-steps" caption="Next Steps" heading="What's next?"&gt;
        &lt;body <emphasis role="bold">source</emphasis>="next-steps.ftl"/&gt;
    &lt;/page&gt;

    &lt;page name="some-stuff" caption="Panels instead of Body"&gt;
        &lt;<emphasis role="bold">panels</emphasis>&gt;
             &lt;panel type="command" command="query,org.get-sponsor-info-by-id,-,-,-,detail-compressed"/&gt;
             &lt;panel type="command" command="query,org.get-org-addresses-by-id,-,-,-,report-compressed" /&gt;
        &lt;/panels&gt;
    &lt;/page&gt;</programlisting>
      </section>

      <section>
        <title>Navigation Trees</title>

        <para>You may declare as many navigation trees as your application
        needs. Consider different trees for different users (based on
        personalization) or a different tree for each access-control role (for
        security) or any other criteria required by your application.</para>

        <section>
          <title>Specifying the Active Navigation Tree</title>

          <para>If you have multiple navigation trees, which tree is actually
          used by the application may be specified as a servlet parameter or
          chosen dynamically at runtime based on some processing rules.</para>

          <section>
            <title>In the
            <filename>APP_ROOT/WEB-INF/sparx/project.xml</filename>
            file</title>

            <para>To specify a static navigation tree in the
            <filename>APP_ROOT/WEB-INF/sparx/project.xml</filename> file just
            set the <sgmltag class="starttag">navigation-tree</sgmltag>
            <sgmltag class="attribute">default</sgmltag> attribute to <sgmltag
            class="attvalue">yes</sgmltag>.<programlisting role="xml">&lt;navigation-tree name="myNavigationTree" <emphasis
                  role="bold">default="yes"</emphasis>/&gt;</programlisting></para>
          </section>

          <section>
            <title>In the <filename>APP_ROOT/WEB-INF/web.xml</filename> file
            as part of a Servlet descriptor</title>

            <para>Use the following example to specify a static navigation
            tree in the <filename>APP_ROOT/WEB-INF/web.xml</filename> file as
            part of the servlet configuration. This method allows you to
            define multiple servlets (sub applications) each with its own
            navigation tree.<programlisting role="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;<emphasis role="bold">SparxNavigationController</emphasis>&lt;/servlet-name&gt;
    &lt;servlet-class&gt;<emphasis role="bold">com.netspective.sparx.navigate.NavigationControllerServlet</emphasis>&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;<emphasis role="bold">com.netspective.sparx.navigate.CONTROLLER_SERVLET_OPTIONS</emphasis>&lt;/param-name&gt;
        &lt;param-value&gt;<emphasis role="bold">--navigation-tree=myNavigationTree</emphasis>&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;</programlisting></para>
          </section>
        </section>
      </section>

      <section>
        <title>Paths, Pages, and Page Identification</title>

        <para>Each <sgmltag class="starttag">page</sgmltag> tag corresponds to
        an HTML page and may contain other <sgmltag
        class="starttag">page</sgmltag> tags that will be considered children
        of the container page. By defining the pages in a hierarchical fashion
        it allows you to create a programmable site map of all pages in your
        application. You'll be able to review the entire application's
        hierarchy in one place and the application will be more secure because
        pages not defined in the map will not be accessible.</para>

        <section>
          <title>Page name (identifier) attribute and paths</title>

          <para>Each <sgmltag class="starttag">page</sgmltag> tag requires a
          <sgmltag class="attribute">name</sgmltag> attribute. The value of
          the <sgmltag class="attribute">name</sgmltag> attribute defines both
          it's unique name within it's parent and becomes part of the
          <emphasis>fully qualified path</emphasis> name of the page so it may
          be uniquely identified within the entire navigation tree. Assuming
          you have the following definition:<programlisting role="xml">&lt;navigation-tree name="myTree" default="yes"&gt;
    &lt;page name="A" caption="Page A"&gt;
        &lt;page name="X" caption="Page 1 of Page A"/&gt;
        &lt;page name="Y" caption="Page 2 of Page A"&gt;
            &lt;page name="T" caption="Page 2 of Page Y"/&gt;
        &lt;/page&gt;
    &lt;/page&gt;
    &lt;page name="B" caption="Page A"&gt;
        &lt;page name="F" caption="Page 1 of Page B"&gt;
            &lt;page name="J" caption="Page 1 of Page F"&gt;
                &lt;page name="Q" caption="Page 1 of Page J"/&gt;
                &lt;page name="R" caption="Page 2 of Page J"/&gt;
            &lt;/page&gt;
        &lt;/page&gt;
    &lt;/page&gt;</programlisting></para>

          <para>When Sparx processes the preceding XML, you will get a
          <classname>NavigationTree</classname> class instance identified as
          <sgmltag class="attvalue">myTree</sgmltag> and it will create pages
          in memory that will be uniquely identified using the following URLs
          -- note that each of the <sgmltag class="attribute">name</sgmltag>
          attributes is simply appended to the parent's <sgmltag
          class="attribute">name</sgmltag> attribute to construct the
          <emphasis>fully qualified path</emphasis>.</para>

          <itemizedlist>
            <listitem>
              <para>/A</para>

              <itemizedlist>
                <listitem>
                  <para>/A/X</para>
                </listitem>

                <listitem>
                  <para>/A/Y</para>

                  <itemizedlist>
                    <listitem>
                      <para>/A/Y/T</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>/B</para>

              <itemizedlist>
                <listitem>
                  <para>/B/F</para>

                  <itemizedlist>
                    <listitem>
                      <para>/B/F/J</para>

                      <itemizedlist>
                        <listitem>
                          <para>/B/F/J/Q</para>
                        </listitem>

                        <listitem>
                          <para>/B/F/J/R</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Page <sgmltag class="attribute">captions</sgmltag>, <sgmltag
          class="attribute">headings</sgmltag>, and <sgmltag
          class="attribute">title</sgmltag> attributes</title>

          <para>While the <sgmltag class="starttag">page</sgmltag> <sgmltag
          class="attribute">name</sgmltag> attribute identifies the page
          internally to Sparx and is used for accessing the page when a URL is
          defined, the <sgmltag class="attribute">caption</sgmltag>, <sgmltag
          class="attribute">heading</sgmltag>, and <sgmltag
          class="attribute">title</sgmltag> attributes are used to identify
          the page to the end user. Each page may have different values for
          the <sgmltag class="attribute">caption</sgmltag>, <sgmltag
          class="attribute">heading</sgmltag>, and <sgmltag
          class="attribute">title</sgmltag> attributes or they may share the
          same values if appropriate.</para>

          <mediaobjectco>
            <imageobjectco>
              <areaspec>
                <area coords="1" id="screen-sparx-page-caption-co" />

                <area coords="2" id="screen-sparx-page-heading-co" />

                <area coords="3" id="screen-sparx-page-title-co" />
              </areaspec>

              <imageobject>
                <imagedata fileref="./resources/images/screen-sparx-page-cap-head-title.gif" />
              </imageobject>

              <calloutlist>
                <callout arearefs="screen-sparx-page-caption-co">
                  <para>The <sgmltag class="attribute">caption</sgmltag>
                  attribute, which is a value source type and is always
                  required, may provide a static string or dynamic text that
                  will be shown as the page's identifier to end users when the
                  page needs to be shown in a menu (or a tab). Although the
                  actual rendering and what the caption will look like is
                  determined by the active theme and its specific navigation
                  skin, the <sgmltag class="attribute">caption</sgmltag>
                  attribute is always used to help navigate to a page and is
                  almost always rendered as a hyperlink.</para>
                </callout>

                <callout arearefs="screen-sparx-page-heading-co">
                  <para>The <sgmltag class="attribute">heading</sgmltag>
                  attribute, which is a value source type and is optional, may
                  provide a static string or dynamic text that will be shown
                  as page's heading. Although the actual rendering and what
                  the heading looks like is determined by the active and its
                  specific navigation skin, the <sgmltag
                  class="attribute">heading</sgmltag> attribute is always used
                  to indicate what the current page's content means to the end
                  user.</para>
                </callout>

                <callout arearefs="screen-sparx-page-title-co">
                  <para>The <sgmltag class="attribute">title</sgmltag>
                  attribute, which is a value source type and is optional, may
                  provide a static string or dynamic text that will be placed
                  into the browser window's title. This is the text that will
                  usually be used by the browser when it bookmarks a page as
                  well.</para>
                </callout>
              </calloutlist>
            </imageobjectco>
          </mediaobjectco>

          <note>
            <para>The <sgmltag class="attribute">caption</sgmltag> is always
            required. However, both the <sgmltag
            class="attribute">heading</sgmltag> and <sgmltag
            class="attribute">title</sgmltag> attributes are optional. If a
            <sgmltag class="attribute">heading</sgmltag> is not provided the
            value defaults to the <sgmltag
            class="attribute">caption</sgmltag>. If a <sgmltag
            class="attribute">title</sgmltag> is not provided it defaults to
            the <sgmltag class="attribute">heading</sgmltag>. This way, if
            only a <sgmltag class="attribute">caption</sgmltag> is provided
            then the <sgmltag class="attribute">caption</sgmltag> becomes the
            <sgmltag class="attribute">heading</sgmltag> and <sgmltag
            class="attribute">title</sgmltag>. If a <sgmltag
            class="attribute">caption</sgmltag> and <sgmltag
            class="attribute">heading</sgmltag> are both provided but no
            <sgmltag class="attribute">title</sgmltag> is provided then the
            <sgmltag class="attribute">heading</sgmltag> becomes the <sgmltag
            class="attribute">title</sgmltag>.</para>
          </note>

          <example>
            <title>Using the <sgmltag class="starttag">page</sgmltag> <sgmltag
            class="attribute">tag's caption</sgmltag>, <sgmltag
            class="attribute">heading</sgmltag>, and <sgmltag
            class="attribute">title</sgmltag> attributes</title>

            <programlisting role="xml">&lt;page name="X" caption="page X"/&gt;
&lt;page name="Y" caption="session:someVar" heading="heading for page Y" /&gt;
&lt;page name="Z" caption="PageZ" heading="heading for page Z" title="vs-expr:${authenticated-user:name}'s page"/&gt;</programlisting>
          </example>
        </section>
      </section>

      <section>
        <title>The Navigation Context</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Transferring Page Flow to non-Sparx Content</title>

        <para>Many times it's desirable to have certain pages in a navigation
        tree be sent to existing content either within your own application or
        external to the application. Sparx allows the page tag to define page
        transfers to other application resources (like other Servlets, JSPs,
        etc.) or external sites.</para>

        <section>
          <title>Redirect to an URL</title>

          <para>The <sgmltag class="starttag">page</sgmltag> <sgmltag
          class="attribute">redirect</sgmltag> attribute, which is a value
          source type, will simply tell the browser to go an alternate page
          when it is clicked in a menu. The alternate page is usually an
          external site but it could actually be any URL that you construct.
          You may specify a <sgmltag class="attribute">target</sgmltag> if you
          want to open another window. Because the <sgmltag
          class="attribute">redirect</sgmltag> attribute is a value source,
          the actual destination may be a static string or a dynamic text
          specification that will be computed at runtime.</para>

          <para>To redirect to an external static URL, use the following
          example. Note that we escape the ':' in 'http:' because the <sgmltag
          class="attribute">redirect</sgmltag> attribute is a value
          source.</para>

          <programlisting role="xml">&lt;page name="X" caption="Java Home" redirect="http\://java.sun.com"/&gt;</programlisting>

          <para>To redirect to a dynamic URL, use the following example. In
          this sample we'll redirect to whatever is in the request parameter
          called 'url'. Note that we'll open a second window for this
          redirect.</para>

          <programlisting role="xml">&lt;page name="X" caption="Dynamic Redirect" redirect="request:url" target="anotherWindow"/&gt;</programlisting>
        </section>

        <section>
          <title>Forward to a Servlet Context Resource</title>

          <para>The <sgmltag class="starttag">page</sgmltag> <sgmltag
          class="attribute">forward</sgmltag> attribute, which is a value
          source type, uses the Servlet Request's
          <classname>RequestDispatcher</classname>.<methodname>forward()</methodname>
          method to simply take the request as-sent and forward it to another
          resource within the application's context. The forwarded page has no
          Sparx navigation skin header/footer or anything else in the response
          buffer so the target resource (where the forward is going) will need
          to handle everything. This is useful for custom processing outside
          of Sparx.</para>

          <para>To forward to an internal, static, URL use the following
          example. The <sgmltag class="attribute">forward</sgmltag>
          attribute's value is relative to the application root.</para>

          <programlisting role="xml">&lt;page name="X" caption="Another JSP Page" forward="some/other/file.jsp"/&gt;</programlisting>

          <para>To forward to a resource based on a dynamic value, use a value
          source specification instead of a static string. In the next example
          we'll forward to whatever resource is specified in the request
          parameter called 'url'.</para>

          <programlisting role="xml">&lt;page name="X" caption="Dynamic forward" forward="request:url"/&gt;</programlisting>
        </section>
      </section>

      <section>
        <title>Page Content (Bodies)</title>

        <para>Since page content (the body) is where all of the action is,
        Sparx allows a wide variety of different content management
        techniques. From simple redirects to complex templates all the way
        through completely customized handled, there's nothing that the Sparx
        page bodies can't handle.</para>

        <section>
          <title>Include a Servlet Context Resource</title>

          <para>The <sgmltag class="starttag">page</sgmltag> <sgmltag
          class="attribute">include</sgmltag> attribute, which is a value
          source type, uses the Servlet Request's
          <classname>RequestDispatcher</classname>.<methodname>include()</methodname>
          method to include another resource within the application's context.
          The included page will be called after the Sparx navigation skin
          header (menus, page heading, meta-data, etc) has already been
          rendered and when control returns from the include the standard
          navigation skin footer will be rendered.</para>

          <para>To include an internal, static, URL use the following example.
          The <sgmltag class="attribute">include</sgmltag> attribute's value
          is relative to the application root.</para>

          <programlisting role="xml">&lt;page name="X" caption="Another JSP Page" include="a/file.jsp"/&gt;</programlisting>

          <para>To include a resource based on a dynamic value, use a value
          source specification instead of a static string. In the next example
          we'll simply include whatever resource is specified in the request
          parameter called 'url'.</para>

          <programlisting role="xml">&lt;page name="X" caption="Dynamic include" include="request:url"/&gt;</programlisting>
        </section>

        <section>
          <title>Execute a Command</title>

          <para>The <sgmltag class="starttag">page</sgmltag> <sgmltag
          class="attribute">command</sgmltag> attribute calls
          <methodname>execute()</methodname> on an instance of the
          <classname>com.netspective.sparx.command.Command</classname>
          interface and includes the content of the execution as the content
          of the page. Commands are described in detail in <xref
          linkend="section-commands" />.</para>

          <para>To display a dialog, obtain input, and include its content
          use:</para>

          <programlisting role="xml">&lt;page name="X" caption="Add Record" command="dialog,person.contact-info,add"/&gt;</programlisting>

          <para>To run a <sgmltag class="starttag">query</sgmltag> and display
          its contents in a report use:</para>

          <programlisting role="xml">&lt;page name="X" caption="Run Query" command="query,person.self-contact-info"/&gt;</programlisting>
        </section>

        <section>
          <title>Show Portal-like Pages using Panels</title>

          <para>TODO: documentation coming soon...</para>
        </section>

        <section>
          <title>The <sgmltag class="starttag">body</sgmltag> tag</title>

          <para>The <sgmltag class="starttag">body</sgmltag> tag starts begins
          a definition of a page body appears under the <sgmltag
          class="starttag">page</sgmltag> tag and its contents are handled by
          the FreeMarker templating engine. The <sgmltag
          class="starttag">body</sgmltag> tag is used when you want as much
          control over the content as possible because the entire body will be
          processed by a FreeMarker template. This means using a custom
          template, HTML, or other processing system (in case you're not using
          FreeMarker). If you don't specify a <sgmltag
          class="attribute">source</sgmltag> attribute then you can include
          the body content directly in the XML (but you will be responsible
          for escaping any tags that may interfere with XML processing). If
          you specify a <sgmltag class="attribute">source</sgmltag> attribute
          then you may provide an external template to load and execute. The
          external template's location is relative to the APP_ROOT
          directory.</para>
        </section>

        <section>
          <title>Body Handlers</title>

          <para>TODO: documentation coming soon...</para>

          <section>
            <title>HTML Subsite Handler</title>

            <para>There are many cases when an existing website needs to be
            shown as part of another application. There are two ways of
            handling this: using frames or using the sub-site type. The
            following examples shows how a DocBook chunked output set of files
            that we want to share our navigation skin could be created as a
            page:</para>

            <programlisting>&lt;page name="manual" caption="User's Manual" heading="-" title="User's Manual"&gt;

    &lt;!-- be sure that redirect URL ends in / because of relative paths in subsite --&gt;
    &lt;redirect&gt;servlet-context-uri:/documentation/manual/&lt;/redirect&gt;     

    &lt;body-handler handler="html-sub-site"&gt;
        &lt;root&gt;servlet-context-path:/nef-manual&lt;/root&gt;
        &lt;file-not-found-message&gt;
            Please run build in &amp;lt;code&amp;gt;NEFS_HOME/support/docs&amp;lt;/code&amp;gt; to generate
            the Manual.&amp;lt;p&amp;gt;
            &amp;lt;code&amp;gt;{0}&amp;lt;/code&amp;gt; was not found.
        &lt;/file-not-found-message&gt;

        &lt;!-- because we're in a subsite we want to translate the locations of our images and resources --&gt;
        &lt;substitute&gt;
            &lt;perl-reg-ex&gt;simple-expr:s!src="\./resources/!src="${servlet-context-uri:/nef-manual/resources/}!g&lt;/perl-reg-ex&gt;
        &lt;/substitute&gt;
        &lt;substitute&gt;
            &lt;perl-reg-ex&gt;simple-expr:s!src="images/!src="${servlet-context-uri:/nef-manual/images/}!g&lt;/perl-reg-ex&gt;
        &lt;/substitute&gt;
    &lt;/body-handler&gt;
&lt;/page&gt;</programlisting>

            <para>Doing the same thing as above but using frames is easy
            too:</para>

            <programlisting>&lt;page name="manual" caption="User's Manual" heading="-" title="NEFS User's Manual"
      handle-meta-data="yes" handle-header="no" handle-footer="no"&gt;
    &lt;body&gt;
        &lt;![CDATA[
            &lt;!-- if anything comes after the manual/ path, it's considered the actual href to the DocBook file --&gt;
            &lt;#assign manualBodyPath = vc.navigationContext.activePathFindResults.getUnmatchedPath(0)?default('')/&gt;
            &lt;#if manualBodyPath != ""&gt;
               &lt;#assign manualBodyPath = "/" + manualBodyPath/&gt;
            &lt;/#if&gt;

            &lt;frameset rows="110,*"&gt;
             &lt;frame src="${vc.servletRootUrl}/documentation/manual/header" name="header" FRAMEBORDER="NO" SCROLLING="NO"&gt;
             &lt;frame src="${vc.servletRootUrl}nef-manual${manualBodyPath}" name="body" FRAMEBORDER="NO" SCROLLING="YES"&gt;
            &lt;/frameset&gt;
        ]]&gt;
    &lt;/body&gt;

    &lt;!-- make sure the targets for all hyperlinks go to the frame's parent (usually _top) --&gt;
    &lt;page name="header" caption="Sample Applications" base-attributes="target='_parent'"&gt;
        &lt;body&gt;This shouldn't appear, the frame stops right above it.&lt;/body&gt;
    &lt;/page&gt;
&lt;/page&gt;
</programlisting>
          </section>
        </section>
      </section>

      <section>
        <title>Conditionally Displaying or Hiding Pages</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Navigation Skins</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Custom Pages, Bodies, and Body Handlers</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title><classname>NavigationControllerServlet</classname> Processing
        Overview</title>

        <para>This section provides an introduction to most of the classes
        involved in processing a Sparx navigation request. The exhibit below
        is a sequence diagram that depicts the general process followed for
        each request that the <literal>NavigationControllerServlet</literal>
        processes. The sequence diagram assumes that the Servlet is setup with
        the following descriptors in the
        <filename>APP_ROOT/WEB-INF/web.xml</filename> file:</para>

        <programlisting role="xml">&lt;web-app&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;<emphasis role="bold">SparxNavigationController</emphasis>&lt;/servlet-name&gt;
        &lt;servlet-class&gt;<emphasis role="bold">com.netspective.sparx.navigate.NavigationControllerServlet</emphasis>&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;<emphasis role="bold">SparxNavigationController</emphasis>&lt;/servlet-name&gt;
        &lt;url-pattern&gt;<emphasis role="bold">/*</emphasis>&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</programlisting>

        <para>The web application descriptors shown above will take all
        requests (basically any URL) and pass it along to the Sparx
        NavigationControllerServlet. The entire URL will be available to the
        Servlet as HttpServletRequest.getPathInfo() so that the appropriate
        NavigationPage can be located.</para>

        <figure>
          <title>Sparx NavigationControllerServlet Request Processing Sequence
          Diagram</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="./resources/images/sparx-uml-seq-nav-controller-no-login.gif" />
            </imageobject>
          </mediaobject>
        </figure>

        <orderedlist>
          <listitem>
            <para>TODO: documentation coming soon...</para>
          </listitem>
        </orderedlist>

        <figure>
          <title>Sparx NavigationPage Rendering Sequence Diagram</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="./resources/images/sparx-uml-seq-nav-page-render.gif" />
            </imageobject>
          </mediaobject>
        </figure>

        <orderedlist>
          <listitem>
            <para>TODO: documentation coming soon...</para>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section>
      <title>Forms and Dialogs</title>

      <para>A major component in developing any web application is giving the
      user the ability to enter data and retrieve data. Dialogs allow users to
      create new data, edit existing data, and remove data. Sparx Dialog
      objects provide a multitude of features such as client-side/server-side
      data verifications and validations, dialog state tracking, and
      consistent skinable appearances.</para>

      <section id="dialogs">
        <title>Overview</title>

        <para>Defining the dialog in the Project File is the first step
        towards creating a dialog. Dialogs are defined using the <sgmltag
        class="starttag">dialog</sgmltag> tag and each dialog must belong to a
        package of dialogs represented by the <sgmltag
        class="starttag">dialogs</sgmltag> tag. For example:</para>

        <programlisting role="xml">&lt;project&gt;
    ....
    &lt;dialogs package="train"&gt;
        &lt;dialog name="test" heading="Add Account" retain-params="*"&gt;
            &lt;frame heading="My first dialog"/&gt;

            &lt;field type="text" name="org_code" caption="Account Code" required="yes" 
                               default="request:myval"/&gt;
            &lt;field type="select" name="org_type" caption="Type" style="multidual" 
                                 choices="query:org.enum-types-all"/&gt;
            &lt;field type="integer" name="employees" caption="Employees" min="10" max="20"/&gt;

        &lt;/dialog&gt;
    &lt;/dialogs&gt;       </programlisting>

        <section>
          <title><sgmltag class="starttag">dialog</sgmltag> Tag
          Attributes</title>

          <variablelist>
            <varlistentry>
              <term>class</term>

              <listitem>
                <para>Specifies a subclass of
                <classname>com.netspective.sparx.form.Dialog</classname> to
                dynamically load and instantiate instead of the default java
                class. This attribute is very useful when you want to use XML
                for the dialog definition but want to alter the behavior of
                the Dialog processing or want to some specific validation not
                provided by the default class.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>dialog-context-class</term>

              <listitem>
                <para>All forms created using the <sgmltag
                class="starttag">dialog</sgmltag> tag are shared across all
                users. Each user, however, gets its own dialog context
                instance for every request/response cycle. Acting as a finite
                state machine, the DialogContext class is the only object in
                the entire dialog processing lifecycle that is created for
                each user. The “form model” (Dialog) and “form view” (skin)
                are created, cached, and reused for each user; however, the
                DialogContext bean or DCB is a new object for each user and
                each request. The dialog context is usually an instance of the
                <classname>com.netspective.sparx.form.DialogContext</classname>
                class. The <sgmltag
                class="attribute">dialog-context-class</sgmltag> attribute
                specifies a subclass of <classname>DialogContext</classname>
                to dynamically load and instantiate instead of the default
                java class. This attribute is very useful when you want to
                some special handling of request/response cycles that may not
                be supported by the default class.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>name</term>

              <listitem>
                <para>The name of the dialog used by Sparx. The name may only
                contain upper or lowercase letters, numbers, and underscores.
                There should no punctuation characters or spaces and the name
                should be valid JavaScript name. The fully qualified name of
                the dialog is the package name plus this name
                ("packageName.dialogName").</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>html-form-name</term>

              <listitem>
                <para>The name of the dialog created for the HTML form. This
                is usually the same as the Sparx <sgmltag
                class="starttag">dialog</sgmltag> <sgmltag
                class="attribute">name</sgmltag> but could be different if you
                need it to be so.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>redirect-after-execute</term>

              <listitem>
                <para>This attribute, which is normally true, specifies
                whether the dialog will redirect after executing (performing
                the tasks it's been instructed to perform). If this is set to
                false, then no redirect will happen after the execute --
                instead, the execute will be called and control flow remains
                on the current page. You should set this attribute to false if
                you use either the <sgmltag
                class="attribute">show-field-data</sgmltag> debugging option
                or <sgmltag class="attribute">loop</sgmltag> option.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>retain-params</term>

              <listitem>
                <para>Specifies the names of the URL parameters that should be
                retained during multiple invocations of this dialog. As
                dialogs are processed by browsers, the same dialog may be
                called during more than one request/response cycle. This
                parameter provides one or more comma-separated list of URL
                parameter names that should be kept between request/response
                cycles. If you would like to retain all parameters, pass an
                asterisk (*) as the value to this attribute.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>retain-initial-state</term>

              <listitem>
                <para>Specifies whether or not to keep track of what the
                initial data values were in the form before the user made any
                changes. Set this to true if you need to get access to the
                original data and compare it to the final data for doing
                partial inserts or doing something only if a value has
                changed.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>hide-hints-until-focus</term>

              <listitem>
                <para>Specifies whether to always show hints or hide them
                until the control receives focus.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>hide-readonly-hints</term>

              <listitem>
                <para>Specifies whether or not to show hints for read-only
                values.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>disable-client-keypress-filters</term>

              <listitem>
                <para>Sparx has built-in capabilities to not allow certain
                keypressed in specific controls. For example, integer and
                float fields do not allow text so alphabetic keys are
                disabled. Set to true if you do not want client-side keypress
                filters.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>disable-client-validation</term>

              <listitem>
                <para>Set to true if you do not want any client-side data
                validation.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>show-data-changed-message-on-leave</term>

              <listitem>
                <para>Set to true if you wish to pop up a message if the user
                has changed data on the form but is leaving the form without
                pressing submit.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>loop</term>

              <listitem>
                <para>Specifies whether or not to show the dialog even after
                the dialog executes. Many websites commonly show forms after
                searches complete, this feature allows that capability.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>loop-separator</term>

              <listitem>
                <para>When loop is set to append or prepend, this attribute
                specifies the HTML that will be inserted either before or
                after the dialog and its execution content.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>readonly-fields-hidden-unless-have-data</term>

              <listitem>
                <para>Specifies whether or not fields in this dialog that are
                flagged as read-only will be made hidden (value will still be
                available but field is not visible) if the field does not have
                a value.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>readonly-fields-unavailable-unless-have-data</term>

              <listitem>
                <para>Specifies whether or not fields in this dialog that are
                flagged as read-only will be made invisible (field will not be
                visible nor will it have any value associated with it) if the
                field does not have a value.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>show-field-data</term>

              <listitem>
                <para>This is a debugging option and will show the dialog data
                instead of performing the default execute action.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>translate-enter-key-to-tab-key</term>

              <listitem>
                <para>Set to true if the enter key should act the same as the
                tab key (move to next control).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>height</term>

              <listitem>
                <para>Set a fixed height in pixels.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>width</term>

              <listitem>
                <para>Set a fixed width in pixels.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>

      <section id="Dialogs-DataFields">
        <title>Dialog Fields</title>

        <para>A dialog is as a container/manager object consisting of data
        fields which have their own behaviors and properties. These data
        fields provide the flexibility to create customized forms for data
        processing and it also provides the ability to create new fields or
        modify existing ones. Sparx fields are similar to HTML fields but are
        far more powerful because they can format and validate themselves
        according to rules that you declare. Currently the following general
        fields are available: <itemizedlist>
            <listitem>
              <para>Text</para>
            </listitem>

            <listitem>
              <para>Integer</para>
            </listitem>

            <listitem>
              <para>Float</para>
            </listitem>

            <listitem>
              <para>Date and Time (including duration)</para>
            </listitem>

            <listitem>
              <para>List</para>
            </listitem>

            <listitem>
              <para>Checkbox</para>
            </listitem>

            <listitem>
              <para>Radio Buttons</para>
            </listitem>
          </itemizedlist> Based on the fields listed above, there are fields
        which serve a more specific role also: <itemizedlist>
            <listitem>
              <para>Credit card expiration date, number, and type</para>
            </listitem>

            <listitem>
              <para>E-mail</para>
            </listitem>

            <listitem>
              <para>Zip Code</para>
            </listitem>

            <listitem>
              <para>Social Security Number</para>
            </listitem>

            <listitem>
              <para>Phone Number</para>
            </listitem>

            <listitem>
              <para>Currency</para>
            </listitem>
          </itemizedlist></para>

        <note>
          <para>Using Value Sources, Sparx provides automatic SQL, a web
          service, or other data binding to any list controls in HTML or
          DHTML. This allows, for instance a query to be run and automatically
          create text fields, a list box, radio buttons, check boxes, and
          multi-select list boxes. All dialog fields have this dynamic data
          binding capability so that arbitrary data sources can populate
          dialog contents and selections.</para>
        </note>

        <section>
          <title>Available Dialog Field Types</title>

          <para>To see a list of all of the field types available, visit the
          Enterprise Console <menuchoice>
              <guimenu>Presentation</guimenu>

              <guisubmenu>Dialogs</guisubmenu>

              <guimenuitem>Form Fields</guimenuitem>
            </menuchoice> page. This Console page will always display all of
          the available field types registered using the <sgmltag
          class="starttag">field-type</sgmltag> template producer (including
          all built-in field types and any custom field types you register).
          Clicking on any field type name will show the list of attributes and
          elements supported by the particular field type. Although this
          section of the document ion introduces you to many of the form field
          types available in Sparx, there are still quite a few that it does
          not cover in detail so you should browse the Console to review all
          of them.</para>

          <screenshot>
            <graphic fileref="./resources/images/screen-console-pres-dialogs-field-types.gif" />
          </screenshot>
        </section>

        <section>
          <title>Attributes common to all Dialog Field Types</title>

          <para>The following list describes the set of attributes that are
          allowed by default for all fields. Each field type (like a integer,
          currency, or select) might define additional attributes for special
          features but all fields share the attributes listed below.</para>

          <variablelist>
            <varlistentry>
              <term><sgmltag class="attribute">class</sgmltag></term>

              <listitem>
                <para>Override the class used for the field.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">name</sgmltag></term>

              <listitem>
                <para>The name of the field. If this field is a child of a
                composite or grid field, the name provided is automatically
                appended to the parent's name to create a unique name. The
                actual name of the control when the HTML is generated is
                usually <literal>_dc.fieldName</literal>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">caption</sgmltag></term>

              <listitem>
                <para>The caption or label that describes the usage of the
                field to the end user. If this field is a member of a
                composite or grid field then the caption will only show if the
                parent field's show-child-caption is set to yes.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">error-caption</sgmltag></term>

              <listitem>
                <para>Usually, when an error is displayed to the user, the
                <sgmltag class="attribute">caption</sgmltag> attribute's value
                is used as the identifier for the error message. If you want a
                different caption to be used for the field in error messages
                then specify it here.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">default</sgmltag></term>

              <listitem>
                <para>The single value source (or list value source if
                appropriate) that specifies the default value of the field.
                The default value is the value that is pre-filled into a
                dialog field when it is initially displayed.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">hint</sgmltag></term>

              <listitem>
                <para>The text that will be shown to a user to provide a hint
                as to the usage of the field. The exact behavior of this
                attribute depends upon the skin being used, but typically the
                contents of the hint attribute are shown right under the field
                control.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">required</sgmltag></term>

              <listitem>
                <para>Specifies whether the field is required or not. If the
                field is specified as required, code is automatically
                generated that will enforce this validation rule.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">required-field-missing-message</sgmltag></term>

              <listitem>
                <para>Specifies the message that appears if the field is not
                entered and the <sgmltag class="attribute">required</sgmltag>
                flag is set to true.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">read-only</sgmltag></term>

              <listitem>
                <para>Specifies whether the field is read-only or not. If the
                value is set to yes, then the field's value becomes a static
                text string (will not generate a real HTML control). If the
                value is set to browser then the appropriate HTML control is
                still created but the control is marked read-only so the
                browser will not allow the value to be changed.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">browser-read-only</sgmltag></term>

              <listitem>
                <para>Specifies whether the field is read-only in the browser.
                The difference between the <sgmltag
                class="attribute">read-only</sgmltag> and <sgmltag
                class="attribute">browser-read-only</sgmltag> attributes is
                that the <sgmltag class="attribute">read-only</sgmltag>
                attribute will not create a browser control (the text will be
                static). The <sgmltag
                class="attribute">browser-read-only</sgmltag> will, however,
                create a browser control for the field but mark it read only
                (using HTML properties) so that it can not be changed.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">readonly-hidden-unless-has-data</sgmltag></term>

              <listitem>
                <para>If a field has its <sgmltag
                class="attribute">read-only</sgmltag> flag set to true, then
                the <sgmltag
                class="attribute">readonly-hidden-unless-has-data</sgmltag>
                flag may be specified if the entire field should become
                <sgmltag class="attribute">hidden</sgmltag> when there is no
                data available in the field. This is very useful in cases
                where a field value that is <sgmltag
                class="attribute">read-only</sgmltag> may look confusing to a
                user if the field's value is null or not supplied.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">readonly-unavailable-unless-has-data</sgmltag></term>

              <listitem>
                <para>If a field has its <sgmltag
                class="attribute">read-only</sgmltag> flag set to true, then
                the <sgmltag
                class="attribute">readonly-unavailable-unless-has-data</sgmltag>
                flag may be specified if the entire field should become
                <sgmltag class="attribute">unavailable</sgmltag> when there is
                no data available in the field. This is very useful in cases
                where a field value that is <sgmltag
                class="attribute">read-only</sgmltag> may look confusing to a
                user if the field's value is null or not supplied.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">hidden</sgmltag></term>

              <listitem>
                <para>Specifies whether the field is hidden or not. As a
                hidden field, the value of the field is still available to the
                programmer, but there will no field caption/label or input
                control available to the user.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">unavailable</sgmltag></term>

              <listitem>
                <para>Specifies whether the field is available in the form or
                not. As an unavailable field, there is no value available to
                the programmer nor is there a caption/label, or control
                available to the user. Setting a field to <sgmltag
                class="attribute">unavailable</sgmltag>=<sgmltag
                class="attvalue">yes</sgmltag> is almost like commenting out
                the field because most dialog skins will not process invisible
                fields. This flag is most useful within <sgmltag
                class="starttag">conditional</sgmltag> tags that can make a
                field disappear for security or other purposes.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">create-adjacent-area</sgmltag></term>

              <listitem>
                <para>Specifies whether to create a <sgmltag
                class="starttag">span</sgmltag> element in the HTML adjacent
                to this field. If set to yes, then a <sgmltag
                class="starttag">span</sgmltag> is created with the complete
                name of this field plus the word <literal>_adjacent</literal>.
                For example, if the field name is
                <literal>customer_id</literal> then the adjacent area will
                have the id <literal>customer_id_adjacent</literal>. This
                attribute is very useful when defined in conjunction with
                popup windows. For example, a popup window can allow a
                selection and fill data in next to a field (in an adjacent
                area).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">create-adjacent-area-hidden</sgmltag></term>

              <listitem>
                <para>Performs same action as create-adjacent-area but it
                hides the area so the value will be available to the browser
                and server processing but not visible to the end user.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">col-break-before</sgmltag></term>

              <listitem>
                <para>Specifies whether a column break should be included
                <emphasis>before</emphasis> this field. The actual behavior of
                this attribute is determined by a skin, but typically if this
                field is a primary (top-level) field, the column break will
                create a dialog with multiple columns. If this field is a
                secondary field (child of composite), then a simple line break
                will be inserted between the composite siblings.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">col-break-after</sgmltag></term>

              <listitem>
                <para>Specifies whether a column break should be included
                <emphasis>after</emphasis> this field.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">identifier</sgmltag></term>

              <listitem>
                <para>Specifies whether or not to treat the contents of this
                field as an identifier. An identifier is a field whose values
                may only contain uppercase letters, numbers, and an
                underscore.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">primary-key</sgmltag></term>

              <listitem>
                <para>Specifies whether or not to treat the contents of this
                field as a primary key for a database table. When this
                attribute is set to true, then the field acts differently
                depending upon the Dialog's Data Perspective. If it's in
                <emphasis>add</emphasis> mode (data needs to be inserted), the
                field allows data entry by the end user. If the dialog is in
                <emphasis>edit</emphasis> or <emphasis>delete</emphasis> mode,
                the field's value becomes <sgmltag
                class="attribute">read-only</sgmltag> (not able to be
                changed).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">primary-key-generated</sgmltag></term>

              <listitem>
                <para>Specifies whether or not to treat the contents of this
                field as an auto-generated primary key for a database table.
                When this attribute is set to true, then the field acts
                differently depending upon the Dialog's Data Perspective. If
                it's in <emphasis>add</emphasis> mode (data needs to be
                inserted), the field is made invisible to the end user because
                the value of the field will be generated by the application or
                the application. If the dialog is in <emphasis>edit</emphasis>
                or <emphasis>delete</emphasis> mode, the field's value becomes
                <sgmltag class="attribute">read-only</sgmltag> (not able to be
                changed) but is made visible to the user.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">initial-focus</sgmltag></term>

              <listitem>
                <para>Specifies whether to set the initial focus of the dialog
                to this field. The last field to have this value set to yes
                (in creation order) will have the focus when the dialog is
                first displayed.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">persist</sgmltag></term>

              <listitem>
                <para>Specifies whether or not to automatically remember the
                last contents of this field (as a browser cookie) for the next
                time the user loads the dialog. This can be used in the place
                of the default attribute when the user's last input value
                should be used as the default for the field.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">size</sgmltag></term>

              <listitem>
                <para>The size (usually the number of characters) of text that
                the control should display at any given time.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">min-length</sgmltag></term>

              <listitem>
                <para>The minimum length of data that the control should
                require.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">max-length</sgmltag></term>

              <listitem>
                <para>The maximum length of data that the control should
                allow.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">uppercase</sgmltag></term>

              <listitem>
                <para>Specifies whether the input should be uppercased or
                not.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">lowercase</sgmltag></term>

              <listitem>
                <para>Specifies whether the input should be lowercased or
                not.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">trim</sgmltag></term>

              <listitem>
                <para>Specifies whether the input should be trimmed (all
                leading and trailing white space removed).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">mask-entry</sgmltag></term>

              <listitem>
                <para>Specifies whether the input should be masked when
                entered. This means that data entry will be allowed but the
                control will not show the input. This is useful when getting
                passwords and other private data.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">reg-expr</sgmltag></term>

              <listitem>
                <para>Specifies a Perl5 regular expression that should be
                matched against the input data. This regular expression should
                be of the form [m]/pattern/[i][m][s][x]. Please see the
                Jakarta ORO API for more information about regular
                expressions.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">invalid-reg-ex-message</sgmltag></term>

              <listitem>
                <para>Specifies the error message to display if a
                validate-pattern is provided but the pattern does not match
                the input.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">submit-pattern</sgmltag></term>

              <listitem>
                <para>Specifies a Perl5 regular expression that should be used
                to format the input for submission to the server (for
                processing). The pattern should be of the form
                s/pattern/replacement/[g][i][m][o][s][x]. Please see the
                Jakarta ORO API for more information about regular
                expressions.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">display-pattern</sgmltag></term>

              <listitem>
                <para>Specifies a Perl5 regular expression that should be used
                to format the input for display on the screen. The pattern
                should be of the form
                s/pattern/replacement/[g][i][m][o][s][x]. Please see the
                Jakarta ORO API for more information about regular
                expressions.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">double-entry</sgmltag></term>

              <listitem>
                <para>Requires that the data must be entered twice before it
                is accepted. There is still a single field, but data entry
                happens twice and matched at the client side before data will
                be validated.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag
              class="attribute">show-caption-as-child</sgmltag></term>

              <listitem>
                <para>Specifies the behavior of the field's caption if it is
                being placed into a <sgmltag
                class="starttag">composite</sgmltag> or <sgmltag
                class="starttag">grid</sgmltag> field.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>

        <section>
          <title>Test Bed Examples</title>

          <para>The following sections contains examples of various fields and
          controls. Almost all of the examples are taken from the NEFS Test
          Bed application, which is available within the NEFS Sampler. To see
          these examples online, please visit http://www.netspective.com and
          then click the <menuchoice>
              <guimenu>Ted Bed</guimenu>

              <guisubmenu>Primary Test Bed</guisubmenu>

              <guimenuitem>/console</guimenuitem>
            </menuchoice> link. Once you enter the Enterprise Console for the
          Test Bed application, go to the Console's <menuchoice>
              <guimenu>Presentation</guimenu>

              <guisubmenu>Dialogs</guisubmenu>

              <guimenuitem>Catalog</guimenuitem>
            </menuchoice> page.</para>

          <screenshot>
            <graphic fileref="./resources/images/screen-console-test-bed-pres-dialogs-catalog.gif" />
          </screenshot>

          <para>Clicking on any dialog from the catalog will allow you to unit
          test that dialog and interact with it by entering data and
          performing validations. You will be able to test out both the
          client- and server-side validations.</para>

          <screenshot>
            <graphic fileref="./resources/images/screen-console-test-bed-pres-test-dialog-01a-val.gif" />
          </screenshot>

          <para>After entering your test data and submitting the form you can
          test how the server-side processing will see the fields and data by
          reviewing the dialog debugger output. When the Dialog Context Debug
          panel appears (after submitting your form) there are multiple tabs
          available that show a variety of debugging data.</para>

          <screenshot>
            <graphic fileref="resources/images/screen-console-test-bed-pres-test-dialog-01a-debug.gif" />
          </screenshot>

          <section>
            <title>Text, Separator, Static, and HTML fields</title>

            <para>The following is an example of a dialog containing general
            text-oriented fields such as text, static, and e-mail.</para>

            <programlisting role="xml">&lt;project&gt;
    ....
    &lt;dialogs package="test"&gt;
        &lt;dialog name="DialogTest_01_A" retain-params="*" hide-hints-until-focus="yes" redirect-after-execute="false"&gt;
            &lt;frame heading="Test String Fields"/&gt;
            &lt;field type="separator" heading="Text Fields"/&gt;
            &lt;field name="text_field_required" type="text" caption="Text Required" required="yes"
                                              hint="This text field is always required"/&gt;
            &lt;field name="text_field_hidden" type="text" hidden="yes" default="request:id"/&gt;
            &lt;field name="static_field1" type="static" caption="Static 1" default="request:id" 
                                        hint="Request attribute 'id' value"/&gt;
            &lt;field name="static_field2" type="static" caption="Static 2 " default="Static Field's Value"/&gt;
            &lt;field name="text_field_optionally_required" type="text" caption="Text Required"
                hint="Text field is required when req param 'abc' has value"
                default="conditional Required Text" required="no"&gt;
                &lt;conditional action="apply-flags" flags="required" has-value="request:abc"/&gt;
            &lt;/field&gt;
            &lt;field name="text_field" type="text" caption="Text" max-length="5" uppercase="yes"
                                     hint="Text field optional (max-length=5, uppercase=yes)"/&gt;
            &lt;field name="email_field" type="e-mail" caption="Email" hint="Email field"/&gt;
            &lt;field name="masked_field" type="text" caption="Masked Field" mask-entry="yes" hint="e.g password"/&gt;
            &lt;field name="properties" type="html" caption="HTML Template Field"&gt;
                &lt;body&gt;
                    &lt;![CDATA[
                    &lt;div class='textbox'&gt;
                    This is a FreeMarker template inside a dialog (1 + 1 = ${1 + 1}).
                    &lt;/div&gt;]]&gt;
                &lt;/body&gt;
            &lt;/field&gt;
            &lt;director submit-caption="Submit" style="acknowledge"/&gt;
        &lt;/dialog&gt;                </programlisting>

            <screenshot>
              <graphic fileref="./resources/images/screen-console-test-bed-pres-test-dialog-01a.gif" />
            </screenshot>
          </section>

          <section>
            <title>Numeric, Currency, Phone, Social Security, and Zip Code
            fields</title>

            <para>The following is an example of a dialog containing general
            fields such as integer, float and specialized fields such as
            currency, social security number and zip code.</para>

            <programlisting role="xml">&lt;project&gt;
    ....
    &lt;dialogs package="test"&gt;
        &lt;dialog name="DialogTest_01_B" retain-params="*" redirect-after-execute="false"&gt;
            &lt;frame heading="Test Numeric Fields"/&gt;
            &lt;field type="separator" heading="Numeric Fields"/&gt;
            &lt;field type="integer" name="integer_field" caption="Integer Field" hint="Integer field" persist="yes"/&gt;
            &lt;field type="float" name="float_field" caption="Float Field" hint="Float field"/&gt;
            &lt;field type="currency" name="currency_field1" caption="Currency" decimals-required="2" default="123.45"
                negative-pos="after-symbol" hint="Currency field (US) with negative sign after the symbol"/&gt;
            &lt;field type="currency" name="currency_field2" caption="Currency" decimals-required="2" default="123.45"
                negative-pos="before-symbol" hint="Currency field (US) with negative sign before the symbol"/&gt;
            &lt;field type="phone" name="phone_field1" caption="Phone Field (dash format)" strip-brackets="yes" 
                         style="dash" hint="Phone field" default="8001234567"/&gt;
            &lt;field type="phone" name="phone_field2" caption="Phone Field (bracket format)" strip-brackets="yes" 
                         style="bracket" hint="Phone field" default="8001234567"/&gt;
            &lt;field type="zip-code" name="zip_field" caption="Zip Field" hint="Zip code field" default="12345"/&gt;
            &lt;field type="ssn" name="ssn_field" caption="SSN" strip-dashes="yes" default="999999999" 
                         hint="Social Security Number field"/&gt;
            &lt;director submit-caption="Submit"/&gt;
        &lt;/dialog&gt;                </programlisting>

            <screenshot>
              <graphic fileref="./resources/images/screen-console-test-bed-pres-test-dialog-01b.gif" />
            </screenshot>
          </section>

          <section>
            <title>Memo, Date &amp; Time, Boolean fields</title>

            <para>The following is a definition for a dialog which contains a
            memo field, several versions of the date and time field, and
            several versions of the boolean field.</para>

            <programlisting role="xml">&lt;project&gt;
    ....
    &lt;dialogs package="test"&gt;
        &lt;dialog name="DialogTest_02" retain-params="*" redirect-after-execute="false"&gt;
            &lt;frame heading="Test Memo, Date/Time, Boolean Fields"/&gt;
            &lt;field type="separator" name="memo_section" heading="Memo"/&gt;
            &lt;field type="memo" name="memo_field_01" caption="Memo Field" default="A fox jumped over the fence" 
                               max-length="10" hint="Max length is 5 characters"/&gt;
            &lt;field type="separator" name="date_time_section" heading="Date and Time Fields"/&gt;
            &lt;field type="date" name="date_field_strict" caption="Date (Strict Year)" format="MM-dd-yyyy" 
                               client-calendar-format="MM-dd-yyyy"
                               default="today" hint="Format is MM-dd-yyyy"/&gt;
            &lt;field type="date" name="date_field_nonstrict" caption="Date (Non-Strict Year)" 
                               client-calendar-format="MM/dd/yyyy" strict-year="no" 
                               default="today+1" hint="Format is MM/dd/yyyy"/&gt;
            &lt;field type="time" name="time_field" caption="Time" strict-time="no" initial-focus="yes" 
                               default="now" hint="Format is HH\:mm"/&gt;
            &lt;field type="date-time" name="datetime_field" caption="Date and Time" format="MM-dd-yyyy HH:mm" 
                                    client-calendar-format="MM-dd-yyyy" default="today" hint="Format is MM-dd-yyyy"/&gt;
            &lt;field type="separator" name="boolean_section" heading="Boolean Fields"/&gt;
            &lt;field type="boolean" name="bool_field_radio" caption="Boolean Field (Radio)" style="radio"/&gt;
            &lt;field type="boolean" name="bool_field_alone" caption="Boolean Field (Alone)" style="check-alone"/&gt;
            &lt;field type="boolean" name="bool_field_combo" caption="Boolean Field (Combo)" style="combo"/&gt;
            &lt;director submit-caption="Submit"/&gt;
        &lt;/dialog&gt;                </programlisting>

            <screenshot>
              <graphic fileref="./resources/images/screen-console-test-bed-pres-test-dialog-02.gif" />
            </screenshot>

            <variablelist>
              <varlistentry>
                <term><sgmltag class="element">field
                type="memo"</sgmltag></term>

                <listitem>
                  <para>The <sgmltag class="starttag">field
                  type="memo"</sgmltag> is based on the HTML TEXTAREA element
                  and the attribute <sgmltag
                  class="attribute">max-length</sgmltag> is used to enforce
                  the maximum number of characters allowed in the memo field.
                  Javascript client-side validations are done to enforce the
                  maximum number of characters allowed.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><sgmltag class="element">field
                type="duration"</sgmltag></term>

                <listitem>
                  <para>The duration field, <sgmltag class="starttag">field
                  type="duration"</sgmltag>, is used to allow entry of a begin
                  date and an end date. It has client-side validations to make
                  sure that the date values are valid and that beginning date
                  field is before the end date field.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><sgmltag class="element">field
                type="date"</sgmltag></term>

                <listitem>
                  <para>By default date fields, <sgmltag
                  class="starttag">field type="date"</sgmltag> do not allow
                  2-digit years and this can be changed by setting the
                  attribute <sgmltag
                  class="attribute">strict-year="no"</sgmltag>. Also the
                  format of a date field can be specified by setting the
                  attribute <sgmltag class="attribute">format</sgmltag>. The
                  value for <sgmltag class="attribute">format</sgmltag> is
                  based on the
                  <classname>java.text.SimpleDateFormat</classname>'s pattern
                  strings. The date field also has a built-n client-side
                  formatting feature which will automatically format the user
                  entered value: user enters 11021999 and it gets displayed as
                  11/02/1999. The default value of the date field accepts
                  special strings such as "<emphasis>today</emphasis>" and
                  "<emphasis>now</emphasis>" and interprets them as present
                  date. Any numerical operation defined after the special
                  string is used to recalculate the default date (for example,
                  "<emphasis>today+1</emphasis>" will display tomorrow's
                  date)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><sgmltag class="element">field
                type="time"</sgmltag></term>

                <listitem>
                  <para>The time field, <sgmltag class="starttag">field
                  type="time"</sgmltag>, is used to allow entry of a time
                  value. It has client-side validations to make sure that the
                  time entered is valid. It also accepts the special string
                  "<emphasis>now</emphasis>" as a default value.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><sgmltag class="element">field
                type="boolean"</sgmltag></term>

                <listitem>
                  <para>The boolean field, <sgmltag class="starttag">field
                  type="boolean"</sgmltag>, represents different HTML
                  elements: a single checkbox, a Yes/No select list, and a
                  Yes/No radio buttons. These different elements are
                  represented by the <sgmltag
                  class="attribute">style</sgmltag> attribute with the
                  following values respectively: <emphasis>radio</emphasis>,
                  <emphasis>checkalone</emphasis>, and
                  <emphasis>combo</emphasis>. A "No" selection submits a value
                  of 0 and a "Yes" selection submits a value of 1.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>

          <section>
            <title>Select fields</title>

            <para>This section provides examples to show the different styles
            available for select fields. The XML tag, <sgmltag
            class="starttag">field type="select"</sgmltag>, is based upon the
            SELECT HTML element. It can be used as a list capable of allowing
            the user to choose one selection or multiple selections based on
            the configuration. There are six styles of selection list
            available (<emphasis>combo</emphasis>, <emphasis>radio</emphasis>,
            <emphasis>list</emphasis>, <emphasis>multilist</emphasis>,
            <emphasis>multicheck</emphasis>, and
            <emphasis>multidual</emphasis>) and they can be defined using the
            <sgmltag class="attribute">style</sgmltag> attribute. The
            <emphasis>multilist</emphasis>, <emphasis>multicheck</emphasis>,
            and <emphasis>multidual</emphasis> styles allow a selection of
            more than one option.</para>

            <programlisting role="xml">&lt;project&gt;
    ....
    &lt;dialogs package="test"&gt;
        &lt;dialog name="DialogTest_03" retain-params="*" redirect-after-execute="false"&gt;
            &lt;frame heading="Test Select Fields"/&gt;
            &lt;field type="separator" heading="Select Fields"/&gt;.
            &lt;field type="select" name="sel_field_combo" caption="Select Field (Combo)" style="combo"
                choices="text-list:Choice 1=A'S;Choice 2=B;Choice 3=C" persist="true"
                default="A'S" hidden="no" prepend-blank="yes" append-blank="yes"/&gt;

            &lt;field type="select" name="sel_field_combo_xml_items" caption="Select Field (Combo with XML Items)" 
                style="combo" persist="true" default="A'S" hidden="no" prepend-blank="yes" append-blank="yes"&gt;
                &lt;items&gt;
                    &lt;item value="A" caption="Choice 1 (in XML Item)"/&gt;
                    &lt;item value="B" caption="Choice 2 (in XML Item)"/&gt;
                    &lt;item value="C" caption="Choice 3 (in XML Item)"/&gt;
                    &lt;item value="D" caption="Choice 4 (in XML Item)"/&gt;
                    &lt;item value="E" caption="Choice 5 (in XML Item)"/&gt;
                &lt;/items&gt;
            &lt;/field&gt;

            &lt;field type="select" name="sel_field_radio" caption="Select Field (Radio)" style="radio"
                choices="text-list:[;!]Choice 1!A;Choice 2!B;Choice 3!C"/&gt;
            &lt;field type="select" name="sel_field_list" caption="Select Field (List)" style="list" size="5" 
                default="B" hidden="no" choices="text-list:Choice 1=A;Choice 2=B;Choice 3=C"/&gt;
            &lt;field type="select" name="sel_field_multilist" caption="Select Field (MultiList)" style="multilist" 
                size="5" default="text-list:A,B"
                choices="text-list:Choice 1=A;Choice 2=B;Choice 3=C"/&gt;
            &lt;field type="select" name="sel_field_multicheck" caption="Select Field (MultiCheck)" 
                style="multicheck" required="yes" choices="text-list:Choice 1=A;Choice 2=B;Choice 3=C" 
                default="text-list:A,C"/&gt;
            &lt;field type="select" name="sel_field_multidual" caption="Select Field (MultiDual)" style="multidual" 
                required="yes" choices="text-list:Choice 1=A;Choice 2=B;Choice 3=C" default="text-list:A" 
                persist="true"
                multi-dual-caption-left="Left Caption" multi-dual-caption-right="Right Caption" 
                multi-dual-width="100"/&gt;
            &lt;director submit-caption="Submit"/&gt;
            &lt;field type="select" name="sel_field_popup" caption="Select Field (Popup)" style="popup"
                choices="text-list:Choice 1=A;Choice 2=B;Choice 3=C"/&gt;
        &lt;/dialog&gt;                </programlisting>

            <screenshot>
              <graphic fileref="./resources/images/screen-console-test-bed-pres-test-dialog-03.gif" />
            </screenshot>

            <para>The choices for the select field may be provided using one
            of the following techniques:</para>

            <variablelist>
              <varlistentry>
                <term><sgmltag class="attribute">choices</sgmltag>
                attribute</term>

                <listitem>
                  <para>The choices attribute may supply a static value using
                  the <sgmltag class="attvalue">text-list:xxx</sgmltag> value
                  source or a dynamic value source such as <sgmltag
                  class="attvalue">query:abc.def</sgmltag> or <sgmltag
                  class="attvalue">session:xyz</sgmltag>. For example, you
                  could specify that the choices should be bound to the
                  results of a query by using <sgmltag
                  class="attribute">choices</sgmltag>=<sgmltag
                  class="attvalue">query:test.user_list</sgmltag>. In a query,
                  the first column will be the caption and the second column
                  (if any) will be the value sent to the server.</para>

                  <programlisting>&lt;project&gt;
    ....
    &lt;dialog ...&gt;
        ....
        &lt;field type="select" ... choices="<emphasis role="bold">query:test.user_list</emphasis>"/&gt;
        ....
    &lt;/dialog&gt;

    &lt;queries package="<emphasis role="bold">test</emphasis>"&gt;
        &lt;query name="<emphasis role="bold">user_list</emphasis>"&gt;
            select name, id
            from User
        &lt;/query&gt;
    &lt;/queries&gt;</programlisting>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><sgmltag class="starttag">items</sgmltag> tag</term>

                <listitem>
                  <para>The items tag may specify all the value/caption pairs
                  as sub-tags. Each of the captions are also value sources
                  that may be dynamic.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>

          <section>
            <title>Conditional fields</title>

            <para>Sparx provides dynamic client-side field displaying and
            hiding functionality which is defined by the <sgmltag
            class="starttag">conditional</sgmltag> tag. In the example below,
            the text field named <emphasis>text_field</emphasis> is dependent
            upon the select field named <emphasis>sel_field_list</emphasis>.
            This is done by adding the <sgmltag
            class="starttag">conditional</sgmltag> element as a child node to
            the text field and setting the attribute <sgmltag
            class="attribute">partner</sgmltag> to the name of the select
            field. The condition for displaying the text field is created by
            setting the <sgmltag class="attribute">js-expr</sgmltag>
            (Javascript expression) attribute. In the XML definition, the text
            field named <emphasis>text_field</emphasis> will only be displayed
            if the selected option of the <emphasis>sel_field_list</emphasis>
            is not the first option. The second conditional field of the
            dialog is a static field named <emphasis>static_field</emphasis>
            and its' display status is dependent upon the
            <emphasis>checkbox_field</emphasis> being "checked".</para>

            <programlisting role="xml">&lt;project&gt;
    ....
    &lt;dialogs package="test"&gt;
        &lt;dialog name="DialogTest_06" redirect-after-execute="false"&gt;
            &lt;frame heading="Test Conditionals"/&gt;
            &lt;field type="select" name="sel_field_list" caption="Select Field (Combo)" 
                   style="combo" size="5"
                   choices="text-list:Choice 1=A;Choice 2=B;Choice 3=C" prepend-blank="yes" 
                   hint="Partner field is hidden. Select 'Choice 2' to see it."/&gt;
            &lt;field type="text" name="static_field" default="Here I am!" 
                hint="Partner field is Select Field (Combo)"&gt;
                &lt;conditional action="display" partner-field-name="sel_field_list" 
                             expression="control.selectedIndex == 2"/&gt;
            &lt;/field&gt;
            &lt;field type="boolean" name="checkbox_field" caption="Checkbox" 
                  style="check-alone" hint="Click me to see my hidden static field."/&gt;
            &lt;field type="static" name="static_field2" default="Checkbox checked!"&gt;
                &lt;conditional action="display" partner-field-name="checkbox_field" 
                             expression="control.checked == true"/&gt;
            &lt;/field&gt;
        &lt;/dialog&gt;                </programlisting>

            <screenshot>
              <graphic fileref="./resources/images/screen-console-test-bed-pres-test-dialog-06.gif" />
            </screenshot>

            <para>Aside from the <sgmltag class="attribute">action</sgmltag>
            attribute, there are other useful attributes available such as
            <sgmltag class="attribute">apply-flag</sgmltag> and <sgmltag
            class="attribute">clear-flag</sgmltag>. The following values are
            available for these two attributes: For setting or removing these
            flags depend upon other attributes such as <sgmltag
            class="attribute">data-cmd</sgmltag>, <sgmltag
            class="attribute">has-permission</sgmltag>, and <sgmltag
            class="attribute">lack-permission</sgmltag>. The <sgmltag
            class="attribute">data-cmd</sgmltag> is used to indicate the
            dialog data mode (add, edit, or delete) in which the defined flag
            should be cleared or set. The <sgmltag
            class="attribute">has-permission</sgmltag> and <sgmltag
            class="attribute">lack-permission</sgmltag> attributes are used to
            modify the flag dependent upon the security access level of the
            user. These two attributes can only be used when Sparx's security
            access control list is being used.</para>
          </section>

          <section>
            <title>Popup fields</title>

            <para>Sparx provides a feature to display a popup dialog box when
            a popup icon is clicked and values from a selection in the popup
            can be returned to the main window.</para>

            <programlisting role="xml">&lt;project&gt;
    ....
    &lt;dialogs package="test"&gt;
        &lt;dialog name="DialogTest_06" redirect-after-execute="false"&gt;
            &lt;frame heading="Test Conditionals"/&gt;
            &lt;field type="select" name="sel_field_list" caption="Select Field (Combo)" 
                   style="combo" size="5"
                   choices="text-list:Choice 1=A;Choice 2=B;Choice 3=C" prepend-blank="yes" 
                   hint="Partner field is hidden. Select 'Choice 2' to see it."/&gt;
            &lt;field type="text" name="static_field" default="Here I am!" 
                hint="Partner field is Select Field (Combo)"&gt;
                &lt;conditional action="display" partner-field-name="sel_field_list" 
                             expression="control.selectedIndex == 2"/&gt;
            &lt;/field&gt;
            &lt;field type="boolean" name="checkbox_field" caption="Checkbox" 
                  style="check-alone" hint="Click me to see my hidden static field."/&gt;
            &lt;field type="static" name="static_field2" default="Checkbox checked!"&gt;
                &lt;conditional action="display" partner-field-name="checkbox_field" 
                             expression="control.checked == true"/&gt;
            &lt;/field&gt;
        &lt;/dialog&gt;                </programlisting>

            <para>The above example displays a dialog with a text field named
            <emphasis>text_field_2</emphasis> which cannot be filled in by the
            user but can only be filled in from a popup box associated with
            it. By clicking on the popup icon () the URL defined as the
            action, <literal>textJS.html</literal>, will be displayed in a
            popup window. The process through a value or multiple values being
            returned into the <emphasis>text_field_2</emphasis> is to invoke a
            Javascript method called <literal>populateValues()</literal>
            provided by Sparx. The following is an example of a HTML string to
            invoke the Javascript method:</para>

            <programlisting>&lt;a href="javascript:opener.activeDialogPopup.populateControls('Here it is!')"&gt;
    Click here to fill in the field
&lt;/a&gt;</programlisting>

            <screenshot>
              <graphic fileref="./resources/images/screen-console-test-bed-pres-test-dialog-07.gif" />
            </screenshot>
          </section>
        </section>

        <section>
          <title>Custom Fields</title>

          <para>Every type of field available has its own both client-side and
          server-side validation features. For example, an integer field
          allows only numerical values into the field and a social security
          number field only allows dashes and numeric digits. Aside from using
          the built-in fields, Sparx provides a way to create new fields using
          the Java class called
          <classname>com.netspective.sparx.form.field.DialogField</classname>.
          The following is a sample class definition for creating a dialog
          field: <programlisting role="java">package my.form;

import com.netspective.sparx.form.field.DialogField;

public class NewField extends DialogField
{
    ...
    ..
}</programlisting> The following XML entry must be added to the dialog's
          package so that the dialog can access the field. The following is an
          example of a dialog using the <classname>NewField</classname>:
          <programlisting role="xml">&lt;dialogs package="Test"&gt;
    &lt;dialog name="TestNewField" heading="Test New Field"&gt;
        &lt;field <emphasis role="bold">class="my.form.NewField"</emphasis> name="new_field" caption="My New Field" ... /&gt;
        ....
        ...
    &lt;/dialog&gt;
&lt;/dialogs&gt;     </programlisting>If you plan on using your new class more
          than once, it may be more convenient to create a field type XDM
          template. For example, you can use the <sgmltag
          class="attribute">field-type</sgmltag> tag to register a field type
          and then use the <sgmltag class="starttag">field</sgmltag> tag's
          <sgmltag class="attribute">type</sgmltag> attribute to specify the
          form field type.</para>

          <programlisting role="xml">&lt;project&gt;
    ...
    <emphasis role="bold">&lt;field-type name="newField" class="my.form.NewField"/&gt;</emphasis>
    ...
    &lt;dialogs package="Test"&gt;
        &lt;dialog name="TestNewField" heading="Test New Field"&gt;
            &lt;field <emphasis role="bold">type="newField"</emphasis> name="new_field" caption="My New Field" ... /&gt;
            ...</programlisting>
        </section>
      </section>

      <section id="Dialogs-DataCommands">
        <title>Dialog Perspectives</title>

        <para>One of the common usage of dialogs is to create, modify, and
        delete the same data such as users, orders, and contact information.
        The differences between these dialogs are minor in a sense that they
        all tend to display the same fields (but in different modes such as
        read-only or unavailable). To avoid defining the same dialog three
        times (with slight variations in field attributes) just to provide
        create, edit, and delete functionality of the same data, Sparx
        provides a feature called <emphasis>dialog data
        perspectives</emphasis>. A dialog functions differently based upon the
        data command it receives; for example, it can display fields as read
        only when the data command is delete and it can hide some fields when
        the data perspective is add. As hinted above, Sparx dialogs recognizes
        the following data perspectives:</para>

        <variablelist>
          <varlistentry>
            <term>add</term>

            <listitem>
              <para>Indicates that the dialog should be processed for
              adding/inserting records.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>edit</term>

            <listitem>
              <para>Indicates that the dialog should be processed for
              editing/updating records. This perspective will automatically
              make any primary-keys read-only.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>delete</term>

            <listitem>
              <para>Indicates that the dialog should be processed for
              deleting/removing records. This perspective will automatically
              make all fields read-only (for confirmation) and allow
              submission.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>print</term>

            <listitem>
              <para>Indicates that the dialog should be processed for printing
              data. All the items become read-only and a few tweaks are made
              so that the dialog looks more like a report than a form.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>confirm</term>

            <listitem>
              <para>Indicates that the dialog should be processed for
              confirming data. This perspective will automatically make all
              fields read-only (for confirmation) but does not infer a further
              action.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Dialog data perspectives are recognized by the dialog in two
        ways: as a request parameter or as a request attribute called
        <varname>data_cmd</varname>. The dialog behaves in different ways
        according to the data command by changing the name of the submit
        action button and also making all the fields read only for the
        <emphasis>delete</emphasis> mode. By default, there is very little
        difference in the behavior of the dialog when it is in either the
        <emphasis>add</emphasis> or <emphasis>edit</emphasis>. The
        functionality of the <emphasis>add</emphasis> or
        <emphasis>edit</emphasis> modes are enhanced more through the power of
        the conditional fields assigned to the dialog. Conditional fields can
        be configured to depend upon the mode the dialog is in so that fields
        can be read-only or unavailable.</para>

        <example>
          <title>Conditional fields dependent upon the Dialog's data
          mode</title>

          <programlisting role="xml">&lt;dialog ...&gt;
    ...
    &lt;field type="text" name="text_field_1" caption="Text Field" size="50"
           hint="Read-only when ADD" default="I guess the perspective is not 'add'"&gt;
        &lt;conditional action="apply-flags" flags="read-only" perspective="add"/&gt;
    &lt;/field&gt;

    &lt;field type="static" name="static_field_4" default="The perspective is not 'add' or 'edit'"&gt;
        &lt;conditional action="apply-flags" flags="unavailable" perspective="add | edit"/&gt;
    &lt;/field&gt;
    ...
&lt;/dialog&gt;   </programlisting>
        </example>

        <para>In the above dialog definition, the select field<sgmltag
        class="attvalue">org_type</sgmltag> and <sgmltag
        class="attvalue">org_industry</sgmltag> has conditions defined based
        upon the mode of the dialog. When the dialog is in edit or delete
        mode, the <emphasis>unavailable</emphasis> flag is applied to the
        fields. For more information on conditional fields, go to <xref
        linkend="Dialogs-DataFields" />.</para>
      </section>

      <section>
        <title>Using Dialogs</title>

        <para>Up to this point we've focused on the definition and declaration
        process. Now we'll talk about how to call and process dialogs once
        they're been defined.</para>

        <figure>
          <title>Dialog Definition, Call, and Processing Overview</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="./resources/images/sparx-dialog-decl-call-process-steps.gif" />
            </imageobject>
          </mediaobject>
        </figure>

        <orderedlist>
          <listitem>
            <para>The first step in using a dialog is to declare it using all
            of the descriptor tags discussed in previous sections. This step
            defines the dialog object but does not declare usage. A single
            dialog could be used on multiple pages so we declare the dialog
            once.</para>
          </listitem>

          <listitem>
            <para>The second step in using a dialog is to declare the actual
            call to a dialog. You can use either the "dialog
            <emphasis>is</emphasis> the page" or the "dialog is a
            <emphasis>part</emphasis> of the page" model. If the dialog will
            be the main portion of the page then you just use the dialog
            command in the page tag. If the dialog is a part of other content
            on the page then just define it as a command panel.</para>
          </listitem>

          <listitem>
            <para>In order for a dialog to actually execute, the <sgmltag
            class="starttag">page</sgmltag> defined in the <sgmltag
            class="starttag">navigation-tree</sgmltag> must be visited using a
            browser (or you can unit test it in the Console).</para>
          </listitem>

          <listitem>
            <para>From this point on, Sparx handles all dialog processing and
            will call your code when specific events need to be
            processed.</para>
          </listitem>

          <listitem>
            <para>Although Sparx handles almost all general validation for
            non-application-specific data you can ask for a callback (using a
            listener) to perform additional validation.</para>
          </listitem>

          <listitem>
            <para>Once all validation has been performed (both client- and
            server-side) and all the data is assumed to be valid then it is
            your responsibility to do something useful with the data.</para>
          </listitem>

          <listitem>
            <para>After performing your application logic you will redirect
            the navigation system to the next action using a variety of
            techniques.</para>
          </listitem>
        </orderedlist>

        <section>
          <title>Dialog State Management with Dialog Context Beans
          (DCBs)</title>

          <para>Acting as a finite state machine, the DialogContext class is
          the only object in the entire dialog processing lifecycle that is
          created for each user. The “form model” (Dialog) and “form view”
          (skin) are created, cached, and reused for each user; however, the
          DialogContext bean or DCB is a new object for each user and each
          request.</para>

          <section>
            <title>Transactions</title>

            <para>All Sparx dialogs have unique identifiers at both
            development and run-time. Features are provided to prevent
            duplicate data entry through the use of Dialog Transactions
            (preventing users from hitting the "back" button and re-running an
            older transaction).</para>
          </section>

          <section>
            <title>Generating form-specific Dialog Context Beans
            (DCBs)</title>

            <para></para>
          </section>
        </section>

        <section>
          <title>Dialog Processing Events</title>

          <para></para>
        </section>

        <section>
          <title>Dialog Execute Handlers</title>

          <para></para>
        </section>
      </section>

      <section id="Using-Dialog">
        <title>Using the dialog</title>

        <para>Sparx provides convenient yet flexible ways to use and enhance
        the behavior of Dialog objects. The most common usage of a dialog is
        to define the dialog in the <filename>WEB-INF/ui/dialog.xml</filename>
        file and then to use the JSP custom tag <emphasis
        role="bold">&lt;xaf:dialog&gt;</emphasis> to invoke the dialog.
        <programlisting role="xml">

    &lt;xaf:dialog name="test.Test1"/&gt;

            </programlisting> This utilizes the built-in functionality and
        behavior of a Sparx dialog. The user does not need to be concerned
        with various processes of a HTML form submittal such as data
        validations, verifying the correct stage execution (blocking redundant
        submittals), and processing the form's action. The common way to
        define an action for a dialog is to insert the action items within the
        dialog's start and end tags: <programlisting role="xml">

         &lt;xaf:dialog name="test.Test1"&gt;
            &lt;xaf:query name="MyQuery" skin="report"/&gt;
         &lt;/xaf:dialog&gt;

            </programlisting> The above snippet of JSP code describes a dialog
        which will execute a SQL query when it is submitted. Instead of a
        query, one can also write pure Java code: <programlisting role="xml">

     &lt;xaf:dialog name="test.Test1"&gt;
        &lt;%
            response.sendRedirect("/home");
        %&gt;
     &lt;/xaf:dialog&gt;

            </programlisting> Everything within the dialog custom tags (HTML,
        Java code, custom tags) are considered the action of the
        dialog.</para>

        <para>Usually, the action of the dialog is defined outside of the
        definition of the dialog such as in the JSP but there is a way to
        define an action for a dialog within the
        <filename>WEB-INF/ui/dialog.xml</filename>. The following is an
        example: <programlisting role="xml">&lt;dialog name="Test4" heading="Test Fields" loop="yes" retain-params="*"&gt;
    &lt;field type="report" name="report_field"&gt;
        &lt;statement name="list"&gt;
            select 0 as "checkbox", userid as "ID", lname as "Name"
            from users

            &lt;report skin="eimo-report"&gt;
                &lt;column type="checkbox" align="center" field-name="my_name" field-value="my_name_row_${1}"/&gt;
                &lt;column heading="ID" output="abc% $ ${2}" format="%"/&gt;
                &lt;column heading="Last Name" url="create-app-url:/${2}" calc="count"/&gt;
            &lt;/report&gt;
        &lt;/statement&gt;
    &lt;/field&gt;
&lt;/dialog&gt;
         </programlisting></para>

        <section>
          <title>Using listeners</title>

          <para>Sparx provides a way to implement business logic into the
          behavior of a dialog by providing a feature called
          <emphasis>Listeners</emphasis>. A listener is a Java object which is
          invoked when state changes occur in a dialog. It contains various
          behavior methods such as execution, data validation, and data
          population. All listeners must extend Sparx's listener class
          <classname>com.netspective.sparx.form.DefaultDialogContextListener</classname>.
          The following is an example of a listener used in a JSP:
          <programlisting role="jsp">

    request.setAttribute
    ("test-listener", new DefaultDialogContextListener()
        {
            public boolean isDialogValid(DialogContext dc, boolean fieldsAlreadyValidated)
            {
                // insert code here to validate dialog
            }
        }
    );

    &lt;xaf:dialog name="Test.Test1" listener="test-listener"/&gt;


            </programlisting> In the example above, the
          <emphasis>test-listener</emphasis>'s
          <methodname>isDialogValid</methodname> method is called when the
          dialog needs to check validity of data, before the dialog has
          performed its own validation.</para>
        </section>

        <section>
          <title>Defining a customized Java Dialog class</title>

          <para>There could be times when the total built-in behavior of a
          dialog does not satisfy the requirements of a web application; thus
          Sparx provides a way to create a dialog object in Java. A dialog can
          be created using a Java class which must extend the Sparx's dialog
          class called
          <classname>com.netspective.sparx.form.Dialog</classname>:
          <programlisting role="java">

package Test;

public class Test1  extends com.netspective.sparx.form.Dialog
{
    ...
    ..
}

            </programlisting> The behavior of the dialog can then be modified
          by overwriting the methods available or introducing new methods. The
          new dialog class can then be used by associating the class with a
          dialog definition in <filename>WEB-INF/ui/dialog.xml</filename>
          file: <programlisting role="xml">

        &lt;dialog name="TestDialog" heading="Test Dialog" class="Test.Test1"&gt;
            ...
            ..
        &lt;/dialog&gt;

            </programlisting></para>
        </section>
      </section>

      <section>
        <title>Server and Client-side Validation</title>

        <para>Sparx provides comprehensive client- and server-side validation
        logic for text, date, numeric, and other user-defined fields. All
        fields in Sparx are object- oriented and know how to draw themselves
        onto HTML and DHTML browsers.</para>

        <section>
          <title>Server-side Validation</title>

          <para></para>
        </section>

        <section>
          <title>Client-side Validation (JavaScript)</title>

          <para>A sophisticated Javascript library accompanies the server-side
          validation functionality that is intrinsic to Sparx (including
          keypress filters for allowing only specific keys to be pressed in
          certain field types likes numeric and date). Using the client-side
          Javascript validation, features like required fields and
          conditionally displayed fields become trivial to implement and test.
          In addition to the basic JavaScript object model, programmers can
          insert (extend) or replace JavaScript feature with their own custom
          functionality. External custom JavaScript files may also be included
          into any dialog or page.</para>

          <example>
            <title>Client-side Validation using JavaScript</title>

            <para>The following example demonstrates a variety of ways that
            Sparx supports client-side validation through JavaScript. You can
            choose to either extend the existing JavaScript functionality or
            override it.<programlisting role="xml">&lt;dialog name="DialogTest_12" heading="Test Custom Javascript"&gt;
    &lt;client-js href="create-app-url:/resources/images/scripts/eimo.js"/&gt;

    &lt;field type="float" name="float_field" caption="Float"&gt;
        &lt;client-js event="is-valid" type="extends" js-expr="return testValid(field, control);"/&gt;
        &lt;client-js event="value-changed" type="extends" js-expr="return testNum(field, control);"/&gt;
    &lt;/field&gt;

    &lt;field type="integer" name="integer_field" caption="Integer"&gt;
        &lt;client-js event="is-valid" type="override" js-expr="return testValid(field, control);"/&gt;
        &lt;client-js event="value-changed" type="extends" js-expr="return testNum(field, control);"/&gt;
        &lt;client-js event="click" type="extends" js-expr="alert('onClick');return true;"/&gt;
        &lt;client-js event="get-focus" type="extends" js-expr="alert('onFocus!');return true;"/&gt;
        &lt;client-js event="lose-focus" type="extends" js-expr="alert('onBlur!');return true;"/&gt;
        &lt;client-js event="key-press" type="extends" js-expr="alert('onKeypress!');return true;"/&gt;
    &lt;/field&gt;

    &lt;field type="ssn" name="ssn_field" caption="SSN"&gt;
        &lt;client-js event="is-valid" type="override" js-expr="return true;"/&gt;
        &lt;client-js event="value-changed" type="override" js-expr="return true;"/&gt;
    &lt;/field&gt;
&lt;/dialog&gt;</programlisting></para>
          </example>
        </section>
      </section>

      <section>
        <title>Dialogs as Services</title>

        <para>Dialogs allow data to be auto-populated and auto-executed. This
        means that a single dialog can serve multiple purposes: for use as a
        front-end for a user to edit/enter data and for a back-end process to
        enter data through a scripted process and automatically execute the
        same dialog as if a user had entered the data manually. This way, the
        same code can double as both a web-based application UI component and
        as a web service when the need arises.</para>
      </section>

      <section>
        <title>Dialog Processing Overview</title>

        <para>This section discusses the overview of the forms creation,
        caching, state management, and output.</para>

        <figure>
          <title>Sparx Forms Processing Class Interactions Overview</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="./resources/images/sparx-dialog-processing-overview.gif" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <section>
      <title>Themes and Skins</title>

      <para>TODO: documentation coming soon...</para>
    </section>

    <section>
      <title>Template Engines</title>

      <para>TODO: documentation coming soon...</para>
    </section>
  </chapter>

  <chapter>
    <title>Project Security Declarations</title>

    <para>TODO: documentation coming soon...</para>

    <section>
      <title>Login Managers</title>

      <para>TODO: documentation coming soon...</para>
    </section>

    <section>
      <title>Authenticated Users and Personalization</title>

      <para>TODO: documentation coming soon...</para>
    </section>

    <section>
      <title>Access Control Lists</title>

      <para>TODO: documentation coming soon...</para>
    </section>

    <section>
      <title>Role-based Navigation Trees</title>

      <para>TODO: documentation coming soon...</para>
    </section>

    <section>
      <title>Role- and permission-based Forms and Fields</title>

      <para>TODO: documentation coming soon...</para>
    </section>
  </chapter>

  <chapter>
    <title>Project Data Management Declarations</title>

    <para>Every enterprise application beyond the simplest Hello World program
    will require access to a relational database management system to store
    data, retrieve it, and report on it. NEF's Axiom framework provides
    sophisticated data management capabilities using simple XML tags and Java
    APIs. All of the database-related functionality is managed in Axiom while
    the presentation portions are handled by Sparx.</para>

    <section>
      <title>Connection Providers</title>

      <para>To set up your database, you need to have a database connection
      (data source) pointing towards your database. This is accomplished by
      using the <sgmltag>connection-provider</sgmltag> tag in the Project File
      (<filename>project.xml</filename>).</para>

      <para><example>
          <title>Setting up the Data Source for Books Application</title>

          <programlisting>&lt;project xmlns:xdm="http://www.netspective.org/Framework/Commons/XMLDataModel"&gt;
...
&lt;<emphasis>connection-provider</emphasis> <emphasis>
                 class="com.netspective.axiom.connection.JakartaCommonsDbcpConnectionProvider"</emphasis>&gt; <co
              id="declare-conn-provider-tags-eg-1" />
 &lt;<emphasis>data-source</emphasis> name="<emphasis>jdbc/default</emphasis>"&gt; <co
              id="declare-conn-provider-tags-eg-2" />
  &lt;<emphasis>driver-class</emphasis>&gt;org.hsqldb.jdbcDriver&lt;/driver-class&gt; <co
              id="declare-conn-provider-tags-eg-3" />
  &lt;<emphasis>url</emphasis>&gt;
  vs-expr:jdbc:hsqldb:${servlet-context-path:/WEB-INF/database/instance/db} <co
              id="declare-conn-provider-tags-eg-4" />
  &lt;/url&gt; 
  &lt;<emphasis>user</emphasis>&gt;sa&lt;/user&gt; <co
              id="declare-conn-provider-tags-eg-5" />
  &lt;<emphasis>password</emphasis>&gt;&lt;/password&gt; <co
              id="declare-conn-provider-tags-eg-6" />
 &lt;/data-source&gt;
&lt;/connection-provider&gt;</programlisting>
        </example><calloutlist>
          <callout arearefs="declare-conn-provider-tags-eg-1">
            <para>A <sgmltag>connection-provider</sgmltag> tag is used to
            declare the connection to your application's database. <note>
                <para>Note that data sources specified under this connection
                provider will be managed by the Jakarta Commons DBCP. If you
                wish to use JNDI, you simply have to specify the resource
                according to the server you're using.</para>
              </note></para>
          </callout>

          <callout arearefs="declare-conn-provider-tags-eg-2">
            <para>Each <sgmltag>connection-provider</sgmltag> tag may contain
            one or more <sgmltag>data-source</sgmltag> tags. The
            <sgmltag>data-source</sgmltag> tag is used to specify the data
            source for the application. Any data source called
            '<emphasis>jdbc/default</emphasis>' is automatically used as the
            default JDBC data source. That is why the name of the data source
            in the above example code is set to "<literal>jdbc/default".
            </literal><note>
                <para>If you wish to change the name of the default data
                source, you may specify it in <filename>project.xml</filename>
                using the <sgmltag>default-data-source</sgmltag> tag.</para>
              </note></para>
          </callout>

          <callout arearefs="declare-conn-provider-tags-eg-3">
            <para>The <sgmltag>driver-class</sgmltag> tag is used to provide
            the driver to be used for the specified database.</para>
          </callout>

          <callout arearefs="declare-conn-provider-tags-eg-4">
            <para>The url is the JDBC URL used to connect to the database. The
            JDBC driver uses it to point to a specific database on a specific
            server. The URL has three parts which are separated by a colon
            "<literal>:</literal>". The first part is always
            "<literal>jdbc</literal>" and the second part is usually the name
            of the driver. In the example code, <literal>hsqldb</literal> is
            the name of the driver that is used to connect to your
            <productname>HypersonicSQL</productname> database. The third part
            is the name of the database.</para>

            <para>It is important to note the
            <sgmltag>servlet-context-path</sgmltag> value source. Value
            sources allow dynamic data to be included in XML without creating
            a programming language inside XML. In the example code, the
            <sgmltag>servlet-context-path</sgmltag> value source creates the
            database named '<literal>db</literal>' in <filename
            class="directory">WEB-INF</filename>/<filename
            class="directory">database</filename>/<filename
            class="directory">instance</filename> folder.</para>
          </callout>

          <callout arearefs="declare-conn-provider-tags-eg-5">
            <para>The <sgmltag>user</sgmltag> tag defines a default user to
            log in to the database. The example code specifies
            '<literal>sa</literal>' which is the default user for System
            Administrator.</para>
          </callout>

          <callout arearefs="declare-conn-provider-tags-eg-6">
            <para>The <sgmltag>password </sgmltag>tag is used to provide the
            password for the log in user. The default '<literal>sa</literal>'
            user has no password.</para>
          </callout>
        </calloutlist><note>
          <para>Please review Tag Documentation in the Console to get further
          details on each tag.</para>
        </note></para>
    </section>

    <section>
      <title>Database Policies</title>

      <para></para>
    </section>

    <section>
      <title>Static Queries</title>

      <para>The Static Queries package allows all SQL statements and dynamic
      parameters used in a project to be declared in XML. Once defined, a
      single or multiple SQL statements may be used in reports, dialogs
      (forms), Servlets, templates, or JSP-pages. In many cases, SQL statement
      pooling completely replaces simple data-serving beans since data objects
      are automatically created for all SQL statements. Data can be easily
      aggregated from multiple data sources because each SQL statement in the
      statement pool can be specified (either in XML or JSP) to come from a
      variety of pre-defined or dynamic data sources. In addition to basic SQL
      management (like prepare, bind parameters, and execute) the Sparx static
      queries objects automatically maintain performance and usage
      statistics.</para>

      <section id="Query">
        <title>Overview</title>

        <para>NEF provides a centralized location to create and store all
        static SQL statements with bind parameters in a single repository: the
        Project File. The XML file also provides the flexibility of defining
        sql statements for multiple data sources in one centralized
        location.</para>
      </section>

      <section>
        <title>What's the difference?</title>

        <para>Lets say you want to query a database table and return the
        selected rows as a collection of JAVA objects. Without Axiom, you
        would need to:</para>

        <procedure>
          <step>
            <para>Obtain a database connection</para>
          </step>

          <step>
            <para>Construct appropriate SQL statement</para>
          </step>

          <step>
            <para>Execute SQL statement</para>
          </step>

          <step>
            <para>Loop over Result Set(s)</para>
          </step>

          <step>
            <para>For every row returned from the database, check if column is
            null or not</para>
          </step>

          <step>
            <para>Appropriately set the resulting column value into Objects
            data member</para>
          </step>

          <step>
            <para>Repeat step 6 for every column in the result set</para>
          </step>

          <step>
            <para>Set the resultant object in a collection</para>
          </step>

          <step>
            <para>Repeat steps 4 through 8 for every row in the result</para>
          </step>

          <step>
            <para>Return collection to calling code</para>
          </step>
        </procedure>

        <para>Now, the same steps with Axiom for the data management and Sparx
        for the presentation layer would become:</para>

        <orderedlist>
          <listitem>
            <para>TODO: documentation coming soon...</para>
          </listitem>
        </orderedlist>
      </section>

      <section id="Creating-Query">
        <title>Creating a static query</title>

        <para>All static queries regardless of their data source are defined
        in the Project File
        (<filename>WEB-INF/sparx/project.xml</filename>).</para>

        <section>
          <title>Defining the query</title>

          <para>A static query is defined (with or without bind parameters) by
          using the <sgmltag class="starttag">query</sgmltag> tag. It is
          important to remember that in Axiom, every static query must belong
          to a statement package represented by <sgmltag
          class="starttag">queries</sgmltag> XML tag. Two XML tags <sgmltag
          class="starttag">params</sgmltag> and <sgmltag
          class="starttag">param</sgmltag> are used to indicate the
          replacement values for the bind parameters. Even if you supply
          default bind parameters you may always override them when calling
          the query. The following is an example of a SQL statement with two
          bind parameters belonging to a sql queries package: <programlisting
          role="xml">&lt;project&gt;
    ....
    &lt;queries package="user"&gt;
        &lt;query name="info"&gt;
            select
                name,
                address,
                phone,
                email
            from
                Customers
            where
                regionid = ? and
                custid = ?
            &lt;params&gt;
                &lt;param value="request:region_id"/&gt;
                &lt;param value="request:cust_id"/&gt;
            &lt;/params&gt;
        &lt;/query&gt;
    &lt;/queries&gt;               </programlisting> The listing above show
          that the <emphasis>regionid</emphasis> and
          <emphasis>custid</emphasis> columns are defined with bind
          parameters. In the example, the values for the bind parameters are
          obtained from the HTTP request using the
          <emphasis>request</emphasis> Single Value Source. The order in which
          the bind parameters are defined within the <emphasis
          role="bold">&lt;params&gt;</emphasis> tag must be the same as the
          order in which they appear in the query statement.</para>

          <para>For the case where a SQL IN condition is necessary, a special
          parameter attribute is available. The attribute is called
          <emphasis>param-list</emphasis> and it follows the value source
          format(param-list:paramIndex). For example: <programlisting
          role="xml">&lt;project&gt;
    ....
    &lt;queries package="user"&gt;
        &lt;query name="info"&gt;
            select
                name,
                address,
                phone,
                email
            from
                Customers
            where
                regionid IN (${param-list:0}) and
                custid = ?
            &lt;params&gt;
                &lt;param values="request:region_id"/&gt;
                &lt;param value="request:cust_id"/&gt;
            &lt;/params&gt;
        &lt;/query&gt;
    &lt;/queries&gt;</programlisting> Note that <emphasis>regionid</emphasis>
          values are obtained from the <emphasis>region_id</emphasis> request
          parameter which is returning a list of values. The value attribute
          for the <emphasis role="bold">&lt;param&gt;</emphasis> tag in this
          case is <emphasis>values</emphasis> (to reflect multiple
          values).</para>
        </section>

        <section>
          <title>Defining the data source</title>

          <para>Within the XML, each SQL statement can specify either no data
          source (meaning the data comes from the default data source), a
          static data source, or a dynamic data source (meaning the data comes
          from a source that will be determined automatically based on some
          rule).</para>

          <para>To use the default data source, just leave the <sgmltag
          class="starttag">query</sgmltag> <sgmltag
          class="attribute">data-src</sgmltag> attribute out of the
          tag.</para>

          <programlisting>&lt;queries package="user"&gt;
    &lt;query name="info"&gt;</programlisting>

          <para>To use a static data source name (JNDI or other connection
          provider), just <sgmltag class="attribute">provide the
          data-src</sgmltag> attribute value with the name of the data
          source.</para>

          <programlisting>&lt;queries package="user"&gt;
    &lt;query name="info" <emphasis role="bold">data-src="jdbc/some_specific_datasource"</emphasis>&gt;</programlisting>

          <para>To use a dynamic data source name you can supply any value
          source for the data source name. So, for example, if the data source
          name is stored in a session attribute called <sgmltag
          class="attvalue">user_data_src</sgmltag> when the user logs in you
          can use:</para>

          <programlisting>&lt;queries package="user"&gt;
    &lt;query name="info" <emphasis role="bold">data-src="session:user_data_src"</emphasis>&gt;</programlisting>
        </section>

        <section>
          <title>Defining alternate SQL for different databases</title>

          <para></para>
        </section>

        <section>
          <title>SQL injection (dynamic replacements in SQL)</title>

          <para>In certain cases there are requirements that specify a SQL
          statement is generally the same except in certain circumstances. For
          these situations, Axiom allows for quasi-dynamic SQL statements that
          have the ability to do macro replacements inside the SQL as well as
          parameters. The SQL statement can have macros that are replaced each
          time the SQL is called and the parameters that may be passed in are
          dynamic (using single-value and list-value sources). The most common
          usage of this feature is to create an IN clause.</para>
        </section>

        <section>
          <title>Presenting the results of a Query</title>

          <para>The display result of the query execution can be configured
          easily using the <sgmltag class="starttag">report</sgmltag> XML tag
          . Column names can be assigned and the actual result itself can be
          aligned or modified as a URL.<programlisting role="xml">&lt;project&gt;
    ....
    &lt;queries package="books"&gt;
        &lt;query name="get-all-books"&gt;

            select id, name, author, book_type.caption, isbn
            from book_info, book_type
            where genre = book_type.id

            &lt;presentation&gt;
                &lt;panel name="main" height="300"&gt;
                    &lt;frame heading="static:All available books"/&gt;
                    &lt;report&gt;
                        &lt;column heading="ID" format="plain" redirect="page-id:/edit?id=${0}"/&gt;
                        &lt;column heading="Name" /&gt;
                        &lt;column heading="Author"/&gt;
                        &lt;column heading="Genre"/&gt;
                        &lt;column heading="ISBN"/&gt;
                    &lt;/report&gt;
                &lt;/panel&gt;
            &lt;/presentation&gt;
        &lt;/query&gt;
    &lt;/queries&gt;                </programlisting>Each <sgmltag
          class="starttag">column</sgmltag> XML tag of the report corresponds
          to the query statement's result set column entry though the
          attribute <emphasis>index</emphasis> (if all the columns follow the
          order of the columns in the SQL select clause the index attribute
          may be left out). The query above does not specify the data source
          thus giving it the flexibility to be used for multiple data
          sources.</para>
        </section>
      </section>

      <section id="Testing-Query">
        <title>Testing the static query</title>

        <section>
          <title>Unit Testing</title>

          <para>Most static queries can be unit tested using though the
          Enterprise Console. The <menuchoice>
              <guimenu>Database</guimenu>

              <guimenu>SQL Statements</guimenu>
            </menuchoice> menu entry in Console displays all the SQL
          statements defined in
          <filename>web-app/Site/WEB-INF/ui/statement.xml</filename> as shown
          below.</para>

          <para><mediaobject>
              <imageobject>
                <imagedata fileref="./resources/images/statements/ace-statements.jpg"
                           format="JPEG" />
              </imageobject>
            </mediaobject> By clicking on the execute icon of any of the
          queries, one can test the execution of that SQL query.</para>
        </section>

        <section>
          <title>Integration Testing</title>

          <para>A custom tag called <emphasis
          role="bold">&lt;xaf:query&gt;</emphasis> is available to use a
          static query within a JSP file. The following is an example of using
          the query defined above inside a JSP: <programlisting role="xml">
    &lt;xaf:query name="user.info" skin="report" debug="no"/&gt;
                    </programlisting></para>
        </section>
      </section>

      <section id="Using-Query">
        <title>Using the static query</title>

        <section id="Using-Query-Tag">
          <title>Using the query command</title>

          <para>Static queries can be executed inside Sparx pages using the
          query command. The execution of the query can also be configured in
          different ways: to display reports, to fill in HTML dialogs, or to
          save the data in arrays inside of displaying them.</para>

          <section>
            <title>Used as a report</title>

            <para>By default a static query report can be created by including
            the query within a JSP and describing the report type.</para>

            <programlisting role="xml">TODO: documentation coming soon...                    </programlisting>

            <para>The <sgmltag class="attribute">skin</sgmltag> attribute
            determines how the report is displayed on the screen. For example,
            the <programlisting role="xml"> skin="report" </programlisting>
            will display the retrieved data in a report format (multiple rows
            with column names as the first row) while <programlisting
            role="xml"> skin="text-csv" </programlisting> displays the
            retrieved data as comma separated variables. A static query report
            can also be created a result of a submit action of a dialog. For
            example, by listing the static query custom tag inside the custom
            dialog tag node, <sgmltag class="starttag">xaf:dialog</sgmltag> ,
            one can ensure that the query will only be executed when the
            dialog is submitted:</para>

            <programlisting role="xml">TODO: documentation coming soon...                    </programlisting>
          </section>

          <section>
            <title>Used to fill a dialog</title>

            <para>Instead of printing a report to the screen, the retrieved
            data from the static query can be saved into a proceeding dialog.
            The following JSP sample is an example of this:</para>

            <programlisting role="xml">TODO: documentation coming soon...     </programlisting>

            <para>The data retrieved from the query is not displayed but it is
            filled into the dialog through the
            <emphasis>store="form:*"</emphasis> and
            <emphasis>report="none"</emphasis> settings. For this to work, the
            dialog field names must be the same as the column names defined in
            the query statement.</para>
          </section>

          <section>
            <title>Used to create an array variable</title>

            <para>The retrieved data from a static query can be saved into a
            HTTP request attribute or a HTTP session attribute variable. The
            following is an example of saving the data inside a request
            attribute:</para>

            <programlisting role="xml">TODO: documentation coming soon...                   </programlisting>

            <para>The above example saves the query data inside a request
            attribute called <emphasis>userInfo</emphasis> of
            <emphasis>Map</emphasis> object type.</para>
          </section>
        </section>

        <section id="Using-Query-Java">
          <title>Using Java objects</title>

          <para>NEF provides an alternative way to execute queries within a
          JSP document rather then using a <sgmltag
          class="starttag">xaf:query</sgmltag> custom tag. There are
          convenience methods provided within
          <classname>com.netspective.sparx.sql.StatementManager</classname>
          class to execute SQL queries. These methods can execute queries in
          the following ways:</para>

          <itemizedlist>
            <listitem>
              <para>Executing a static query defined in
              <filename>statement.xml</filename> by using the query id passed
              to the method as a parameter</para>
            </listitem>

            <listitem>
              <para>Executing a static query which is directly passed to the
              method as a parameter</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Defined Query</title>

            <para>The following is an example of using the
            <classname>com.netspective.sparx.sql.Queries</classname> class
            within a JSP to execute a query defined in
            <filename>statement.xml</filename>:</para>

            <programlisting role="java">TODO: documentation coming soon...</programlisting>

            <para>The above example is doing exactly the same as the following
            JSP snippet using the query custom tag (assuming the query is
            expecting the bind parameter from a request attribute called
            <literal>org_id</literal>):</para>

            <programlisting role="xml">TODO: documentation coming soon...</programlisting>
          </example>

          <example>
            <title>Passed In Query</title>

            <para>The following is an example of using the
            <classname>com.netspective.sparx.sql.StatementManager</classname>
            class within a JSP to execute a query which is passed in (not
            defined in <filename>statement.xml</filename>):</para>

            <programlisting role="java">TODO: documentation coming soon...                    </programlisting>
          </example>
        </section>
      </section>
    </section>

    <section>
      <title>Stored Procedures and Callable Statements</title>

      <para>TODO: documentation coming soon...</para>
    </section>

    <section>
      <title>Dynamic Queries</title>

      <para>The Dynamic Queries package (also known as the <emphasis>Query
      Definitions</emphasis> package) allows you to define tables, columns,
      joins, sort orders, and other important data through the use of Meta
      Information about data relationships. Once you create a query
      definition, Sparx allows end-users of your application to use simple
      HTML-based forms to automatically generate accurate SQL and
      performance-tuned statements to create paged reports or export data to
      external sources with very little effort. Instead of defining dynamic
      queries using imperative (if/then/else) Java programming using SQL
      injection, you simply provide rules to Sparx and then the end-user can
      generate SQL automatically by simply filling in some query by example
      forms.</para>

      <section id="Dynamic-Query" xreflabel="Querying Relational Data">
        <title>Overview</title>

        <para>One of Axiom's powerful features is to generate dynamic SQL
        statements based upon user input. The dynamic SQL generator can also
        generate different output formats such as pageable HTML reports with
        configurable rows per page or comma separated value (CSV) reports. The
        main component of the dynamic queries is the <emphasis>query
        definition dialog</emphasis> which is used to define bind parameters
        of the dynamic SQL statement. Thus, the dynamic query generator can be
        thought of as a combination of <emphasis>Dialog</emphasis> and
        <emphasis>Static Query</emphasis> features.</para>
      </section>

      <section id="Creating-Dynamic-Query">
        <title>Creating a dynamic query</title>

        <para>All dynamic query configurations are stored in the same
        repository as the static queries :
        <filename>WEB-INF/ui/statement.xml</filename>. A dynamic query in
        Axiom is defined with the <sgmltag
        class="element">query-defn</sgmltag> XML tag. Within this XML element,
        other XML element representations of column data fields, join tables
        and conditions, query definition dialog, conditions, and order fields
        are defined. The following is a sample dynamic query definition:
        <programlisting role="xml">&lt;project&gt;
    ....
    &lt;query-defn name="books"&gt;
        &lt;field name="book_id" caption="Book ID" join="BookInfo" column="id"/&gt;
        &lt;field name="name" caption="Name" join="BookInfo" column="name"/&gt;
        &lt;field name="author" caption="Author" join="BookInfo" column="author"/&gt;
        &lt;field name="genre_id" caption="Genre ID" join="BookInfo" column="genre"/&gt;
        &lt;field name="genre_caption" caption="Genre" join="BookType" column="caption"/&gt;
        &lt;field name="isbn" caption="ISBN" join="BookInfo" column="isbn"/&gt;

        &lt;join name="BookInfo" table="book_info"/&gt;
        &lt;join name="BookType" table="book_type" condition="BookType.id = BookInfo.genre"/&gt;

        &lt;presentation&gt;
            &lt;select-dialog name="searchBooksDialog"  allow-debug="yes" hide-output-dests="no" 
                                                     hide-readonly-hints="yes" &gt;
                &lt;frame heading="Search for Books" /&gt;
                &lt;field type="text" name="book_id" caption="Book ID" /&gt;
                &lt;field type="text" name="name" caption="Book Name"/&gt;
                &lt;field type="text" name="author" caption="Author"/&gt;
                &lt;field type="text" name="isbn" caption="ISBN"/&gt;
                &lt;field type="select" style="list" name="genre" caption="Genre" 
                                     choices="schema-enum:Book_Type"/&gt;

                &lt;select name="test"&gt;
                    &lt;display field="book_id"/&gt;
                    &lt;display field="name"/&gt;
                    &lt;display field="author"/&gt;
                    &lt;display field="genre_caption"/&gt;
                    &lt;display field="isbn"/&gt;

                    &lt;condition field="book_id" allow-null="no" comparison="equals" value="field:book_id" 
                               connector="and"/&gt;
                    &lt;condition field="name" allow-null="no" comparison="starts-with" value="field:name" 
                               connector="and"/&gt;
                    &lt;condition field="author" allow-null="no" comparison="equals" value="field:author" 
                               connector="and"/&gt;
                    &lt;condition field="genre_id" allow-null="no" comparison="equals" value="field:genre" 
                               connector="and"/&gt;

                    &lt;presentation&gt;
                        &lt;panel name="report"&gt;
                            &lt;frame heading="static:Book Search Results"/&gt;
                            &lt;report&gt;
                                &lt;column heading="ID" format="plain" redirect="page-id:/edit?id=${0}"/&gt;
                                &lt;column heading="Name" /&gt;
                                &lt;column heading="Author"/&gt;
                                &lt;column heading="Genre"/&gt;
                                &lt;column heading="ISBN"/&gt;
                            &lt;/report&gt;
                        &lt;/panel&gt;
                    &lt;/presentation&gt;
                &lt;/select&gt;
            &lt;/select-dialog&gt;
        &lt;/presentation&gt;
    &lt;/query-defn&gt;                </programlisting></para>

        <para>The dynamic query definition show above contains various XML
        tags which are summarized below: <variablelist>
            <title>XML Tag Definitions</title>

            <varlistentry>
              <term><sgmltag class="starttag">field</sgmltag></term>

              <listitem>
                <para>Represents database column names and column expressions
                used for generating the SQL. It is available for setting the
                report columns (represented by the <sgmltag
                class="element">display</sgmltag> tag) and setting the
                condition strings (represented by the <sgmltag
                class="element">condition</sgmltag> tag). The displayed report
                column value can be formatted using the <sgmltag
                class="element">report</sgmltag> tag which can be used as a
                child node definition.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="starttag">report</sgmltag></term>

              <listitem>
                <para>Represents the result column formatting. Child node
                element for the <sgmltag class="element">field</sgmltag>. The
                following attributes are available: <itemizedlist>
                    <listitem>
                      <para><sgmltag class="attribute">type</sgmltag>:&nbsp;
                      The values available are <sgmltag
                      class="attvalue">default</sgmltag>, <sgmltag
                      class="attvalue">numeric</sgmltag>, <sgmltag
                      class="attvalue">decimal</sgmltag>, and <sgmltag
                      class="attvalue">checkbox</sgmltag>.</para>
                    </listitem>

                    <listitem>
                      <para><sgmltag class="attribute">format</sgmltag>:&nbsp;
                      The values available are <sgmltag
                      class="attvalue">plain</sgmltag>, <sgmltag
                      class="attvalue">general</sgmltag>, <sgmltag
                      class="attvalue">decimal</sgmltag>, <sgmltag
                      class="attvalue">currency</sgmltag>, <sgmltag
                      class="attvalue">percentage</sgmltag>, <sgmltag
                      class="attvalue">date</sgmltag>, <sgmltag
                      class="attvalue">datetime</sgmltag>, and <sgmltag
                      class="attvalue">time</sgmltag>.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="starttag">join</sgmltag></term>

              <listitem>
                <para>Represents database tables that are included for the
                JOIN part of the SQL statement. Each element is only included
                as a join if the corresponding <sgmltag
                class="element">field</sgmltag> element is being used or the
                attribute <sgmltag class="attribute">auto-include</sgmltag> is
                set to "yes".</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="starttag">select-dialog</sgmltag></term>

              <listitem>
                <para>Represents a query definition dialog object containing
                fields for entering values of the bind parameters. The
                following attributes are available: <itemizedlist>
                    <listitem>
                      <para><sgmltag
                      class="attribute">allow-debug</sgmltag>:&nbsp; when
                      attribute is set to <quote>yes</quote>, the dialog
                      object displays a debug check box. When this checkbox is
                      checked and the dialog is submitted, the generated SQL
                      with its bind parameters will be displayed for debugging
                      purposes instead of execution of the generated
                      SQL.</para>
                    </listitem>

                    <listitem>
                      <para><sgmltag
                      class="attribute">show-output-dests</sgmltag>: &nbsp;
                      The attribute is used to give the user several output
                      options: HTML output (pageable report and row count per
                      page), CSV output format, tab delimited format.</para>
                    </listitem>

                    <listitem>
                      <para><sgmltag class="attribute">heading</sgmltag>:
                      &nbsp; The title of the query definition dialog.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="starttag">select</sgmltag></term>

              <listitem>
                <para>Represents the SQL query which is being generated. It is
                a parent node for the report columns (<sgmltag
                class="starttag">display</sgmltag>), order-by selections
                (<sgmltag class="starttag">order-by</sgmltag>), and condition
                statements (<sgmltag class="starttag">condition</sgmltag>).
                The following attributes are available: <itemizedlist>
                    <listitem>
                      <para><sgmltag
                      class="attribute">heading</sgmltag>:&nbsp; The heading
                      of the resulting query</para>
                    </listitem>

                    <listitem>
                      <para><sgmltag class="attribute">distinct</sgmltag>:
                      &nbsp; Indicates whether or not the SELECT statement is
                      distinct (values are <sgmltag
                      class="attvalue">yes</sgmltag> and <sgmltag
                      class="attvalue">no</sgmltag>). <important>
                          <para>Setting this attribute will insert a
                          <emphasis>distinct</emphasis> string into the SQL
                          and it will effect all columns!</para>
                        </important></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="starttag">display</sgmltag></term>

              <listitem>
                <para>Represents the SQL columns that are retrieved from the
                database. The following attribute is available: <itemizedlist>
                    <listitem>
                      <para><sgmltag class="attribute">field</sgmltag>:&nbsp;
                      The value for this attribute must correspond to one of
                      the fields defined by the <sgmltag
                      class="starttag">field</sgmltag>. For example,
                      <programlisting role="xml">&lt;query-defn&gt;
    &lt;field id="org_id" caption="Account ID" join="org" column="org_id"/&gt;
    ...
        &lt;select-dialog ..&gt;
            ...
            ...
            &lt;select&gt;
                &lt;display field="org_id"/&gt;
                ...
            &lt;/select&gt;
        &lt;/select-dialog&gt;                                   </programlisting></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="starttag">order-by</sgmltag></term>

              <listitem>
                <para>Represents the sort criteria. The following attributes
                are available: <itemizedlist>
                    <listitem>
                      <para><sgmltag class="attribute">field</sgmltag>:&nbsp;
                      The value for this attribute must correspond to one of
                      the fields defined by the <sgmltag
                      class="starttag">field</sgmltag>. For example,
                      <programlisting role="xml">&lt;query-defn&gt;
    &lt;field id="org_id" caption="Account ID" join="org" column="org_id"/&gt;
    ...
      &lt;select-dialog ..&gt;
          ...
          ...
          &lt;select&gt;
              &lt;order-by field="org_id"/&gt;
              ...
          &lt;/select&gt;
      &lt;/select-dialog&gt;                                    </programlisting></para>
                    </listitem>

                    <listitem>
                      <para><sgmltag
                      class="attribute">descending</sgmltag>:&nbsp; Indicates
                      whether or not the sort order should be descending or
                      ascending.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="starttag">condition</sgmltag></term>

              <listitem>
                <para>Represents the selection criteria. The following
                attributes are available:</para>

                <itemizedlist>
                  <listitem>
                    <para><sgmltag class="attribute">field</sgmltag>:&nbsp;
                    The value for this attribute must correspond to one of the
                    fields defined by the <sgmltag
                    class="starttag">field</sgmltag>.</para>
                  </listitem>

                  <listitem>
                    <para><sgmltag
                    class="attribute">allow-null</sgmltag>:&nbsp; Whether or
                    not to allow a NULL value as a valid bind parameter
                    value.</para>
                  </listitem>

                  <listitem>
                    <para><sgmltag
                    class="attribute">comparison</sgmltag>:&nbsp; Describes
                    what kind of relational operator to use. The following
                    values are available: <sgmltag
                    class="attvalue">starts-with</sgmltag>, <sgmltag
                    class="attvalue">in</sgmltag>, <sgmltag
                    class="attvalue">greater-than-equal</sgmltag>,<sgmltag
                    class="attvalue">greater-than</sgmltag>, <sgmltag
                    class="attvalue">less-than-equal</sgmltag>, <sgmltag
                    class="attvalue">less-than</sgmltag>, <sgmltag
                    class="attvalue">equals</sgmltag>, <sgmltag
                    class="attvalue">contains</sgmltag>, <sgmltag
                    class="attvalue">is-defined</sgmltag>, <sgmltag
                    class="attvalue">starts-with</sgmltag>, <sgmltag
                    class="attvalue">ends-with</sgmltag>, and <sgmltag
                    class="attvalue">not-equals</sgmltag>.</para>
                  </listitem>
                </itemizedlist>

                <para>For example,</para>

                <programlisting role="xml">&lt;query-defn&gt;
    &lt;field id="org_id" caption="Account ID" join="org" column="org_id"/&gt;
    ...
        &lt;select-dialog ..&gt;
            ...
            &lt;select&gt;
                &lt;condition field="org_id" allow-null="no" comparison="starts-with"
                           bind-expr="upper(?)" value="form:customer_id" connector="and"/&gt;
            ...
            &lt;/select&gt;
        &lt;/select-dialog&gt;</programlisting>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="starttag">director</sgmltag></term>

              <listitem>
                <para>Represents the dialog director object which can be used
                to change the text of the action buttons and their respective
                URLs. The following attributes are available: <itemizedlist>
                    <listitem>
                      <para><sgmltag
                      class="attribute">cancel-url</sgmltag>:&nbsp; Defines
                      what the URL is for the Cancel button.</para>
                    </listitem>

                    <listitem>
                      <para><sgmltag
                      class="attribute">cancel-caption</sgmltag>:&nbsp;
                      Defines what the Cancel button should be called.</para>
                    </listitem>

                    <listitem>
                      <para><sgmltag
                      class="attribute">submit-caption</sgmltag>:&nbsp;
                      Defines what Submit button should be called.</para>
                    </listitem>
                  </itemizedlist><programlisting role="xml">&lt;query-defn&gt;
    &lt;field id="org_id" caption="Account ID" join="org" column="org_id"/&gt;
    ...
        &lt;select-dialog ..&gt;
            ...
            &lt;director submit-caption="Submit" cancel-caption="Cancel" cancel-url="/go"/&gt;</programlisting></para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </section>

      <section id="Testing-Dynamic-Query">
        <title>Testing the dynamic query</title>

        <section>
          <title>Unit Testing</title>

          <para>All available dynamic query definitions can be viewed in
          Console under the <menuchoice role="bold">
              <guimenu>Database</guimenu>

              <guimenuitem>SQL Query Definitions</guimenuitem>
            </menuchoice> menu item:</para>

          <para><screenshot>
              <graphic fileref="./resources/images/statements/ace-querydefs.jpg" />
            </screenshot></para>

          <para>By clicking on the name of the query definition, all the
          entries of the query definition can be viewed:</para>

          <para><screenshot>
              <graphic fileref="./resources/images/statements/ace-querydefs2.jpg" />
            </screenshot></para>

          <para>Clicking on the Action icon in the Select Table shown above
          displays the query definition dialog represented by the <sgmltag
          class="element">select-dialog</sgmltag> tag.</para>

          <para><screenshot>
              <graphic fileref="./resources/images/statements/ace-querydefs3.jpg" />
            </screenshot></para>

          <para>The debug checkbox is very useful to debug the dynamic query
          which is being generated according to the user's
          configuration.</para>
        </section>

        <section>
          <title>Integration Testing</title>

          <para>The query definition dialog can be used in a JSP using the
          custom tag <emphasis
          role="bold">&lt;xaf:query-select-dialog&gt;</emphasis>. For example,
          the following entry displays a query definition dialog inside a JSP:
          <programlisting role="xml">TODO: documentation coming soon...   </programlisting></para>
        </section>
      </section>

      <section id="Using-Dynamic-Query">
        <title>Using the dynamic query</title>

        <para>A dynamic query statement is generated from the query definition
        dialog and the resulting report can be configured in different ways.
        <programlisting role="xml">TODO: documentation coming soon...  </programlisting></para>
      </section>
    </section>

    <section>
      <title>Schemas</title>

      <para>The Schemas package allows almost all standard database schema
      objects like tables, columns, and data types (data dictionaries) to be
      managed in a database-independent XML format. The same XML declarations
      can be used to generate database-specific SQL DDL allowing a single XML
      source schema to work in a variety of SQL relational databases (like
      Oracle, SQL Server, MySQL, etc.). Experienced DBAs are not required to
      create consistent, high-quality SQL DDL during the design and
      construction phases of an application. Database-dependent objects like
      triggers and stored procedures are not managed by Sparx and are created
      using existing means. Because almost all schema resources are defined in
      XML, Sparx allows for re-use of Schemas across applications and
      different database vendors and produces and maintains Schema
      documentation. Sparx encourages the creation and re-use of a set of
      data-types and table-types (the data dictionary) that define standard
      behaviors for columns and tables. Data-types and table-types comprise
      the database dictionary and can easily be inherited and extended. Sparx
      also generates database-independent Java Object-relational classes. This
      is a called the Application DAL (Data Access Layer). Sparx can
      automatically generate a Java Object-relational DAL for an entire
      schema, automating the majority of SQL calls by providing strongly-typed
      Java wrappers for all tables and columns.</para>

      <figure>
        <title>Axiom Schema Artifacts</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="./resources/images/data-mgmt-schema-conversions-overview.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Benefits of Managing the Relational Database Schemas in
        Axiom</title>

        <itemizedlist>
          <listitem>
            <para>Database Programmers spend time on essential tables and
            schema elements significant to a specific application instead of
            rewriting common schema elements for each application.</para>
          </listitem>

          <listitem>
            <para>Allows for re-use of Schemas across applications and
            produces and maintains Schema documentation. XIF encourages the
            creation and re-use of a set of datatypes and tabletypes that
            define standard behaviors for columns and tables. Data types and
            table types comprise the Axiom database dictionary and can easily
            be inherited and extended.</para>
          </listitem>

          <listitem>
            <para>Almost all schema objects like tables, columns, data types,
            etc. are managed in a database-independent XML tags. The entire
            schema is managed in XML as a part of your project file and SQL is
            generated through XSLT style sheets (the templates). The same XML
            tags can be used to generate database-specific SQL DDL allowing a
            single XML source schema to work in a variety of SQL relational
            databases (like Oracle, SQL Server, MySQL, etc.).</para>
          </listitem>

          <listitem>
            <para>Database-specific SQL DDL is created by applying Database
            Policies to the <sgmltag class="starttag">schema</sgmltag> tags.
            Experienced DBAs are not required to create consistent,
            high-quality SQL DDL during the design and construction phases of
            an application. Database-dependent objects like triggers and
            stored procedures are not managed by the XIF and are created using
            existing means.</para>
          </listitem>

          <listitem>
            <para>Database-independent Java Object-relational classes are
            created by using a Java source code generator. This is called the
            Application DAL (Data Access Layer). Axiom can automatically
            generate a Java Object-relational DAL (Data Access Layer) for an
            entire schema, automating the majority of SQL calls by providing
            strongly-typed Java wrappers for all tables and columns.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Creating Datatypes</title>

        <para>Datatypes should be considered <quote>column templates</quote>
        that allow a programmer to specify a column type. Datatypes may be
        inherited from other datatypes, allowing better reuse and
        object-orientation in relational databases. They can be easily
        generated and maintains a database-independent data dictionary. The
        data types are be defined within <sgmltag>the</sgmltag> <sgmltag
        class="starttag">schema</sgmltag> XML tag. The following is an example
        of several common data types defined for a relational database (these
        are complex examples because they are samples of built-in data-types,
        yours may be much simpler): <programlisting role="xml">&lt;project&gt;
    ....
    &lt;schema name="mySchema"&gt;
        &lt;data-type name="text" class="com.netspective.axiom.schema.column.type.TextColumn"&gt;
            &lt;size&gt;32&lt;/size&gt;
            &lt;sql-ddl&gt;
                &lt;define dbms="ansi" xdm:replace-template-expressions="no"&gt;
                     varchar(${column.getSize()})
                &lt;/define&gt;
            &lt;/sql-ddl&gt;
        &lt;/data-type&gt;

        &lt;data-type name="float" class="com.netspective.axiom.schema.column.type.FloatColumn"&gt;
            &lt;sql-ddl&gt;
                &lt;define dbms="ansi" xdm:replace-template-expressions="no"&gt;
                     float
                 &lt;/define&gt;
                &lt;define dbms="oracle" xdm:replace-template-expressions="no"&gt;
                     number(20,6)
                &lt;/define&gt;
            &lt;/sql-ddl&gt;
        &lt;/data-type&gt;           </programlisting>Datatypes provide their
        SQL DDL using the <sgmltag class="starttag">define</sgmltag> tag under
        <sgmltag class="starttag">sql-ddl</sgmltag> tag. Datatypes are usually
        simple types like <quote>text</quote>, <quote>integer</quote>, or
        <quote>float</quote>. More complex types like <quote>duration</quote>
        can be created by using the <sgmltag
        class="element">composite</sgmltag> tag allowing a single datatype to
        automatically generate multiple columns in tables.</para>

        <note>
          <para>There are many built-in data types that serve as building
          blocks and examples for how you can create your own data types. The
          built-in data types can also be used as-is for the majority of
          cases. To include the built-in data types into your schema you can
          use the following <sgmltag class="starttag">xdm:include</sgmltag>
          instruction. Once you have created a schema tag and provided the
          xdm:include instruction, you may view all of the default data types
          in Console's <menuchoice>
              <guimenu>XDM Tag Referecne</guimenu>

              <guimenu>Template Catalog</guimenu>
            </menuchoice> page.</para>

          <programlisting>&lt;project&gt;
    ....
    &lt;schema name="db"&gt;
        <emphasis role="bold">&lt;xdm:include resource="com/netspective/axiom/conf/schema.xml"/&gt;</emphasis>

        ... the rest of your schema declarations go here ...</programlisting>
        </note>
      </section>

      <section>
        <title>Creating Table Types</title>

        <para>Table types should be considered <quote>table templates</quote>
        that allow a programmer to specify a table type. Table types may be
        inherited from other table types, allowing better reuse and
        object-orientation in relational databases. <programlisting
        role="xml">&lt;project&gt;
    ....
    &lt;schema name="mySchema"&gt;
        ....
        &lt;table-type name="Entity"&gt;
            &lt;column name="${owner.name.toLowerCase()}_id" type="auto-inc" 
                    primary-key="yes" descr="Unique identifier for ${owner.name}"/&gt;
        &lt;/table-type&gt;

        &lt;table-type name="Person" type="Entity"&gt;
            &lt;column name="first_name" type="text" size="64" descr="The person's first name"/&gt;
            &lt;column name="last_name" type="text" size="64" descr="The person's last name"/&gt;
        &lt;/table-type&gt;</programlisting>The <sgmltag
        class="starttag">column</sgmltag> element in the <sgmltag
        class="starttag">table-type</sgmltag> elements creates actual columns
        derived from a particular <sgmltag
        class="starttag">data-type</sgmltag>. The <sgmltag
        class="starttag">column</sgmltag> elements will automatically maintain
        all type definitions and links to foreign keys automatically. The
        columns are arguably the most important definitions in the entire
        <sgmltag class="starttag">schema</sgmltag> tag hierarchy. They take
        abstract representations of data types and instantiate actual columns
        in tables. The following are attributes for the <sgmltag
        class="starttag">column</sgmltag> element: <variablelist>
            <varlistentry>
              <term><sgmltag class="attribute">name</sgmltag></term>

              <listitem>
                <para>The name of the column. Each column is usually named as
                a singular noun in all lower case with each word inside a name
                separated by underscores. For instance, person_id is a good
                column name but personid is harder to read. If you use the
                appropriate naming convention, the Data Access Layer generator
                will produce better output.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">type</sgmltag></term>

              <listitem>
                <para>The name of data-type to inherit. All of the attributes
                and elements from the other data-type will be inherited and
                any attributes and elements defined in this data-type will
                override those values. You can get an idea of all the types
                available for use with this attribute by looking at the
                datatypes.xml file.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">size</sgmltag></term>

              <listitem>
                <para>The size attribute of the specified data type. What the
                size means depends on the data type. For example, in text
                fields, it specifies the number of characters used.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>primary-key</term>

              <listitem>
                <para>Specifies whether or not this column is a primary
                key.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">lookup-ref</sgmltag></term>

              <listitem>
                <para>Format is Table_X.Column_Y. Specifies a general foreign
                key relationship from the defining column which references the
                foreign Column_Y of Table_X (creates a 1:1 or 1:N relationship
                between defining column and the referenced column). If you use
                this attribute, the type attribute is not required (it’s set
                to the same type as the referenced column).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">parent-ref</sgmltag></term>

              <listitem>
                <para>Format is Table_X.Column_Y. Specifies a parent/child
                foreign key relationship which indicates that Table_X is a
                parent of the defining column using Column_Y’s value (creates
                a 1:N relationship between Table_X and the column defining the
                parentref). If you use this attribute, the type attribute is
                not required (it’s set to the same type as the referenced
                column).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">self-ref</sgmltag></term>

              <listitem>
                <para>Format is "Table_X.Column_Y". Specifies a
                self-referential foreign key relationship which indicates that
                Table_X Column_Y is used to maintain an internal hierarchy
                (creates a 1:N relationship between itself). If you use this
                attribute, the type attribute is not required (it’s set to the
                same type as the referenced column).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">descr</sgmltag></term>

              <listitem>
                <para>Description</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">required</sgmltag></term>

              <listitem>
                <para>Specifies whether or not this column is a required
                column. If the column is required, XIF generates a not null
                constraint.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">default</sgmltag></term>

              <listitem>
                <para>Specifies the SQL expression that will be used as the
                column's default value in the SQL create table
                statement</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">unique</sgmltag></term>

              <listitem>
                <para>Specifies whether this column's values should be unique
                (meaning no two rows should share the same value for this
                column). When this value is set to yes, this attribute creates
                a unique index based on this single column. If more than one
                column needs to be unique (as a composite), use the
                &lt;index&gt; child element of the table element to create a
                unique index based on multiple columns.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>indexed</term>

              <listitem>
                <para>Specifies whether this column's values should be indexed
                (for increasing search performance). When this value is set to
                yes, this attribute creates a search index based on this
                single column. If more than one column needs to be unique (as
                a composite), use the &lt;index&gt; child element of the table
                element to create an index based on multiple columns.</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </section>

      <section>
        <title>Creating Tables</title>

        <para>A table type is a set of one or more column definitions. So when
        you create a table based on a table type, that table will include all
        the columns of the table type as well as its own. Each <sgmltag
        class="element">table</sgmltag> can be based on one or more table
        types as shown in the following example: <programlisting role="xml">&lt;project&gt;
    ....
    &lt;schema name="db"&gt;
        &lt;xdm:include resource="com/netspective/axiom/conf/schema.xml"/&gt;

        &lt;table-type name="Entity"&gt;
            &lt;column name="${owner.name.toLowerCase()}_id" type="auto-inc" 
                    primary-key="yes" descr="Unique identifier for ${owner.name}"/&gt;
        &lt;/table-type&gt;

        &lt;table-type name="Person" type="Entity"&gt;
            &lt;column name="first_name" type="text" size="64" descr="The person's first name"/&gt;
            &lt;column name="last_name" type="text" size="64" descr="The person's last name"/&gt;
        &lt;/table-type&gt;

        <emphasis role="bold">&lt;table name="Asset" abbrev="asset" type="Entity,Presentation"&gt;</emphasis>
            &lt;column name="type" lookup-ref="Asset_Type" required="yes"/&gt;
            &lt;column name="name" type="text" size="64" required="yes"/&gt;
            &lt;column name="quantity" type="integer" required="yes"/&gt;
        &lt;/table&gt;

        <emphasis role="bold">&lt;table name="Borrower" type="Person,Presentation"&gt;</emphasis>
            &lt;!-- no columns are being added, it's just first name and last name --&gt;
        &lt;/table&gt;

        &lt;table name="Asset_Loan" abbrev="asloan" type="Entity,Presentation"&gt;
            &lt;column name="asset_id" parent-ref="Asset.asset_id"/&gt;
            &lt;column name="borrower_id" lookup-ref="Borrower.borrower_id"/&gt;
            &lt;column name="loan_type" lookup-ref="Loan_Type"/&gt;
            &lt;column name="loan" type="duration" required="yes"/&gt;
            &lt;column name="returned" type="boolean"/&gt;
        &lt;/table&gt;
</programlisting> Using table types, one can quickly and consistently create
        similar tables that are automatically updated whenever the tabletypes
        change. The following attributes are allowed for the <sgmltag
        class="element">table</sgmltag> element: <variablelist>
            <varlistentry>
              <term><sgmltag class="attribute">name</sgmltag></term>

              <listitem>
                <para>the name of the table</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">abbrev</sgmltag></term>

              <listitem>
                <para>should be kept to 3 or 4 characters to allow constraint
                names and index names to be created properly</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><sgmltag class="attribute">type</sgmltag></term>

              <listitem>
                <para>the table-type of the table</para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </section>

      <section>
        <title>Creating Relationships</title>

        <para>TODO: documentation coming soon...</para>
      </section>

      <section>
        <title>Managing Enumerations and Lookup Tables</title>

        <para>An enumeration is a special type of table that is generated by
        Sparx. It consists of three fields per record: a unique id which is
        used to relate the enumeration table in a 1:n manner with other
        tables, a non-null caption that is used to provide a short description
        of each value in the enumeration and an optional abbrev(iation) for
        the caption. An enumeration table is always of a fixed length since
        each record that goes into the table must be defined in the XML by
        hand. The syntax of an enumeration table is unlike that of regular
        tables. However, once parsed and interpreted, enumeration tables are
        translated into a set of regular tables for relational integrity
        purposes.</para>

        <para>Using enumeration tables can significantly improve performance
        for static and lookup tables and still allow normal relational logic
        (foreign keys). All lookups in Sparx dialogs using the schema-enum
        value source directly read and cache enumeration XML files instead of
        asking the database for the contents of the database. Since the DDL
        generated by XIF for enumeration tables is normal SQL (using standard
        create table commands), relational logic is maintained but performance
        is significantly improved.</para>

        <para>An enumeration table is used to establish a 1:n relationship
        between an attribute of an object (e.g. the genre of the book in this
        case) and the object itself (in this case, the book). It does this by
        letting the id field of the attribute enumeration table be inserted as
        a foreign key in the table containing records for the object. In this
        particular scenario, the lookupref attribute of the type field in the
        Book_Info table makes that happen.</para>
      </section>

      <section>
        <title>Generating SQL DDL File</title>

        <para>Using Console, database-independent XML tags become a
        database-dependent SQL DDL file. Regenerating SQL DDL is the preferred
        method to modifying DDL during the design and construction phases
        (pre-production) of a web application. In post-production usage, the
        entire SQL is regenerated for changed tables and relationships but a
        experienced DBA should be involved for the alteration of live
        schemas.</para>
      </section>
    </section>
  </chapter>
</book>