<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
<!ENTITY include_nef_faq_non_tech SYSTEM "../nef-faq-non-tech-section.xml">
]>
<book>
  <title>Netspective Enterprise Frameworks 7.0 (NEF) User&#39;s Manual</title>

  <bookinfo>
    <title>Netspective Enterprise Frameworks (NEF) 7.0 User&#39;s Manual</title>

    <releaseinfo>Release 7.0.0 ($Date: 2003-10-30 01:38:02 $)</releaseinfo>

    <releaseinfo>This version is in DRAFT until November 15, 2003 when
    it&#39;s expected to be completed. Check back daily until then because
    material is being added regularly.</releaseinfo>

    <authorgroup>
      <author>
        <firstname>Shahid</firstname>

        <othername role="mi">N.</othername>

        <surname>Shah</surname>
      </author>
    </authorgroup>

    <copyright>
      <year>2000</year>

      <year>2001</year>

      <year>2002</year>

      <year>2003</year>

      <year>2004</year>

      <holder>Netspective Communications LLC</holder>
    </copyright>

    <legalnotice>
      <para>Netspective, Enterprise Console, Sparx, Axiom, Commons, Medigy,
      Junxion and their respective logos are trademarks of Netspective
      Communications LLC, and may be registered in some jurisdictions.</para>
    </legalnotice>

    <legalnotice>
      <para>Netspective and its suppliers assume no responsibility for any
      damage or loss resulting from the use of this developer’s guide.
      Netspective and its suppliers assume no responsibility for any loss or
      claims by third parties that may arise through the use of this software
      or documentation.</para>
    </legalnotice>

    <legalnotice>
      <para>For warranty information and a copy of the End User License
      Agreement, please see the Netspective web site at <ulink
      url="http://www.netspective.com">http://www.netspective.com</ulink>. If
      you would like a copy of these materials mailed to you, or if you have
      any questions, please contact Netspective. The information included on
      this web site sets forth Netspective’s sole and complete warranty and
      software licensing obligations with respect to your Netspective product.
      Use of the product indicates your acceptance of the terms of the
      warranty and the End User License Agreement.</para>
    </legalnotice>
  </bookinfo>

  <chapter>
    <title>Introduction</title>

    <para>The Netspective Enterprise Frameworks Suite (<acronym>NEFS</acronym>)
    is a comprehensive application frameworks suite which helps build secure
    data-driven web applications. Design and prototyping, implementation, unit
    tests, implementation documentation, and production logs and metrics are
    just some of the development deliverables and phases that the NEF helps
    accelerate and standardize.</para>

    <section>
      <title id="nef-features">Features</title>

      <para>The <acronym>NEF</acronym> has hundreds of features that support
      the development of sophisticated applications with exceptional ease.
      Some of the important ones include:</para>

      <section>
        <title>General Features</title>

        <itemizedlist>
          <listitem>
            <para>Instantly create sophisticated mission- and safety-critical
            web-based applications that run on <emphasis>any application
            server.</emphasis></para>
          </listitem>

          <listitem>
            <para>Declare components for the presentation and data management
            layers in XML and have NEF assemble up to 80% of your application
            for you with little or no Java code. All the Java code you write
            will be related to application functionality, not user interface
            (HTML) generation or database access.</para>
          </listitem>

          <listitem>
            <para>Write all your business logic using EJBs, rules processing
            systems, or plain Java objects and connect them to NEF components
            like dialogs, fields, and schemas easily.</para>
          </listitem>

          <listitem>
            <para>Use the automatically-generated web services that change as
            the rest of your application changes. As you add features, tables,
            forms, and functionality the web services will remain in sync.</para>
          </listitem>

          <listitem>
            <para>Declare your user interface forms, fields, validation rules,
            conditional logic, and security policies using simple XML tags and
            get fully functional theme- and skin-based HTML output
            automatically.</para>
          </listitem>

          <listitem>
            <para>Declare your database structures and relationships using
            simple XML tags and get fully functional SQL DDL, SQL DML, HTML
            documentation and XML import/export capabilities automatically.</para>
          </listitem>

          <listitem>
            <para>Declare your database SQL and parameters using simple XML
            tags and get fully functional reports and synchronized and
            validated input capabilities automatically.</para>
          </listitem>

          <listitem>
            <para>Automatically produce programmer artifacts like HTML
            documentation, unit tests, functional specifications, and
            requirements traceability maps just by using XML tags and the NEF
            API.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Feature List</title>

        <section>
          <title>Global</title>

          <itemizedlist>
            <listitem>
              <para>Works with any IDE, editor, studio apps</para>
            </listitem>

            <listitem>
              <para>Works with but does not require EJBs</para>
            </listitem>

            <listitem>
              <para>Native J2EE API always available</para>
            </listitem>

            <listitem>
              <para>Uses normal Java inheritance and delegation for
              extensiblity</para>
            </listitem>

            <listitem>
              <para>Low learning curve</para>
            </listitem>

            <listitem>
              <para>Works well with other frameworks</para>
            </listitem>

            <listitem>
              <para>Source code available</para>
            </listitem>

            <listitem>
              <para>Ability to version-control components and apps</para>
            </listitem>

            <listitem>
              <para>Operating system independence</para>
            </listitem>

            <listitem>
              <para>App-server independence</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Architecture</title>

          <itemizedlist>
            <listitem>
              <para>J2EE Design/Architecture Patterns</para>
            </listitem>

            <listitem>
              <para>Application Integration Patterns</para>
            </listitem>

            <listitem>
              <para>Application Functionality Patterns</para>
            </listitem>

            <listitem>
              <para>Web-services</para>
            </listitem>

            <listitem>
              <para>Externalization of Resources</para>
            </listitem>

            <listitem>
              <para>Executable Specifications</para>
            </listitem>

            <listitem>
              <para>Logging and Performance Stats</para>
            </listitem>

            <listitem>
              <para>Business Values and Rules Repository</para>
            </listitem>

            <listitem>
              <para>Centralized Configuration Parameters</para>
            </listitem>

            <listitem>
              <para>Allows production, testing, development modes</para>
            </listitem>

            <listitem>
              <para>Code Generation</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Process &#38; Methodology</title>

          <itemizedlist>
            <listitem>
              <para>Administration Console</para>
            </listitem>

            <listitem>
              <para>Unit Testing of Common Components</para>
            </listitem>

            <listitem>
              <para>Unit Testing of Custom Components</para>
            </listitem>

            <listitem>
              <para>Integration Testing</para>
            </listitem>

            <listitem>
              <para>System Testing</para>
            </listitem>

            <listitem>
              <para>Functional Specifications</para>
            </listitem>

            <listitem>
              <para>Metrics (Function Points, SLOC)</para>
            </listitem>

            <listitem>
              <para>Implementation documentation</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Presentation Layer</title>

          <itemizedlist>
            <listitem>
              <para>Forms and Controls</para>
            </listitem>

            <listitem>
              <para>Client-side Validation</para>
            </listitem>

            <listitem>
              <para>Server-side Validation</para>
            </listitem>

            <listitem>
              <para>Template Language</para>
            </listitem>

            <listitem>
              <para>Automatic Form Reload on Error</para>
            </listitem>

            <listitem>
              <para>Dialog Data State Machine</para>
            </listitem>

            <listitem>
              <para>Complete HTML generation</para>
            </listitem>

            <listitem>
              <para>Data Binding to Presentation Layer</para>
            </listitem>

            <listitem>
              <para>Reports</para>
            </listitem>

            <listitem>
              <para>Navigation and Workflow</para>
            </listitem>

            <listitem>
              <para>Wireless, PDA, Browser Support</para>
            </listitem>

            <listitem>
              <para>Multiple skins support (with no code changes)</para>
            </listitem>

            <listitem>
              <para>Presentation Object Performance Statistics</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Data Management Layer</title>

          <itemizedlist>
            <listitem>
              <para>Schema Management</para>
            </listitem>

            <listitem>
              <para>Lightweight Data Access Objects</para>
            </listitem>

            <listitem>
              <para>Object-relational mapping and persistence</para>
            </listitem>

            <listitem>
              <para>Connection Pooling</para>
            </listitem>

            <listitem>
              <para>SQL DML Generation</para>
            </listitem>

            <listitem>
              <para>SQL DDL Generation</para>
            </listitem>

            <listitem>
              <para>Static SQL Queries Library</para>
            </listitem>

            <listitem>
              <para>Dynamic SQL Queries Library</para>
            </listitem>

            <listitem>
              <para>HTML Design Documentation</para>
            </listitem>

            <listitem>
              <para>Dynamic Data sources</para>
            </listitem>

            <listitem>
              <para>SQL performance statistics</para>
            </listitem>

            <listitem>
              <para>Transaction Management and Isolation</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Security and Personalization Layer</title>

          <itemizedlist>
            <listitem>
              <para>User Login Form</para>
            </listitem>

            <listitem>
              <para>User Management Objects</para>
            </listitem>

            <listitem>
              <para>Access Control Lists</para>
            </listitem>

            <listitem>
              <para>Permissions Management</para>
            </listitem>

            <listitem>
              <para>Roles Management</para>
            </listitem>

            <listitem>
              <para>Forms/Controls Conditional Security</para>
            </listitem>

            <listitem>
              <para>Reports Conditional Security</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
    </section>

    <section>
      <title>Benefits</title>

      <para>The NEF features provide the following benefits to technical
      managers and engineers of all levels:</para>

      <itemizedlist>
        <listitem>
          <para>Application developers spend time on real features significant
          to end-users instead of infrastructure issues.</para>
        </listitem>

        <listitem>
          <para>Technical managers can better manage their application
          development projects by utilizing the built-in project management,
          application documentation, unit-testing, and artifact-generation
          tools.</para>
        </listitem>

        <listitem>
          <para>Most of the user interface and database logic is coded in a
          declarative style using XML instead of a programmatic style using
          Java. This significantly reduces the amount of code (as much as
          50-75% of code can be eliminated), increases re-use, maintains
          consistency across multiple projects, and improves code quality.</para>
        </listitem>

        <listitem>
          <para>Analysts can use the declarative user interface features to
          create prototypes that can later be completed by programmers (no
          more throw-away prototypes).</para>
        </listitem>

        <listitem>
          <para>Applications are built by assembling declared user interface
          (forms/dialogs) and database (SQL) components combined with
          application-specific business logic using single or multiple
          distributed application tiers.</para>
        </listitem>

        <listitem>
          <para>NEF is not a templating system that simply generates HTML but
          a feature-rich framework that significantly reduces the time to
          produce high-quality data-intensive thin-client applications. It
          favors no specific templating system but comes bundle with support
          for both JSP and <ulink url="http://www.freemarker.org">FreeMarker</ulink>.</para>
        </listitem>

        <listitem>
          <para>NEF does not favor Servlets over JSPs or JSPs over Servlets
          and can work in one, the other, or both environments simultaneously
          with no loss of functionality in either environment.</para>
        </listitem>

        <listitem>
          <para>Implementation can be done using XML, Java, or both.</para>
        </listitem>

        <listitem>
          <para>Implements common design patterns like MVC and factories.
          Skins infrastructure allow identical business logic to be used
          across different user interfaces for a variety of browsers and
          platforms like hand-helds.</para>
        </listitem>

        <listitem>
          <para>NEF enhances and works equally well with all project
          development methodologies including waterfall, RAD, OOAD, and the
          agility of methodologies like Extreme Programming (XP).</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Alternative Frameworks</title>

      <para>Why use the Netspective Frameworks Suite instead of creating your
      own, using commercial embedded, commercial standalone, or other
      open-source frameworks. Because NEF is a comprehensive and easy to use
      J2EE architectural framework solution (whereas other products are only
      partial solutions).</para>

      <section>
        <title>Why not create your own custom framework?</title>

        <para>Due to the lack of robust commercial offerings, today most
        enterprises choose to build their own frameworks and platforms. Your
        In-house and home-grown solutions tend to have a great deal of
        momentum behind them because they may be favored internally by the
        experienced and senior engineers that construct them. However,
        home-grown solutions exhibit the following shortcomings:</para>

        <itemizedlist>
          <listitem>
            <para>They often have limited features (to compare, see <xref
            linkend="nef-features" />)</para>
          </listitem>

          <listitem>
            <para>They are usually poorly documented.</para>
          </listitem>

          <listitem>
            <para>They are notoriously difficult to extend because they are
            usually designed for special-purpose jobs.</para>
          </listitem>

          <listitem>
            <para>They are usually expensive to create and maintain and
            require engineering attention which is taken away from business
            requirements. Programmers often end up spending time on
            infrastructure issues instead of issues that directly affect
            end-users.</para>
          </listitem>
        </itemizedlist>

        <para>With its unique architecture, NEF can supplement in-house
        frameworks or replace them completely. We will be able to work
        alongside home-grown solutions and be extensible enough to allow
        enterprises to make a slow switch over to NEF.</para>

        <para>Even if all of your engineers are very experienced and your
        architecture is very sound, part of every J2EE application development
        process is spent in prototyping, technical writing, testing, and
        maintenance. Even if the code is completed on time, these other tasks
        take up to another 30 to 40% of the total project resources. NEF can
        take an experienced J2EE programmer and improve their productivity and
        in many cases eliminate the need for specialized resources for
        architecture and design, prototyping, documentation, logging,
        deployment, and maintenance.</para>
      </section>

      <section>
        <title>I have an application server, isn’t that sufficient for me to
        write my J2EE applications?</title>

        <para>Most J2EE application servers contain a great deal of common
        infrastructure code that helps <emphasis>contain</emphasis>,
        <emphasis>manage</emphasis>, <emphasis>deploy</emphasis>, and
        <emphasis>execute</emphasis> applications. They also have features the
        increase scalability, reliability, and availability of applications by
        providing features like clustering and failover. What they lack,
        because it’s not part of their product requirements, is the ability to
        help build the applications they contain. Just as an operating system
        is a container for executing applications written in any language but
        does not assist in the development of the applications, a J2EE
        application server is a container for executing Java and J2EE
        applications but does not assist in the development of the Java/J2EE
        applications. Sparx, as a J2EE framework, helps create the
        applications that you can then deploy onto any J2EE container or
        application server.</para>
      </section>

      <section>
        <title>Why not use the frameworks that come with my application
        server?</title>

        <para>Many commercial embedded frameworks are provided by application
        server vendors like WebLogic or WebSphere. The main issues you&#39;ll
        face with these frameworks are:</para>

        <itemizedlist>
          <listitem>
            <para>They are usually vendor-specific and tie you to a particular
            application server, operating system, or database server</para>
          </listitem>

          <listitem>
            <para>The frameworks are not designed for complete coverage of
            sophisticated applications and engineers end up having to do a
            great deal of infrastructure work on their own.</para>
          </listitem>

          <listitem>
            <para>Unlike NEF&#39;s feature list (see <xref
            linkend="nef-features" />) most embedded application server
            frameworks are very light on functionality.</para>
          </listitem>
        </itemizedlist>

        <para>With its unique architecture, NEF can supplement or replace your
        application server vendor&#39;s frameworks with a good mix of easy to
        use components for faster development and the sophistication that
        senior architects need to create robust applications. Also, keep in
        mind that all NEF-based applications are application-server,
        database-server, and operating-system independent.</para>
      </section>

      <section>
        <title>Why not use open source frameworks like Struts?</title>

        <para>There are many freely-available open source frameworks are quite
        good for certain types of applications. There are a number of good
        tools in this category like Struts, Enhydra, Expresso, and others;
        however, they all share the following issues:</para>

        <itemizedlist>
          <listitem>
            <para>None of these free products match NEF from a feature or
            functionality perspective (see <xref linkend="nef-features" />).</para>
          </listitem>

          <listitem>
            <para>Most of the open source tools cater to very talented Java
            engineers since they require a serious understanding of low-level
            computer science concepts, J2EE APIs, and Java programming.</para>
          </listitem>

          <listitem>
            <para>Most open source tools are written by experienced
            programmers <emphasis>for</emphasis> experienced programmers and
            as such depend on mutual understanding instead of heavy
            documentation.</para>
          </listitem>

          <listitem>
            <para>While they save money in the beginning (since they are free)
            they end up costing much more because they often require more
            experienced engineers, usually require a higher number of
            engineers, and don&#39;t have the quality management tools
            built-in.</para>
          </listitem>
        </itemizedlist>

        <para>NEF can complement or replace most frameworks like Struts or
        Expresso.</para>
      </section>

      <section>
        <title>What are the primary advantages of NEF versus other frameworks?</title>

        <para>There are two primary competitive advantages that
        Netspective&#39;s frameworks have over other frameworks.</para>

        <orderedlist>
          <listitem>
            <para>Simplification — we are focusing on pure reduction of time
            and effort for the engineer and the use of the technology by
            less-experienced staff members. If you&#39;re not an expert in
            Java, web development, persistence, or other topics then NEF is
            the perfect suite of frameworks because all the hard stuff is
            abstracted. If you&#39;re already an expert in many of the areas
            then you&#39;ll enjoy working on end-user and application domain
            tasks instead of grunt coding in the infrastructure.</para>
          </listitem>

          <listitem>
            <para>Holistic approach to engineering — which refers to our
            concentration not on just the coding aspects but the engineering
            aspects -- testing (quality), metrics (measurement), monitoring,
            performance), and documentation.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section>
      <title>Libraries and Components</title>

      <para>The NEF suite is comprised of multiple libraries and frameworks,
      all of which are designed to work together.</para>

      <figure>
        <title>Overview of NEF Components</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="./resources/images/nefs-overview.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Commons Core Library</title>

        <para>The <emphasis>Commons</emphasis> library contains general
        purpose classes for access control, configuration management, value
        sources, data validation, and XML parsing. The Commons library may be
        used in both web-based and non-web-based applications.</para>
      </section>

      <section>
        <title>Axiom Relational Data Management Service (Data Management
        Layer)</title>

        <para>The <emphasis>Axiom</emphasis> service provides static query,
        dynamic query (query definitions), and schema management
        functionality. Axiom is a sophisticated relational database management
        framework that provides the capability to completely manage schemas,
        SQL DDL, SQL DML, XML import/export, and vendor-independent
        persistence. The Axiom framework depends upon the Commons library and
        may be used in both web-based and non-web-based applications.</para>
      </section>

      <section>
        <title>Sparx Application Platform (Presentation and Application
        Layers)</title>

        <para>The <emphasis>Sparx</emphasis> application framework helps
        manage navigation, dialogs (forms), reports, and other complex user
        interface functionality. Sparx helps create sophisticated yet easy to
        use user interfaces on all common browsers including Microsoft
        Internet Explorer, Mozilla, and Opera. The Sparx framework is built
        using Commons and Axiom and is designed exclusively for creating
        web-based thin-client applications.</para>
      </section>

      <section>
        <title>Enterprise Console</title>

        <para>The NEF and all application components built with it can be
        viewed with the <emphasis>Netspective Enterprise Console</emphasis>
        servlet. The Console is an optional component for every application
        built with NEF and it is turned on by default. You may decide to turn
        it off completely for your applications or secure it differently. Each
        application has a private instance of the Console using
        <literal>http://<replaceable>server</replaceable>/<replaceable>appName</replaceable>/console</literal>.
        When you log into the Console for Application X (<literal>appX/console</literal>)
        versus Y (<literal>appY/console</literal>) you will only see
        components for the appropriate application.</para>

        <section>
          <title>Console Login</title>

          <para>The Console&#39;s default user name is &#39;<literal>console</literal>&#39;
          and the default password is &#39;<literal>console</literal>&#39;
          (each without quotes) . Unless otherwise specified, that is the user
          name and password combination you should use if the Console prompts
          you to login.</para>
        </section>

        <section>
          <title>Accessing the Console in Applications</title>

          <para>As mentioned already, each application has a private instance
          of the Console using the <literal>http://<replaceable>server</replaceable>/<replaceable>appName</replaceable>/console</literal>
          pattern. Here are some examples of how to access the Console for
          some of the sample applications.</para>

          <variablelist>
            <varlistentry>
              <term>Hello World</term>

              <listitem>
                <para>The Hello World sample application is the most basic
                sample application and its application identifier is
                <literal>nefs-sample-hello-world</literal>. The URL for Hello
                World is
                http://sampler.netspective.com/nefs-sample-hello-world and its
                Console URL is
                http://sampler.netspective.com/nefs-sample-hello-world/console.
                Note that the Console is accessed simply by adding the
                <literal>/console</literal> path at the end of the
                application&#39;s URL.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Library</term>

              <listitem>
                <para>The Library sample application is the sample application
                that demonstrates how to create a complete database
                application and its application identifier is
                <literal>nefs-sample-library</literal>. The URL for Library is
                http://sampler.netspective.com/nefs-sample-library and its
                Console URL is
                http://sampler.netspective.com/nefs-sample-library/console.
                Note that the Console is accessed simply by adding the
                <literal>/console</literal> path at the end of the
                application&#39;s URL.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Your Application</term>

              <listitem>
                <para>When writing your own application you will simply append
                <literal>/console</literal> to the end of your own
                application&#39;s context identifier. If your app would be
                available at http://your-server/your-app-id then the Console
                for your application would be available at
                http://http://your-server/your-app-id/console.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>

      <section>
        <title>How NEF Libraries Fit In Your Application</title>

        <para>NEF components are pure Java libraries that reside
        <emphasis>inside your application</emphasis>, unlike other similar
        frameworks which are containers <emphasis>for your application</emphasis>.
        The main difference is interoperability of frameworks. Netspective
        Frameworks are designed as enterprise frameworks that can stand-alone
        or enhance other COTS or in-house frameworks. NEF consists of three
        JAR files containing the Commons, Axiom, and Sparx binaries and a set
        of HTML and XML resources like XSLT style sheets, icons and an
        extensive JavaScript library. This simple structure affords developers
        a great deal of flexibility in how they want to use any of the
        Netspective Frameworks. Therefore, you do not have to redesign or
        recode your application as you would to comply with the limitations of
        a framework container. Instead, you can start out by using a few Sparx
        features here and there and adopting more of the Sparx ease and speed
        of development as the need arises. And, because the frameworks all
        work like normal Java libraries, version control, debugging, and code
        management is not affected.</para>

        <figure>
          <title>NEF Position in J2EE Stack</title>

          <mediaobject>
            <imageobject>
              <imagedata
              fileref="./resources/images/nefs-relationship-to-app.gif" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <section>
      <title>NEF Artifacts</title>

      <para>Using simple XML declarations for the items on the left (schema,
      SQL, UI, etc.) NEF produces a variety of objects and artifacts. Many of
      the components that NEF produces are not generated but instantiated
      while others are both generated first then instanatiated. The <filename
      class="directory">WEB-INF/classes/auto</filename> directory contains all
      classes that are generated. So, if a class is found in directory other
      than <filename class="directory">WEB-INF/classes/auto</filename> (the
      auto-generation directory) then it&#39;s a custom or user class that was
      created or prepared outside of NEF. NEF loads most components using XML
      which is translated at the startup of the application into objects that
      are cached, shared, and executed. Unlike most code generators which
      create code that must be separately compiled, many of the NEF components
      automatically executed in memory with no compile/link/debug cycle.</para>

      <figure>
        <title>NEF Artifacts</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="./resources/images/nefs-outputs.gif" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>NEF Web Services</title>

      <para>The general topic of web services refers to the ability of
      applications and systems to speak to each other over Internet protocols.
      The &#34;normal&#34; case of web applications has a customer accessing a
      catalog site and making a purchase over a secure website. This
      interaction is quite common but sometimes its preferable to have a
      computer system automatically place an order with other computer
      systems. For example, suppliers could provide web services to large
      corporations so that corporations could automatically, without human
      intervention, place orders to the supplier when their inventory runs
      low. NEF supports both web applications (where a human being is
      interacting with an application or computer system) and web services
      (where a service is being created for use by other computers). NEF
      allows the web services to automatically become applications and
      applications to automatically become services with very little work on
      the part of analysts or programmers. For example, every Sparx form or
      dialog automatically provides the capability for becoming a web service.
      Additionally, any table or SQL query defined using Sparx automatically
      has the capability to run in both &#34;application&#34; and
      &#34;service&#34; modes.</para>
    </section>

    <section>
      <title>NEF System Requirements</title>

      <para>NEF contains pure Java libraries (no native code) and therefore
      should work on any platform that supports Java2. The Frameworks have
      been tested on and require one of the following platforms:</para>

      <itemizedlist>
        <listitem>
          <para>Microsoft Windows NT 4.0 Workstation/Server</para>
        </listitem>

        <listitem>
          <para>Microsoft Windows 2000 Professional/Server</para>
        </listitem>

        <listitem>
          <para>Microsoft Windows XP</para>
        </listitem>

        <listitem>
          <para>Microsoft Windows Server 2003</para>
        </listitem>

        <listitem>
          <para>Apple OS X</para>
        </listitem>

        <listitem>
          <para>SUN Solaris 7</para>
        </listitem>

        <listitem>
          <para>Red Hat Linux</para>
        </listitem>

        <listitem>
          <para>Slackware Linux</para>
        </listitem>
      </itemizedlist>

      <para>NEF has been tested on and requires one of the following Java
      Development Kits (JDKs):</para>

      <itemizedlist>
        <listitem>
          <para>Java JDK 1.2 or above</para>
        </listitem>

        <listitem>
          <para>Java JDK 1.3 or above</para>
        </listitem>

        <listitem>
          <para>Java JDK 1.4 or above (recommended)</para>
        </listitem>
      </itemizedlist>

      <para>NEF has been tested on and requires one of the following Java
      Application Servers:</para>

      <itemizedlist>
        <listitem>
          <para>BEA WebLogic</para>
        </listitem>

        <listitem>
          <para>IBM WebSphere</para>
        </listitem>

        <listitem>
          <para>ORACLE AS</para>
        </listitem>

        <listitem>
          <para>Caucho Resin</para>
        </listitem>

        <listitem>
          <para>Apache Tomcat</para>
        </listitem>
      </itemizedlist>
    </section>

    &include_nef_faq_non_tech;
  </chapter>

  <chapter>
    <title>Getting Started</title>

    <para>While the Netspective Enterprise Frameworks Suite (NEFS) is
    comprised of Commons, Axiom, and Sparx the most visible portion of the NEF
    to end users (programmers) will be the Sparx Application Platform. For
    this reason, the remainder of this document will concentrate on
    introducing Sparx first and then referencing Commons and Axiom where
    appropriate. In many cases, the terms Sparx and NEF will be used
    interchangeably because Sparx builds upon and uses Commons and Axiom.</para>

    <section>
      <title>Evaluating the Frameworks</title>

      <para>The first (and quickest) way to evaluate the NEF is to view all
      the documentation online and follow along with the online versions of
      the applications created in the tutorials. The main advantages of this
      method are simplicity and speed. Since all you need is a web browser,
      you can start learning about NEF within minutes. You will also be
      introduced to NEF&#39;s built-in remote development and team programming
      capabilities. The disadvantage is that you will not have the ability to
      dabble in or change the application code yourself.</para>

      <para>The second (and recommended) way of evaluating NEF is by
      downloading a free developer evaluation kit or obtaining an evaluation
      CD direct from Netspective. This kit contains everything you need to
      start getting familiar with NEF and learning how to develop applications
      powered by it. The main advantage of using this method is that you will
      get a good hands-on look at NEF and, by the time you are through with
      the documentation and tutorials, you will be well on your way to
      developing your own applications using NEF. The only disadvantage is
      that you’ll need to download and install a Java Developer’s Kit (JDK)
      and the NEF kit itself on your own server.</para>

      <section>
        <title>Evaluating the Frameworks Online</title>

        <para>An online evaluation is only different from a regular evaluation
        in the amount of interaction you have with NEF. While the regular
        evaluation will enable you to re-create all the demonstration
        applications that come with the evaluation kit, the online version
        will allow you to only see the source code and the final products (you
        will not be able to modify any code).</para>

        <para>The only thing you will need to keep in mind while following the
        tutorials is that all URLs listed in the documentation that are
        supposed to be pointing to the applications developed in the tutorials
        will be different. The general rule is that for an application named
        appName, the URL for its online version should look like the following
        URL: <literal>http://sampler.netspective.com/nefs-sample-<replaceable>appName</replaceable></literal>.</para>

        <para>Therefore, if you are following the development of the Hello
        World application, instead of using your browser to access the URL
        mentioned in the documentation (<literal>http://localhost:8099/nefs-sample-hello-world</literal>),
        you should point your web browser to the following URL:
        http://sampler.netspective.com/nefs-sample-hello-world. Similarly,
        when following the development of the Library sample application
        online, you should point your web browser to <literal>http://sampler.netspective.com/nefs-sample-library</literal>
        instead of <literal>http://localhost:8099/nefs-sample-library</literal>.</para>
      </section>

      <section>
        <title>Evaluating the Frameworks on your PC</title>

        <para>This section introduces you to how to install pre-requesites the
        evaluation kit on your own PC instead of reviewing the code online.</para>

        <section>
          <title>Pre-requsites</title>

          <para>Since NEF works with J2EE application servers, a fundamental
          requirement to develop applications with it is a Java SDK (the full
          SDK is required, the JRE will not be enough). You can obtain Sun’s
          official Java SDK from its Java web site at <ulink
          url="http://java.sun.com/j2se/1.3/download.html">http://java.sun.com/j2se/1.3/download.html</ulink>.
          This is a link to the Java 1.3. SDK but Java 1.2 and 1.4 will also
          work.</para>

          <para>You can also optionally install a Java integrated development
          environment (IDE) for developing Sparx applications using the
          evaluation kit. Sparx does not require any particular Java IDE and
          if you prefer to use simple text editors like vi, emacs, or <ulink
          url="http://www.textpad.com">TextPad</ulink> those will do just as
          well. We recommend <ulink url="http://www.eclipse.org">Eclipse</ulink>
          or <ulink url="http://www.intellij.org">JetBrain’s IDEA</ulink> for
          those who are not already familiar with other IDEs.</para>
        </section>

        <section>
          <title>Installing the Evaluation Kit</title>

          <para>Navigate to the <ulink url="http://www.netspective.com">Netspective
          web site</ulink> and download the evaluation kit. The evaluation kit
          comes in the form of a Windows .zip or Unix tar.gz file. Uncompress
          the contents of the file into a directory of your choice – however,
          please realize that this document assumes you’re using the default
          <literal>C:\Netspective</literal> directory. If you are using UNIX,
          Linux, or OS X please make the appropriate adjustments mentally
          while reading this document.</para>
        </section>

        <section>
          <title>Starting the Application and Web Server (Resin)</title>

          <para>NEF includes a free development version of an excellent Java
          application server that doubles as a web server. Resin is a separate
          product and support for it is available from <ulink
          url="http://www.caucho.com">http://www.caucho.com</ulink>. NEF fully
          supports WebLogic, WebSphere, Tomcat, and many other application
          servers as well but for evaluation purposes we provide Resin because
          it’s easy to use and fast.</para>

          <para>Before attempting to access any sample application, you need
          to ensure that Resin is running. There are two methods of starting
          Resin. The first is as a foreground application that you manually
          start and leave running while you are working with NEF. The second
          is as a Windows service or a UNIX daemon.</para>

          <para>You can start Resin in the foreground by opening up My
          Computer under Windows and navigating to the evaluation kit’s
          installation directory (<literal>c:\Netspective</literal> by
          default). Navigate to the <literal>resin-x.y.z/bin</literal>
          directory under this installation directory and double-click on the
          executable named <literal>httpd.exe</literal>. This should start
          Resin in foreground mode running the web server and application
          servers on port 8099.</para>

          <para>If you’d like to use a different port you can modify
          resin-x.y.z/conf/resin.conf. For complete instructions on how to
          start Resin in the foreground or by deploying it as a NT
          service/daemon, please visit <ulink
          url="If you’d like to use a different port you can modify resin-x.y.z/conf/resin.conf. For complete instructions on how to start Resin in the foreground or by deploying it as a NT service/daemon, please visit http://www.caucho.com">http://www.caucho.com</ulink>.
          While you are developing your application it&#39;s best to remain in
          this foreground mode so that error messages sent to stdout will
          appear in your window instead of being placed in a log file.</para>
        </section>
      </section>
    </section>

    <section>
      <title>Using the Sampler to Sample the NEF</title>

      <para>You can get an idea of the kind of applications that can be
      developed with NEF by taking a look at the sample applications that come
      with the evaluation kit. To see a list of all the sample applications,
      go to <ulink url="http://sampler.netspective.com">http://sampler.netspective.com</ulink>
      (or <ulink url="http://localhost:8099">http://localhost:8099</ulink> if
      you installed the developer kit on your local machine). The
      <emphasis>Sampler</emphasis> application is itself an NEF (mainly Sparx)
      application that helps you navigate your way through all the NEF sample
      applications, test beds, and starter projects.</para>

      <screenshot>
        <graphic fileref="./resources/images/screen-sampler-home.gif" />
      </screenshot>

      <section>
        <title>Viewing Source Code in a Browser</title>

        <para>The Netspective administration console, called the
        <emphasis>Enterprise Console</emphasis>, provides a complete file
        browser with color syntax highlighting for XML, JSP, Java, JavaScript,
        and SQL files – this file browser allows you to review source code for
        sample applications at <ulink url="http://sampler.netspective.com">http://sampler.netspective.com</ulink>
        or locally if you downloaded the evaluation kit.</para>

        <para>The Enterprise Console is a Sparx Servlet that provides a
        browser-based administrative interface to all of the dynamic
        components and objects that NEF produces. The Enterprise Console is
        automatically available to all NEF-based applications during
        development. The Console&#39;s default user name is &#39;<literal>console</literal>&#39;
        and the default password is &#39;<literal>console</literal>&#39;.
        Unless otherwise specified, that is the user name and password
        combination you should use if the Console prompts you to login.</para>

        <screenshot>
          <graphic fileref="./resources/images/screen-console-login.gif" />
        </screenshot>

        <para>Once you have logged into the Console for any particular
        application, all of the source files and folders are available for
        viewing. Simply click on the <guimenuitem>Project</guimenuitem> tab
        and then click <guimenuitem>Project Folders</guimenuitem> to view all
        of the folders contained in the application and
        <guimenuitem>Project Files</guimenuitem> to navigate all the
        directories and look at the project files. The first time you enter
        the Project Files section, you should see a list of all the
        directories that exist in the application’s root directory. You can
        click on any directory to navigate to it and view the list of files
        and sub-directories inside it.</para>

        <screenshot>
          <graphic
          fileref="./resources/images/screen-console-project-files.gif" />
        </screenshot>

        <para>If you click on any XML, JSP or Java source file, you should
        also be able to see the source for those files directly from the
        browser.</para>

        <screenshot>
          <graphic
          fileref="./resources/images/screen-console-project-file-source.gif" />
        </screenshot>
      </section>
    </section>

    <section>
      <title>Application Directory Structure</title>

      <para>Every NEF application shares the benefit of a standard directory
      structure. To see the structure of an empty application (one with only
      the basic files required for all applications), view the Project Folders
      tab of the <ulink
      url="http://sampler.netspective.com/nefs-starter-empty/console/project/folders">starter
      application</ulink>.</para>

      <figure>
        <title>NEF Standard Project Directory Structure</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="./resources/images/screen-starter-folders.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <variablelist>
        <varlistentry>
          <term>APP_ROOT</term>

          <listitem>
            <para>The root directory (in this case <literal>nefs-starter-empty</literal>)
            contains all the browser-accessible files for the application.
            This is commonly referred to as the <emphasis>Document Root</emphasis>
            for a website because it is the root directory visible to web
            browsers. It also contains a private directory, called
            <literal>WEB-INF</literal>, for the application to store NEF and
            Java servlet related files (it&#39;s called private because none
            of its contents will ever be served to end users). As already
            mentioned, all files in the application’s root directory are
            accessible through a web browser. All subdirectories in the
            application root other than <literal>WEB-INF</literal> will also
            be directly accessible through a browser. Therefore, if you put an
            index.jsp file in this directory, you should be able to access it
            using a URL of the form http://host:port/appName/index.jsp.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>APP_ROOT/resources</term>

          <listitem>
            <para>If present this directory tree contains all of the
            application&#39;s shared files that need to be served to end users
            of your applications. Web browser resources that your application
            needs such as images and scripts are placed here and will be
            served to your end users by their browser.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>APP_ROOT/sparx</term>

          <listitem>
            <para>This directory tree contains all of the Sparx shared files
            that need to be served to end users of your applications. Web
            browser resources that Sparx needs such as style sheets,
            JavaScript sources, images, and Console files are placed here and
            will be served to your end users by their browser. You should not
            modify files in this directory because it does not contain any
            programmer-modifiable files.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>APP_ROOT/resources/sparx</term>

          <listitem>
            <para>This directory tree (which is not present in the starter
            application or the diagram above) contains optional Sparx shared
            files and resources that usually belong in <literal>APP_ROOT/sparx</literal>
            but are being overridden by your application. For example, if you
            have your own stylesheets or images that need to replace something
            in Sparx, they would be placed in this directory. Because the
            <literal>APP_ROOT/sparx</literal> directory contents should never
            be modified, the <literal>APP_ROOT/resources/sparx</literal>
            directory gives you the opportunity to override Sparx resources
            without worrying about files being overwritten when Sparx is
            upgrade.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>APP_ROOT/WEB-INF</term>

          <listitem>
            <para>The <literal>WEB-INF</literal> directory is required by the
            J2EE Servlet Specification. It contains all files private to the
            application, meaning none of the files in this directory will be
            accessible to an end-user’s web-browser (except through the
            Netspective Console which optionally allows secure browsing of
            source files in <literal>WEB-INF</literal>).</para>

            <para>The <literal>APP_ROOT/WEB-INF/web.xml</literal> file
            configures your application for your J2EE Servlet container and
            you should refer to your application server’s documentation for
            how to configure the contents of that file. For Resin (the
            application server included in the NEF Evaluation Kit) you can
            refer to the documentation available at <ulink
            url="http://www.caucho.com">http://www.caucho.com</ulink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>WEB-INF/classes</term>

          <listitem>
            <para>This directory, which is a part of the J2EE Servlet
            Specification, holds all the custom Java source code written for
            the application. After the application is built, each Java source
            file in this directory contains a corresponding compiled version
            in the same location as the source.</para>

            <para>All Java classes in WEB-INF/classes are automatically
            included in the classpath of the application. Therefore if you
            have declared a dialog (in the project.xml file) to have a custom
            Java handler for complete or partial dialog processing, the Java
            source and compiled versions should be located somewhere in this
            directory structure. Any auxiliary Java classes that you might
            need should also be placed here.</para>

            <para>By default, you should place all of your Java classes in the
            directory <literal>WEB-INF/classes/app</literal> (or another
            appropriate subdirectory) because certain application servers will
            not work with Java classes that are not in a package.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>WEB-INF/classes/auto</term>

          <listitem>
            <para>Although this directory is not found in the starter package,
            it is automatically created by NEF when it generates classes for
            use by your application. It is called <literal>auto</literal>
            because the classes in there are auto-generated and should not be
            modified.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>WEB-INF/lib</term>

          <listitem>
            <para>This directory, which is a part of the J2EE Servlet
            Specification, holds all the Java Archive (JAR) files needed by
            your application. These include not only JAR files needed for
            Sparx but also extra JAR files needed by your own Java classes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>WEB-INF/sparx</term>

          <listitem>
            <para>Sparx uses the <literal>WEB-INF/sparx</literal> directory to
            store its project component descriptors. There is usually at least
            one <literal>project.xml</literal> file and may contain
            subdirectories if you wish to split up your application component
            declarations. The <emphasis role="bold">APP_ROOT/WEB-INF/sparx/project.xml</emphasis>
            is the file that drives all of the Sparx functionality in your
            application (see <xref linkend="nef-project-file" />).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>WEB-INF/sparx/conf</term>

          <listitem>
            <para>This directory contains contains sample <literal>web.xml</literal>
            configuration files for different application servers like
            WebLogic, WebSphere, Resin and Tomcat. It also contains Ant build
            files for compiling your application&#39;s classes.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </chapter>

  <chapter>
    <title>Developing Applications with NEF</title>

    <para>There are several schools of thought when it comes to answering the
    &#34;where do I start writing my application?&#34; question. Two of the
    popular ones are:</para>

    <orderedlist>
      <listitem>
        <para>Define and prototype the entire user interface (presentation
        layer or UI) and wait until the UI is completed before starting the
        database management tasks. In this option, the user interface elements
        (forms, fields, etc.) drive the data model and schema.</para>
      </listitem>

      <listitem>
        <para>Define and prototype the entire data management layer first and
        then follow-up with the presentation layer. In this option, the data
        model and schema drive the user interface.</para>
      </listitem>
    </orderedlist>

    <para>Netspective does not assume either method to be correct so it
    supports both of them. Developing applications with NEF involves an
    interative process that includes (but is not limited to) the following
    steps:</para>

    <procedure>
      <step>
        <para>Define your requirements.</para>
      </step>

      <step>
        <para>Declare your requirements to Sparx using the XML tags.</para>
      </step>

      <step>
        <para>Use the Console to Unit Test your Sparx XML declarations.</para>
      </step>

      <step>
        <para>Generate classes for data access, object identification, and
        persistence.</para>
      </step>

      <step>
        <para>Customize functionality using either inheritance or delegation.</para>
      </step>

      <step>
        <para>Run Functional/Integration tests of your combined Sparx XML
        declarations and Java code customizations.</para>
      </step>

      <step>
        <para>Deploy your application once everything is working.</para>
      </step>
    </procedure>

    <figure>
      <title>NEF Application Development Process Overview</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="./resources/images/nefs-swdev-process.gif" />
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>Define</title>

      <para>This definition phase is usually a mental exercise but it may
      involve formal requirements gathering (Waterfall style) or using
      customer stories (XP/Agile style). Normally. the more time you spend in
      the definition phase understanding your customer&#39;s requirements, the
      less time you&#39;ll spend changing code later on. However, using
      NEF&#39;s delcarative programming model allow you to change requirements
      and lets your customers change their minds without significant impact to
      your code.</para>

      <section>
        <title>Defining the Presentation Layer</title>

        <section>
          <title>Navigation</title>

          <para>Define your application&#39;s hierarchy (the &#34;main&#34;
          menu, submenus, and so on). Consider each navigation item a
          &#34;page&#34;. Also consider how navigation should occur from one
          page to another so that appropriate workflows may be specified in
          forms and pages.</para>
        </section>

        <section>
          <title>Forms and Data Collection</title>

          <para>Define the manner in which data will be collected. This
          includes what forms, fields, field types, validation, and other
          related information might be required.</para>
        </section>
      </section>

      <section>
        <title>Defining the Data Management Layer</title>

        <section>
          <title>Static SQL Queries</title>

          <para>Consider what SQL should be created manually.</para>
        </section>

        <section>
          <title>Dynamic SQL Queries</title>

          <para>Consider what type of searches your application should
          perform.</para>
        </section>

        <section>
          <title>Database Schema</title>

          <para>Define the structures (tables, columns, relationships) needed
          to store your data and consider where the data will be stored (the
          type of database, location of the database, etc.). You may skip this
          phase of database schema definition if you are connecting to a
          legacy database or an existing data source.</para>
        </section>
      </section>

      <section>
        <title>Defining the Security Layer</title>

        <para>Define the different security roles necessary and all the
        permissions that will be assigned to roles.</para>
      </section>
    </section>

    <section>
      <title>Declare</title>

      <para>Almost all facets of the software development process are covered
      by the Commons, Axiom, and Sparx XML tags and Java APIs, including but
      not limited to, forms declarations, data validation, page definition,
      template writing, navigation, dynamic and static SQL, and database
      schemas. All of the declarations are placed in the <literal><filename>APP_ROOT/WEB-INF/sparx/project.xml</filename></literal>
      file (see <xref linkend="nef-project-file" />).</para>

      <section>
        <title>Declaring the Presentation Layer</title>

        <para>The presentation layer tags are broken up into several groups:
        navigation, forms/fields, on-screen validation, and conditional
        processing. Almost all of the presentation layer tags are managed by
        Sparx.</para>

        <section>
          <title>Introduction to Navigation Declaration Tags</title>

          <para>The navigation tags are comprised primarily of the <sgmltag
          class="starttag">navigation-tree</sgmltag>, <sgmltag
          class="starttag">page</sgmltag>, and <sgmltag class="starttag">body</sgmltag>
          tags. These are very high-level tags that provide a great deal of
          functionality without requiring any HTML or JSP. However, if you
          need to customize the behavior you have full access to the APIs
          through both inheritance and delegation. You focus on the hierarchy,
          specify the structure and rules and NEF will do the rest. The Sparx
          navigation system fully implements MVC (model-view-controller)
          design pattern.</para>

          <example>
            <title>Examples of Navigation Tags in the Presentation Layer</title>

            <programlisting>&#60;project xmlns:xdm=&#34;http://www.netspective.org/Framework/Commons/XMLDataModel&#34;&#62;
...

&#60;<emphasis role="bold">navigation-tree</emphasis> name=&#34;app&#34; default=&#34;yes&#34;&#62; <co
id="declare-nav-tags-eg-1" />

    &#60;<emphasis role="bold">page</emphasis> name=&#34;home&#34; default=&#34;yes&#34; caption=&#34;Hello&#34; heading=&#34;Hello World!&#34;&#62; <co
id="declare-nav-tags-eg-2" />
        &#60;<emphasis role="bold">body</emphasis>&#62; <co
id="declare-nav-tags-eg-3" />
            &#60;![CDATA[
            This is the &#39;Hello World&#39; app. Click &#60;a href=&#34;next-steps&#34;&#62;here&#60;/a&#62; to see what&#39;s next.
            ]]&#62;
        &#60;/body&#62;
    &#60;/page&#62;

    &#60;page name=&#34;next-steps&#34; caption=&#34;Next Steps&#34; heading=&#34;What&#39;s next?&#34;&#62;
        &#60;body <emphasis role="bold">source</emphasis>=&#34;next-steps.ftl&#34;/&#62; <co
id="declare-nav-tags-eg-4" />
    &#60;/page&#62;

    &#60;page name=&#34;some-stuff&#34; caption=&#34;Panels instead of Body&#34;&#62;
        &#60;<emphasis role="bold">panels</emphasis>&#62; <co
id="declare-nav-tags-eg-5" />
             &#60;panel type=&#34;command&#34; command=&#34;query,org.get-sponsor-info-by-id,-,-,-,detail-compressed&#34;/&#62;
             &#60;panel type=&#34;command&#34; command=&#34;query,org.get-org-addresses-by-id,-,-,-,report-compressed&#34; /&#62;
        &#60;/panels&#62;
    &#60;/page&#62;

    &#60;page name=&#34;sampler&#34; caption=&#34;Sampler&#34; <emphasis
role="bold">redirect</emphasis>=&#34;vs-expr:${servlet-context-uri:server-root}/nefs-sampler&#34;/&#62; <co
id="declare-nav-tags-eg-6" />
    &#60;page name=&#34;sampler&#34; caption=&#34;Sampler&#34; <emphasis
role="bold">include</emphasis>=&#34;/some/file.jsp&#34;/&#62; <co
id="declare-nav-tags-eg-7" />
    &#60;page name=&#34;sampler&#34; caption=&#34;Sampler&#34; <emphasis
role="bold">forward</emphasis>=&#34;/some/file.jsp&#34;/&#62; <co
id="declare-nav-tags-eg-8" />

    &#60;page name=&#34;add&#34; caption=&#34;Add Book&#34; <emphasis
role="bold">command</emphasis>=&#34;dialog,schema.db.Book_Info,add&#34;/&#62; <co
id="declare-nav-tags-eg-9" />
    &#60;page name=&#34;edit&#34; caption=&#34;Edit Book&#34; command=&#34;dialog,schema.db.Book_Info,edit&#34;
          require-request-param=&#34;id&#34; retain-params=&#34;id&#34;&#62;
        &#60;<emphasis role="bold">missing-params-body</emphasis>&#62; <co
id="declare-nav-tags-eg-10" />
           Please choose a book to edit from the &#38;lt;a href=&#39;home&#39;&#38;gt; books list&#38;lt;/a&#38;gt;.
        &#60;/missing-params-body&#62;
    &#60;/page&#62;</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-nav-tags-eg-1">
              <para>The <sgmltag class="starttag">navigation-tree</sgmltag>
              tag starts out the definition of a tree. You may declare as many
              navigation trees as your application needs. Consider different
              trees for different users (based on personalization) or a
              different tree for each access-control role (for security) or
              any other criteria required by your application. Each tree has a
              name and may be marked with <sgmltag class="attribute">default</sgmltag>=<sgmltag
              class="attvalue">yes</sgmltag> if it is to be the default tree.
              Which tree is actually used by the application may be specfied
              as a servlet parameter or chosen dynamically at runtime based on
              some processing rules.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-2">
              <para>Each <sgmltag class="starttag">navigation-tree</sgmltag>
              tag one or more <sgmltag class="starttag">page</sgmltag> tags
              that define what pages should be visible to the user. Each
              <sgmltag class="starttag">page</sgmltag> tag supports common
              things like the page&#39;s name (unique identifier), a caption
              (what might show up in a tab or menu), a heading, and title.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-3">
              <para>Each <sgmltag class="starttag">page</sgmltag> tag may have
              an optional <sgmltag class="starttag">body</sgmltag> tag with
              contents directly specified as XML content. You can use the
              CDATA XML element to escape HTML tags. The content of the
              <sgmltag class="starttag">body</sgmltag> tag is treated as a
              <ulink url="http://www.freemarker.org">FreeMarker</ulink>
              template by default.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-4">
              <para>The <sgmltag class="starttag">page</sgmltag> tag&#39;s
              <sgmltag class="starttag">body</sgmltag> tag may instead specify
              a <sgmltag class="attribute">source</sgmltag> attribute that
              indicates the given file is a a <ulink
              url="http://www.freemarker.org">FreeMarker</ulink> template
              relative to the APP_ROOT directory. Other template engines like
              JSP are also supported.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-5">
              <para>The <sgmltag class="starttag">page</sgmltag> tag&#39;s
              <sgmltag class="starttag">body</sgmltag> tag may be replaced
              with the <sgmltag class="starttag">panels</sgmltag> tag to have
              automatic layouts of mutliple panels.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-6">
              <para>The <sgmltag class="starttag">page</sgmltag> tag may
              specify a <sgmltag class="attribute">redirect</sgmltag>
              attribute to automatically redirect to another page whenever it
              is chosen.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-7">
              <para>The <sgmltag class="starttag">page</sgmltag> tag may
              specify an <sgmltag class="attribute">include</sgmltag>
              attribute to simply insert the contents of another web resource
              directly into the body.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-8">
              <para>The <sgmltag class="starttag">page</sgmltag> tag may
              specify a <sgmltag class="attribute">forward</sgmltag> attribute
              to forward the request to another web resource (this is the same
              as Servlet forwarding not HTTP forwarding).</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-9">
              <para>The <sgmltag class="starttag">page</sgmltag> tag may
              specify a <sgmltag class="attribute">command</sgmltag> attribute
              to use the Command pattern and delegate the body to a
              <classname>com.netspective.commons.command.Command</classname>
              interface. These are very high-level commands like interacting
              with a dialog and displaying the results of a query that can be
              defined elsewhere and called on different pages.</para>
            </callout>

            <callout arearefs="declare-nav-tags-eg-10">
              <para>The <sgmltag class="starttag">page</sgmltag> tag may
              specify required request parameters and optionally produce
              automatic error messages when they are not provided.</para>
            </callout>
          </calloutlist>

          <note>
            <para>Almost all <sgmltag class="starttag">page</sgmltag> tag
            attributes support Value Sources for their values so the values
            may be static or dynamic (see <xref
            linkend="section-value-sources" />). This allows, for example the
            captions, headings, and all user-visible values to be properly
            placed in property files or other external resources and mapped in
            a language-specific manner for internationlization purposes. The
            important thing to understand is that even though the declarations
            are in a static XML file, the values of the descriptors are
            capable of being dynamic.</para>
          </note>
        </section>

        <section>
          <title>Introduction to Forms Declaration Tags</title>

          <para>The forms tags are comprised primarily of the <sgmltag
          class="starttag">dialogs</sgmltag>, <sgmltag class="starttag">dialog</sgmltag>,
          and <sgmltag class="starttag">field</sgmltag> tags. These are very
          high-level tags that provide a great deal of functionality without
          requiring any HTML or JSP custom tags. You focus on the rules and
          validatoin createria and NEF will do the rest. NEF ships with many
          common controls and gives you the capability to add your own at any
          time.</para>

          <example>
            <title>Examples of Form Tags in Presentation Layer</title>

            <programlisting>&#60;project xmlns:xdm=&#34;http://www.netspective.org/Framework/Commons/XMLDataModel&#34;&#62;
...

&#60;<emphasis role="bold">dialogs</emphasis> package=&#34;test&#34;&#62; <co
id="declare-form-tags-eg-1" />
    &#60;<emphasis role="bold">dialog</emphasis> name=&#34;DialogTest_01_A&#34; retain-params=&#34;*&#34; hide-hints-until-focus=&#34;yes&#34;&#62; <co
id="declare-form-tags-eg-2" />
        &#60;<emphasis role="bold">frame</emphasis> heading=&#34;Test String Fields&#34;/&#62; <co
id="declare-form-tags-eg-3" />

        &#60;<emphasis role="bold">field</emphasis> name=&#34;text_field_hidden&#34; <emphasis
role="bold">type=&#34;text&#34;</emphasis> hidden=&#34;yes&#34; default=&#34;request:id&#34;/&#62; <co
id="declare-form-tags-eg-4" />
        &#60;field name=&#34;text_field&#34; type=&#34;text&#34; caption=&#34;Text&#34; hint=&#34;Text field optional (max-length=5, uppercase=yes)&#34;
               max-length=&#34;5&#34; uppercase=&#34;yes&#34;/&#62;
        &#60;field name=&#34;text_field_regex&#34; type=&#34;text&#34; caption=&#34;Text Email&#34; hint=&#34;Text field with regular expression validation&#34;
               display-pattern=&#34;/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/&#34;
               invalid-reg-ex-message=&#34;Invalid email format.&#34;/&#62;

               <co id="declare-form-tags-eg-5" />
        &#60;field <emphasis role="bold">type=&#34;boolean&#34;</emphasis> name=&#34;bool_field_radio&#34; caption=&#34;Boolean Field (Radio)&#34; style=&#34;radio&#34; /&#62;
        &#60;field name=&#34;email_field&#34; <emphasis role="bold">type=&#34;e-mail&#34;</emphasis> caption=&#34;Email&#34; hint=&#34;Email field&#34;/&#62;
        &#60;field name=&#34;masked_field&#34; <emphasis role="bold">type=&#34;text&#34;</emphasis> caption=&#34;Masked Field&#34; mask-entry=&#34;yes&#34; hint=&#34;e.g password&#34;/&#62;
        &#60;field <emphasis role="bold">type=&#34;integer&#34;</emphasis> name=&#34;integer_field&#34; caption=&#34;Integer Field&#34; hint=&#34;Integer field&#34; <emphasis
role="bold">persist=&#34;yes&#34;</emphasis>/&#62;
        &#60;field <emphasis role="bold">type=&#34;float&#34;</emphasis> name=&#34;float_field&#34; caption=&#34;Float Field&#34; hint=&#34;Float field&#34;/&#62;
        &#60;field <emphasis role="bold">type=&#34;currency&#34;</emphasis> name=&#34;currency_field1&#34; caption=&#34;Currency&#34; decimals-required=&#34;2&#34; default=&#34;123.45&#34;
               negative-pos=&#34;after-symbol&#34; hint=&#34;Currency field (US) with negative sign after the symbol&#34;/&#62;
        &#60;field <emphasis role="bold">type=&#34;phone&#34;</emphasis> name=&#34;phone_field1&#34; caption=&#34;Phone Field (dash format)&#34; strip-brackets=&#34;yes&#34; style=&#34;dash&#34;
               hint=&#34;Phone field&#34; default=&#34;8001234567&#34;/&#62;
        &#60;field <emphasis role="bold">type=&#34;zip-code&#34;</emphasis> name=&#34;zip_field&#34; caption=&#34;Zip Field&#34; hint=&#34;Zip code field&#34; default=&#34;12345&#34;/&#62;
        &#60;field <emphasis role="bold">type=&#34;ssn&#34;</emphasis> name=&#34;ssn_field&#34; caption=&#34;SSN&#34; strip-dashes=&#34;yes&#34; default=&#34;999999999&#34;/&#62;

        &#60;field <emphasis role="bold">type=&#34;select&#34;</emphasis> name=&#34;sel_field_combo_xml_items&#34; caption=&#34;Select Field (Combo with XML Items)&#34;
               style=&#34;combo&#34; default=&#34;A&#34; prepend-blank=&#34;yes&#34;&#62;
            &#60;items&#62;
                &#60;item value=&#34;A&#34; caption=&#34;Choice 1 (in XML Item)&#34;/&#62;
                &#60;item value=&#34;B&#34; caption=&#34;Choice 2 (in XML Item)&#34;/&#62;
                &#60;item value=&#34;C&#34; caption=&#34;Choice 3 (in XML Item)&#34;/&#62;
                &#60;item value=&#34;D&#34; caption=&#34;Choice 4 (in XML Item)&#34;/&#62;
                &#60;item value=&#34;E&#34; caption=&#34;Choice 5 (in XML Item)&#34;/&#62;
            &#60;/items&#62;
        &#60;/field&#62;

        &#60;field name=&#34;text_field_required&#34; type=&#34;text&#34; caption=&#34;Text Required&#34;
            hint=&#34;Text field is required when req param &#39;abc&#39; has value&#34;
            default=&#34;conditional Required Text&#34; required=&#34;no&#34;&#62;
            &#60;<emphasis role="bold">conditional</emphasis> action=&#34;apply-flags&#34; flags=&#34;required&#34; has-value=&#34;request:abc&#34;/&#62; <co
id="declare-form-tags-eg-6" />
        &#60;/field&#62;

        &#60;field name=&#34;properties&#34; <emphasis role="bold">type=&#34;html&#34;</emphasis> caption=&#34;HTML Template Field&#34;&#62;
            &#60;<emphasis role="bold">body</emphasis>&#62; <co
id="declare-form-tags-eg-7" />
                &#60;![CDATA[
                &#60;div class=&#39;textbox&#39;&#62;
                This is a FreeMarker template inside a dialog (1 + 1 = ${1 + 1}).
                &#60;/div&#62;]]&#62;
            &#60;/body&#62;
        &#60;/field&#62;

        &#60;<emphasis role="bold">director</emphasis> submit-caption=&#34;Submit&#34; style=&#34;acknowledge&#34;/&#62; <co
id="declare-form-tags-eg-8" />
    &#60;/dialog&#62;
</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-form-tags-eg-1">
              <para>All dialogs are placed into packages using the <sgmltag
              class="starttag">dialogs</sgmltag> tag so that they may be
              organized appropriately.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-2">
              <para>Each dialog is declared using a <sgmltag class="starttag">dialog</sgmltag>
              tag and is uniquely identified with a name. The fully qualfied
              name of the dialog becomes <replaceable>packageName</replaceable>.<replaceable>dialogName</replaceable>.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-3">
              <para>Dialogs may contain a <sgmltag class="starttag">frame</sgmltag>
              tag so that it can have an appropriate heading and borders if
              desired.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-4">
              <para>Dialogs must contain one or more <sgmltag class="starttag">field</sgmltag>
              tags that declare the input that needs to be obtained. All
              <sgmltag class="starttag">field</sgmltag> tags must specify a
              <sgmltag class="attribute">type</sgmltag> attribute that
              indicates the type of data that should be allowed along with one
              or more other attributes that control validation, data entry,
              and other rules.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-5">
              <para>NEF ships with many different high-level field types, all
              of which know how to render and validate themselves.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-6">
              <para>The <sgmltag class="starttag">field</sgmltag> tags may
              contain <sgmltag class="starttag">conditional</sgmltag> tags
              that allow some of the behavior of the field to change at
              runtime based on other field values, the request/response cycle,
              session information, or other arbitrary rules.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-7">
              <para>A special <sgmltag class="starttag">field</sgmltag>
              <sgmltag class="attribute">type</sgmltag>=<sgmltag
              class="attvalue">html</sgmltag> is provided so that the content
              of the field may be completely customized using a templating
              system or other means.</para>
            </callout>

            <callout arearefs="declare-form-tags-eg-8">
              <para>A <sgmltag class="starttag">director</sgmltag> tag is used
              for forms submission and to control navigation out of a dialog
              after processing is completed. Different directors may be
              created and reused for various purposes such as having a
              different set of buttons for confirm dialogs versus data entry
              dialogs.</para>
            </callout>
          </calloutlist>

          <note>
            <para>Almost all <sgmltag class="starttag">dialog</sgmltag> and
            <sgmltag class="starttag">field</sgmltag> tag attributes support
            Value Sources for their values so the values may be static or
            dynamic (see <xref linkend="section-value-sources" />). This
            allows, for example the captions, headings, and all user-visible
            values to be properly placed in property files or other external
            resources and mapped in a language-specific manner for
            internationlization purposes. Also, it means that the values of
            fields and select choices may be bound to database values,
            request/response values, or other dynamic sources. The important
            thing to understand is that even though the declarations are in a
            static XML file, the values of the descriptors are capable of
            being dynamic.</para>
          </note>
        </section>
      </section>

      <section>
        <title>Declaring the Data Management Layer</title>

        <para>The data manager layer tags are broken up into several groups:
        static queries, dynamic queries, schema management, and connection
        management, and database vendor management. Almost all of the data
        management layer tags are managed by Axiom.</para>

        <section>
          <title>Introduction to Static Query Declarations (Static Data Access
          Objects)</title>

          <para>That static query and data access objects (DAOs) declarations
          are comprised of the <sgmltag class="starttag">queries</sgmltag>,
          <sgmltag class="starttag">query</sgmltag>, and <sgmltag
          class="starttag">params</sgmltag> tags.</para>

          <example>
            <title>Examples of Query Tags in Data Management Layer</title>

            <programlisting>&#60;project xmlns:xdm=&#34;http://www.netspective.org/Framework/Commons/XMLDataModel&#34;&#62;
...

&#60;<emphasis role="bold">queries</emphasis> package=&#34;test&#34;&#62; <co
id="declare-data-query-static-eg-1" />

    &#60;<emphasis role="bold">query</emphasis> name=&#34;get-asset-loans&#34;&#62; <co
id="declare-data-query-static-eg-2" />

        select <co id="declare-data-query-static-eg-3" />
            asset_loan_id, last_name + &#39;, &#39; + first_name, Loan_Type.caption, loan_begin_date, loan_end_date, returned
        from
            Asset_Loan, Loan_Type, Borrower
        where
            loan_type = Loan_Type.id and
            Asset_Loan.borrower_id = Borrower.borrower_id and
            Asset_Loan.asset_id = ?
        order
            by loan_begin_date desc

        &#60;<emphasis role="bold">params</emphasis>&#62; <co
id="declare-data-query-static-eg-4" />
            <emphasis role="bold">&#60;param value=&#34;request:asset_id&#34;/&#62;</emphasis> <co
id="declare-data-query-static-eg-5" />
        &#60;/params&#62;
    &#60;/query&#62;
</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-data-query-static-eg-1">
              <para>All queries are placed into packages using the <sgmltag
              class="starttag">queries</sgmltag> tag so that they may be
              organized appropriately.</para>
            </callout>

            <callout arearefs="declare-data-query-static-eg-2">
              <para>Each query is declared using a <sgmltag class="starttag">query</sgmltag>
              tag and is uniquely identified with a name. The fully qualfied
              name of the query becomes <replaceable>packageName</replaceable>.<replaceable>queryName</replaceable>
              and may be treated as a read-only database-indendent DAO (data
              access object).</para>
            </callout>

            <callout arearefs="declare-data-query-static-eg-3">
              <para>The SQL for the query is placed in the XML. This way, all
              SQL is external from Java code and may be tuned, optimized, and
              modified separate from the code that calls it. Notice that the
              perferred method of creating static query objects to to not use
              SQL injection (replaceable SQL) and instead rely on bind
              parameters. If SQL Injection (or SQL rewriting) is required,
              then portions of actual SQL may be made replaceable using Value
              Sources as well.</para>
            </callout>

            <callout arearefs="declare-data-query-static-eg-4">
              <para>Each query that requires parameters may have a <sgmltag
              class="starttag">params</sgmltag>.</para>
            </callout>

            <callout arearefs="declare-data-query-static-eg-5">
              <para>Each <sgmltag class="starttag">params</sgmltag> tag must
              have one or more <sgmltag class="starttag">param</sgmltag> tags
              along with <sgmltag class="attribute">value</sgmltag>
              attributes. The <sgmltag class="attribute">value</sgmltag>
              attribute support Value Sources for its value so the value may
              be static or dynamic (see <xref linkend="section-value-sources" />).
              This allows, for example, the parameter to a query to be
              obtained dynamically from the runtime environment. Every
              <sgmltag class="starttag">query</sgmltag> tag also becomes a
              real Java object so parameters may be passed into Java methods
              for the object as well (which would override what was specified
              in the XML).</para>
            </callout>
          </calloutlist>

          <note>
            <para>A single <sgmltag class="starttag">query</sgmltag> tag may
            actually contain various SQL texts, each for a different database.
            For example, the <sgmltag class="starttag">query</sgmltag> tag
            supports defining multiple SQL statements for any given name so
            that the programmer only calls the right object and the SQL for
            the proper database will be called.</para>
          </note>
        </section>

        <section>
          <title>Introduction to Dynamic Query Declarations (Dynamic Data
          Access Objects)</title>

          <para>The dynamic queries data access objects (DAOs) declarations
          are comprised of the <sgmltag class="starttag">query-defn</sgmltag>,
          <sgmltag class="starttag">field</sgmltag>, and <sgmltag
          class="starttag">join</sgmltag> tags. Once declared, the query
          definition supports completely automatic generation of SQL based on
          user selections.</para>

          <example>
            <title>Examples of Query Definition Tags in Data Management Layer</title>

            <programlisting>&#60;project xmlns:xdm=&#34;http://www.netspective.org/Framework/Commons/XMLDataModel&#34;&#62;
...

&#60;<emphasis role="bold">query-defn</emphasis> name=&#34;books&#34;&#62; <co
id="declare-data-query-defn-eg-1" />

    &#60;<emphasis role="bold">field</emphasis> name=&#34;book_id&#34; caption=&#34;Book ID&#34; <emphasis
role="bold">join=&#34;BookInfo&#34;</emphasis> column=&#34;id&#34;/&#62; <co
id="declare-data-query-defn-eg-2" />
    &#60;field name=&#34;name&#34; caption=&#34;Name&#34; join=&#34;BookInfo&#34; column=&#34;name&#34;/&#62;
    &#60;field name=&#34;author&#34; caption=&#34;Author&#34; join=&#34;BookInfo&#34; column=&#34;author&#34;/&#62;
    &#60;field name=&#34;genre_id&#34; caption=&#34;Genre ID&#34; join=&#34;BookInfo&#34; column=&#34;genre&#34;/&#62;
    &#60;field name=&#34;genre_caption&#34; caption=&#34;Genre&#34; join=&#34;BookType&#34; column=&#34;caption&#34;/&#62;
    &#60;field name=&#34;isbn&#34; caption=&#34;ISBN&#34; join=&#34;BookInfo&#34; column=&#34;isbn&#34;/&#62;

    &#60;<emphasis role="bold">join</emphasis> name=&#34;BookInfo&#34; table=&#34;book_info&#34;/&#62; <co
id="declare-data-query-defn-eg-3" />
    &#60;join name=&#34;BookType&#34; table=&#34;book_type&#34; condition=&#34;BookType.id = BookInfo.genre&#34;/&#62;
</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-data-query-defn-eg-1">
              <para>All query definitions are declared using the <sgmltag
              class="starttag">query-defn</sgmltag> tag and are uniquely
              identified with a name.</para>
            </callout>

            <callout arearefs="declare-data-query-defn-eg-2">
              <para>Each query definition contains one ore more <sgmltag
              class="starttag">field</sgmltag> tags that declare the universe
              of selectable fields. The <sgmltag class="starttag">field</sgmltag>
              tags are specified so that Axiom knows what fields the user
              should be allowed to select. Query definition fields may come
              from a mix of tables so long as they have appropriately defined
              <sgmltag class="attribute">join</sgmltag> attribute values.</para>
            </callout>

            <callout arearefs="declare-data-query-defn-eg-3">
              <para>Each query definition contains one ore more <sgmltag
              class="starttag">join</sgmltag> tags that declare the source
              table for fields. The <sgmltag class="starttag">join</sgmltag>
              tags are specified so that Axiom knows which tables to connect
              to which fields.</para>
            </callout>
          </calloutlist>
        </section>

        <section>
          <title>Introduction to Schema Management Declarations</title>

          <para>The schema management descriptors are specified using the
          <sgmltag class="starttag">schema</sgmltag>, <sgmltag
          class="starttag">table</sgmltag>, and <sgmltag class="starttag">column</sgmltag>
          tags. Once declared, the schema descriptor supports completely
          automatic generation of SQL DML (insert/updates/removes), SQL DDL
          (create tables, objects, etc), and XML import/export. Schema tags
          support full relational integrity and may actually be used to define
          meta data to support Java-based relational integrity for existing
          and legacy databases that may not be built with fully relational
          integrity.</para>

          <example>
            <title>Examples of Schema Tags in Data Management Layer</title>

            <programlisting>&#60;project xmlns:xdm=&#34;http://www.netspective.org/Framework/Commons/XMLDataModel&#34;&#62;
...

&#60;<emphasis role="bold">schema</emphasis> name=&#34;db&#34;&#62; <co
id="declare-data-schema-eg-1" />
    <emphasis role="bold">&#60;xdm:include resource=&#34;com/netspective/axiom/conf/schema.xml&#34;/&#62;</emphasis> <co
id="declare-data-schema-eg-2" />

    &#60;<emphasis role="bold">data-type</emphasis> name=&#34;text&#34; <emphasis
role="bold">class=&#34;com.netspective.axiom.schema.column.type.TextColumn&#34;</emphasis>&#62; <co
id="declare-data-schema-eg-3" />
        &#60;size&#62;32&#60;/size&#62;
        &#60;<emphasis role="bold">sql-ddl</emphasis>&#62; <co
id="declare-data-schema-eg-4" />
            &#60;define dbms=&#34;ansi&#34; xdm:replace-template-expressions=&#34;no&#34;&#62;varchar(${column.getSize()})&#60;/define&#62;
            &#60;define dbms=&#34;oracle&#34; xdm:replace-template-expressions=&#34;no&#34;&#62;varchar2(${column.getSize()})&#60;/define&#62;
        &#60;/sql-ddl&#62;
    &#60;/data-type&#62;

    &#60;<emphasis role="bold">table-type</emphasis> name=&#34;Entity&#34; <emphasis
role="bold">class=&#34;my.base.TableClass&#34;</emphasis>&#62; <co
id="declare-data-schema-eg-5" />
        &#60;column <emphasis role="bold">name=&#34;${owner.name.toLowerCase()}_id&#34;</emphasis> <co
id="declare-data-schema-eg-6" /> <emphasis role="bold">type=&#34;auto-inc&#34;</emphasis> <co
id="declare-data-schema-eg-7" />
                <emphasis role="bold">primary-key=&#34;yes&#34; </emphasis>descr=&#34;Unique identifier for ${owner.name}&#34;/&#62;
    &#60;/table-type&#62;

    &#60;table-type name=&#34;Person&#34; <emphasis role="bold">type=&#34;Entity&#34;</emphasis>&#62; <co
id="declare-data-schema-eg-8" />
        &#60;column name=&#34;first_name&#34; <emphasis role="bold">type=&#34;text&#34;</emphasis> size=&#34;64&#34; descr=&#34;The person&#39;s first name&#34;/&#62;
        &#60;column name=&#34;last_name&#34; type=&#34;text&#34; size=&#34;64&#34; descr=&#34;The person&#39;s last name&#34;/&#62;
    &#60;/table-type&#62;

    &#60;<emphasis role="bold">table</emphasis> name=&#34;Borrower&#34; <emphasis
role="bold">type=&#34;Person&#34;</emphasis>&#62; <co
id="declare-data-schema-eg-9" />
        &#60;!-- no columns are being added, it&#39;s just first name and last name --&#62;
    &#60;/table&#62;

    &#60;table name=&#34;Asset&#34; abbrev=&#34;asset&#34; type=&#34;Entity,Presentation&#34;&#62;
        &#60;column name=&#34;type&#34; lookup-ref=&#34;Asset_Type&#34; required=&#34;yes&#34; descr=&#34;The type of asset&#34;/&#62;
        &#60;column name=&#34;name&#34; type=&#34;text&#34; size=&#34;64&#34; required=&#34;yes&#34; descr=&#34;Name of the asset&#34;/&#62;
        &#60;column name=&#34;quantity&#34; type=&#34;integer&#34; required=&#34;yes&#34;/&#62;
    &#60;/table&#62;

    &#60;table name=&#34;Asset_Type&#34; abbrev=&#34;atype&#34; <emphasis
role="bold">type=&#34;Enumeration&#34;</emphasis>&#62; <co
id="declare-data-schema-eg-10" />
        &#60;enumerations&#62;
            &#60;enum&#62;Other&#60;/enum&#62;
            &#60;enum&#62;Software&#60;/enum&#62;
            &#60;enum&#62;Periodical&#60;/enum&#62;
            &#60;enum&#62;Book&#60;/enum&#62;
        &#60;/enumerations&#62;
    &#60;/table&#62;</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-data-schema-eg-1">
              <para>All schemas are declared using the <sgmltag
              class="starttag">schema</sgmltag> tag and are uniquely
              identified with a name. You may define multiple schemas within
              the same project.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-2">
              <para>Schemas components like <sgmltag class="starttag">data-types</sgmltag>
              and <sgmltag class="starttag">table-types</sgmltag> that
              comprise a data dictionary may be externalized and shared across
              projects. The default <filename>com/netspective/axiom/conf/schema.xml</filename>
              resource file contains dozens of built-in data types and table
              types that may be extended or just used. Type such as text,
              integer, float, currency, date, and even composite types such as
              duration are built-into Axiom.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-3">
              <para>Each schema may define <sgmltag class="starttag">data-type</sgmltag>
              tags that act as column templates. Each data type may specify a
              special handler class as well so that actual functionality may
              be placed into Java classes.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-4">
              <para>Each <sgmltag class="starttag">data-type</sgmltag> tag may
              contain <sgmltag class="starttag">sql-ddl</sgmltag> tags that
              describe what a logical data type declaration should be
              physically constructed as when the SQL DDL is generated. Support
              for complete database independence is built-in.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-5">
              <para>Each schema may define <sgmltag class="starttag">table-type</sgmltag>
              tags that act as templates templates. Each table type may
              specify a special handler class as well so that actual
              functionality may be placed into Java classes. Any number of
              columns may be defined in a table type and automatically placed
              into tables that consume the table type.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-6">
              <para>In table type templates the names of columns may be
              auto-generated so that they follow a consistent scheme. In this
              case we&#39;re saying that all Entity tables should have an
              auto-incrementing primary key that is named the same name as the
              table plus &#39;_id&#39;.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-7">
              <para>Full support for database-independent auto-generated
              columns is provided. If a column is defined as an <sgmltag
              class="attvalue">auto-inc</sgmltag> column that column will
              automatically use sequences for its implementation in Oracle and
              an IDENTITY type in SQL *Server (Axiom will figure out the
              proper database at runtime). Support for a database-neutral GUID
              type is also available if non-numeric auto increment
              capabilities are required.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-8">
              <para>Type inheritance is supported in both data types and table
              types. A <sgmltag class="starttag">table-type</sgmltag> tag may
              use the <sgmltag class="attribute">type</sgmltag> attribute to
              extend other table types which would declare that the
              <literal>Person</literal> table type extends the
              <literal>Entity</literal> table type so that when the
              <literal>Person</literal> table type is assigned to a table it
              will get the contents of both table types.</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-9">
              <para>A <sgmltag class="starttag">table</sgmltag> tag may use
              the <sgmltag class="attribute">type</sgmltag> attribute to
              consume the contents of table-types. The <literal>Borrower</literal>
              table in this case declares that it&#39;s a Person type so it
              obtains the contents of the <literal>Person</literal> table type
              (and by inheritance the <literal>Entity</literal> table type as
              well).</para>
            </callout>

            <callout arearefs="declare-data-schema-eg-9">
              <para>Special support is included for lookup tables. A <sgmltag
              class="starttag">table</sgmltag> tag may use the <sgmltag
              class="attribute">type</sgmltag> attribute specify that it&#39;s
              an <literal>Enumeration</literal> table and with that simple
              declaration the table will be treated as a static table meaning
              any retrievals for rows necessary in the table will be done
              purely Java-side and will not require any database calls. Also,
              the static data defined in the <sgmltag class="starttag">table</sgmltag>
              tag will automatically be populated into the database when the
              DDL is loaded.</para>
            </callout>
          </calloutlist>
        </section>
      </section>

      <section>
        <title>Declaring the Security Layer</title>

        <para>The security layer is declared using the <sgmltag
        class="starttag">login-manager</sgmltag>, <sgmltag class="starttag">access-control</sgmltag>,
        <sgmltag class="starttag">permission</sgmltag> and <sgmltag
        class="starttag">roles</sgmltag> tags.</para>

        <section>
          <title>Introduction to Login Management and User Authentication Tags</title>

          <para>All sophisticated applications require logins based on
          appropriate privileges so NEF has built-in support for such user
          authentication using the <sgmltag class="starttag">login-manager</sgmltag>,
          <sgmltag class="starttag">login-authenticator</sgmltag>, <sgmltag
          class="starttag">authenticated-user-class</sgmltag>, <sgmltag
          class="starttag">password-query</sgmltag>, and <sgmltag
          class="starttag">login-dialog</sgmltag> tags.</para>

          <example>
            <title>Examples of Login an Authentication Tags in Security Layer</title>

            <programlisting>&#60;project xmlns:xdm=&#34;http://www.netspective.org/Framework/Commons/XMLDataModel&#34;&#62;
...

&#60;<emphasis role="bold">login-manager</emphasis> name=&#34;app&#34; default=&#34;yes&#34;&#62; <co
id="declare-security-login-mgr-eg-1" />
    &#60;<emphasis role="bold">login-authenticator</emphasis> class=&#34;com.netspective.sparx.security.authenticator.DatabaseLoginAuthenticator&#34;&#62; <co
id="declare-security-login-mgr-eg-2" />
        &#60;<emphasis role="bold">authenticated-user-class</emphasis>&#62;app.cts.AppAuthenticatedUser&#60;/authenticated-user-class&#62; <co
id="declare-security-login-mgr-eg-3" />
        &#60;<emphasis role="bold">password-query</emphasis>&#62; <co
id="declare-security-login-mgr-eg-4" />
            select
                password
            from
                person_login
            where
                user_id = ?
        &#60;/password-query&#62;
        &#60;<emphasis role="bold">role-query</emphasis>&#62; <co
id="declare-security-login-mgr-eg-5" />
            select
                role_id
            from
                person_role
            where
                user_id = ?
        &#60;/password-query&#62;
    &#60;/login-authenticator&#62;

    &#60;<emphasis role="bold">login-dialog</emphasis> retain-params=&#34;*&#34;&#62; <co
id="declare-security-login-mgr-eg-6" />
        &#60;frame heading=&#34;Welcome to the Clinical Trial System&#34;/&#62;
        &#60;field name=&#34;user-id&#34; type=&#34;text&#34; caption=&#34;Login ID&#34; required=&#34;yes&#34; persist=&#34;yes&#34; initial-focus=&#34;yes&#34;/&#62;
        &#60;field name=&#34;password&#34; type=&#34;text&#34; caption=&#34;Password&#34; mask-entry=&#34;yes&#34; required=&#34;yes&#34;/&#62;
    &#60;/login-dialog&#62;
&#60;/login-manager&#62;</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-security-login-mgr-eg-1">
              <para>A login manager is defined using the <sgmltag
              class="starttag">login-manager</sgmltag> tag and is uniquely
              identified with a name. You may define multiple login managers
              for different areas of your application or for multiple
              servlets. If no default login manager is specified no user
              authentication is required to enter an application.</para>
            </callout>

            <callout arearefs="declare-security-login-mgr-eg-2">
              <para>A <sgmltag class="starttag">login-authenticator</sgmltag>
              tag is used to specify all the options that will be used to
              actually perform the authentication. The
              DatabaseLoginAuthenticator class is built-in and is suitable for
              most uses. If you need alternate authentication schemes such as
              JAAS or your own custom routines those are also supported.</para>
            </callout>

            <callout arearefs="declare-security-login-mgr-eg-3">
              <para>The <sgmltag class="starttag">authenticated-user-class</sgmltag>
              tag is used to specify a class that will be used to manage an
              authenticated user. There are routines for managing the user id,
              the user&#39;s roles, permissions, and other attributes.</para>
            </callout>

            <callout arearefs="declare-security-login-mgr-eg-4">
              <para>The <sgmltag class="starttag">password-query</sgmltag> tag
              is used to specify the SQL that should be executed to obtain a
              valid passoword. This query is sent a single parameter (the user
              id typed into the dialog) and if it returns a single value it is
              considered the password. That password is then matched against
              what the user types in. Support for encrypted passwords is also
              built-in.</para>
            </callout>

            <callout arearefs="declare-security-login-mgr-eg-5">
              <para>The <sgmltag class="starttag">role-query</sgmltag> tag is
              used to specify the SQL that should be executed to obtain a list
              of access control list roles assigned to an authenticated user.
              This query is sent a single parameter (the user id typed into
              the dialog) and it should return the list of roles assigned to
              the user.</para>
            </callout>

            <callout arearefs="declare-security-login-mgr-eg-6">
              <para>The <sgmltag class="starttag">login-dialog</sgmltag> tag
              is used to declare the contents of the dialog that will be used
              to get the username and password.</para>
            </callout>
          </calloutlist>
        </section>

        <section>
          <title>Introduction to Access Control and User Authorization Tags</title>

          <para>Once a user has been authenticated they may still require
          authorization to perform certain activities. NEF has built-in
          support for building user authorization rules and declartively
          controlling access to application components based on authorization
          rules such as roles and permissions.</para>

          <example>
            <title>Examples of Access Control and Authorization Tags in
            Security Layer</title>

            <programlisting>&#60;project xmlns:xdm=&#34;http://www.netspective.org/Framework/Commons/XMLDataModel&#34;&#62;
...

&#60;<emphasis role="bold">access-control-list</emphasis> name=&#34;acl&#34;&#62; <co
id="declare-security-acl-eg-1" />
    &#60;<emphasis role="bold">permission</emphasis> name=&#34;app&#34;&#62; <co
id="declare-security-acl-eg-2" />
        &#60;<emphasis role="bold">permission</emphasis> name=&#34;orders&#34;&#62; <co
id="declare-security-acl-eg-3" />
            &#60;permission name=&#34;order_list&#34;/&#62;
            &#60;permission name=&#34;create_order&#34;/&#62;
            &#60;permission name=&#34;edit_order&#34;/&#62;
            &#60;permission name=&#34;view_order&#34;/&#62;
            &#60;permission name=&#34;delete_order&#34;/&#62;
        &#60;/permission&#62;
    &#60;/permission&#62;

    &#60;<emphasis role="bold">role</emphasis> name=&#34;role&#34;&#62; <co
id="declare-security-acl-eg-4" />
        &#60;<emphasis role="bold">role</emphasis> name=&#34;super-user&#34;&#62; <co
id="declare-security-acl-eg-5" />
            &#60;grant permission=&#34;/acl/app/orders&#34;/&#62;
        &#60;/role&#62;
        &#60;role name=&#34;normal-user&#34;&#62;
            &#60;<emphasis role="bold">grant</emphasis> permission=&#34;/acl/app/orders&#34;/&#62; <co
id="declare-security-acl-eg-6" />
            &#60;<emphasis role="bold">revoke</emphasis> permission=&#34;/acl/app/orders/delete_order&#34;/&#62; <co
id="declare-security-acl-eg-7" />
        &#60;/role&#62;
    &#60;/role&#62;
&#60;/access-control-list&#62;</programlisting>
          </example>

          <calloutlist>
            <callout arearefs="declare-security-acl-eg-1">
              <para>An access control list is defined using the <sgmltag
              class="starttag">access-control-list</sgmltag> tag and is
              uniquely identified with a name. You may define multiple access
              control list managers for different areas of your application or
              for multiple servlets.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-2">
              <para>The <sgmltag class="starttag">permission</sgmltag> tag
              defines a feature or function that needs to be protected.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-3">
              <para>The <sgmltag class="starttag">permission</sgmltag> tag may
              be defined hierarchically.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-4">
              <para>The <sgmltag class="starttag">role</sgmltag> tag defines a
              user role.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-5">
              <para>The <sgmltag class="starttag">role</sgmltag> tag may be
              defined hierarchically.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-6">
              <para>Each <sgmltag class="starttag">role</sgmltag> tag may
              grant one or more permissions. Roles may be permissive or
              restrive.</para>
            </callout>

            <callout arearefs="declare-security-acl-eg-7">
              <para>Each <sgmltag class="starttag">role</sgmltag> tag may
              revoke one or more permissions.</para>
            </callout>
          </calloutlist>
        </section>
      </section>
    </section>

    <section>
      <title>Unit Test</title>

      <para>Every Sparx XML tag you use to declare your application&#39;s
      requirements has an automated means to verify and test your declaration
      within the Console. At this point you may begin to involve your
      customers by demonstrating the forms, validation, pages, etc within the
      Console -- before you start writing any code.</para>
    </section>

    <section>
      <title>Generate Code</title>

      <para>Generate SQL DDL (data definition language) for creating database
      schemas and generate the data access objects (DAOs) that become the Data
      Access Layer (DAL) for reading and writing content from the database.
      Each schema generated by Axiom automatically includes the ability to
      import data using XML (either for testing purposes or for production
      usage).</para>
    </section>

    <section>
      <title>Customize Code</title>

      <para>Use Java class inheritance, composition, or listeners to Customize
      your Sparx XML declarations. The Sparx XML declarations basically create
      common functionality. By adding Java code you will customize the
      declarations to execute customized business logic.</para>
    </section>

    <section>
      <title>Functional/Integration Test</title>

      <para>Run Functional/Integration tests of your combined Sparx XML
      declarations and Java code customizations.</para>
    </section>

    <section>
      <title>Deploy</title>

      <para>Deploy your application once everything is working.</para>
    </section>
  </chapter>

  <chapter>
    <title>Key NEF Concepts</title>

    <para>This chapter outlines some of the important, global, concepts that
    you should be familiar with before embarking on developing your own
    applications.</para>

    <section>
      <title id="nef-project-file">The NEF Project File</title>

      <para>All of the NEF (Sparx, Axiom, and Commons) components are declared
      in an <emphasis>input source</emphasis> file known as the
      <emphasis>Project File</emphasis>. The Project File may be either a
      single file with all components or may be broken up into multiple files
      and pulled into the main Project File by using <sgmltag class="starttag">xdm:include</sgmltag>
      tags.</para>

      <example>
        <title>Basic NEF Project File</title>

        <programlisting>&#60;?xml version=&#34;1.0&#34;?&#62;

&#60;project xmlns:xdm=&#34;http://www.netspective.org/Framework/Commons/XMLDataModel&#34;&#62; <co
id="project-file-basic-eg-1" />

    &#60;xdm:include resource=&#34;com/netspective/commons/conf/commons.xml&#34;/&#62; <co
id="project-file-basic-eg-2" />
    &#60;xdm:include resource=&#34;com/netspective/axiom/conf/axiom.xml&#34;/&#62; <co
id="project-file-basic-eg-3" />
    &#60;xdm:include resource=&#34;com/netspective/sparx/conf/sparx.xml&#34;/&#62; <co
id="project-file-basic-eg-4" />
    &#60;xdm:include resource=&#34;com/netspective/sparx/conf/console.xml&#34;/&#62; <co
id="project-file-basic-eg-5" />

    <replaceable>&#60;!-- Your application tags go here. --&#62;</replaceable> <co
id="project-file-basic-eg-6" />

    &#60;xdm:include file=&#34;your/own/file.xml&#34;/&#62; <co
id="project-file-basic-eg-7" />

    <replaceable>&#60;!-- Your other application tags go here. --&#62;</replaceable>
&#60;/project&#62;</programlisting>

        <calloutlist>
          <callout arearefs="project-file-basic-eg-1">
            <para>The root tag is called <sgmltag class="starttag">project</sgmltag>
            and should use the provided <literal>xdm</literal> namespace.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-2">
            <para>Include the Netspective Commons default component
            declarations. It uses the <literal>resource</literal> attribute so
            it will be located by searching the classpath and will usually
            find the file in the JAR file and directly read it from there.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-3">
            <para>Include the Netspective Axiom default component declarations
            and factory registrations. It uses the <literal>resource</literal>
            attribute so it will be located by searching the classpath and
            will usually find the file in the JAR file and directly read it
            from there.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-4">
            <para>Include the Netspective Sparx default component declarations
            and factory registrations. It uses the <literal>resource</literal>
            attribute so it will be located by searching the classpath and
            will usually find the file in the JAR file and directly read it
            from there.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-5">
            <para>Include the Netspective Enterprise Console servlet
            declarations and application components. If you are turning off
            the Console in your applications you may leave this line out.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-6">
            <para>This is the location where your component declarations will
            be done. Unless otherwise specified, all the components are
            declared right under the <sgmltag class="starttag">project</sgmltag>
            tag.</para>
          </callout>

          <callout arearefs="project-file-basic-eg-7">
            <para>This line demonstrates how you can include your own XML
            files using the <literal>file</literal> attribute. In this
            example, because the file is not absolute it will be treated as
            relative to the calling file. The <sgmltag class="starttag">xdm:include</sgmltag>
            tag may be included anywhere in the file and simple takes items
            from the included file and places them into the calling file while
            parsing.</para>
          </callout>
        </calloutlist>
      </example>

      <note>
        <para>The <sgmltag class="starttag">xdm:include</sgmltag> tag is
        explained further in <xref linkend="section-xdm-include" />.</para>
      </note>

      <section>
        <title>Input Source</title>

        <para>The default Project File is <filename>APP_ROOT/WEB-INF/sparx/project.xml</filename>
        but may be configured to be a different file. Although you may choose
        an alternate location for the Project File, the remainder of this
        document assumes that the Project File is <filename>APP_ROOT/WEB-INF/sparx/project.xml</filename>.
        The project file may be either a physical file or be provided as a
        resource (URL) if desired. While looking at an NEF application, you
        can always find the Project File location by opening the Console for
        the given application and looking at the Console
        <menuchoice><guimenu>Home</guimenu></menuchoice> Page.</para>

        <screenshot>
          <graphic
          fileref="./resources/images/screen-console-home-project-file-highlight.gif" />
        </screenshot>

        <para>If you would like more information about where your Project File
        is and how it&#39;s being loaded, you will want to go to the
        Console&#39;s <menuchoice><guimenu>Project</guimenu><guimenuitem>Source</guimenuitem></menuchoice>
        menu. That page will show not only the main file but all included
        resources, components, and files (all of the final paths of any
        <sgmltag class="starttag">xdm:include</sgmltag> tags).</para>

        <screenshot>
          <graphic
          fileref="./resources/images/screen-console-project-source.gif" />
        </screenshot>

        <para>If you would like to specify an alternate name for the Project
        File you may change the location in the application&#39;s
        <filename>WEB-INF/web.xml</filename> file.</para>

        <example>
          <title>Specifying a different location for the NEF Project File</title>

          <programlisting>&#60;web-app&#62;
      ...
    &#60;servlet&#62;
        &#60;servlet-name&#62;SparxNavigationController&#60;/servlet-name&#62;
        &#60;servlet-class&#62;com.netspective.sparx.navigate.NavigationControllerServlet&#60;/servlet-class&#62;
        &#60;init-param&#62;
            &#60;param-name&#62;com.netspective.sparx.navigate.CONTROLLER_SERVLET_OPTIONS&#60;/param-name&#62;
            &#60;param-value&#62;<emphasis role="bold">--project=/WEB-INF/other/path/project.xml</emphasis>&#60;/param-value&#62;
        &#60;/init-param&#62;
    &#60;/servlet&#62;
      ...
&#60;/web-app&#62;</programlisting>
        </example>

        <note>
          <para>To learn more about the other controller servlet options
          allowed by Sparx, visit Console&#39;s <menuchoice><guimenu>Project</guimenu><guimenuitem>Configuration</guimenuitem></menuchoice>
          page.</para>
        </note>
      </section>

      <section>
        <title>Errors and Warnings</title>

        <para>Because the NEF manages literally hundreds of objects and
        classes and allows you to use XML to declare some sophisticated object
        relationships, many errors and warnings may be displayed. Errors are
        always highlighted within your applications, the Console, and
        <literal>stdout</literal>. A few contrived errors have been created
        for the Hello World application and the following screen shots
        demonstrate how you will be able to tell if there are errors in your
        application.</para>

        <para><example><title>NEF Error Reporting Samples</title><para>The
        following screenshot highlights the line that will appear at the top
        of your application if there are any NEF errors.</para><screenshot><graphic
        fileref="./resources/images/screen-hello-world-error-line.gif" /></screenshot><para>When
        you click on the Console link in the error message (or go to the
        application&#39;s Console Project Source tab) you will see something
        like the following. Notice that if there are any errors and you are
        viewing the Console you will see a error highlight at the top of the
        Console window. Once you&#39;re in the Console
        <menuchoice><guimenu>Project</guimenu><guimenuitem>Source</guimenuitem></menuchoice>
        menu you will be presented with a listing of the errors in the middle
        of the page.</para><screenshot><graphic
        fileref="./resources/images/screen-console-error-highlight.gif" /></screenshot></example></para>
      </section>

      <section>
        <title>The <classname>com.netspective.sparx.Project</classname> class</title>

        <para></para>
      </section>
    </section>

    <section>
      <title>The XML Data Model (XDM)</title>

      <para>The eXtensible Markup Language (XML) plays an important role in
      NEF&#39;s ease of use, extensibility, and code generation. NEF
      declarations are performed using XML -- all dialogs, fields, validation
      rules, some conditional processing, all SQL statements, dynamic queries,
      configuration files, database schemas, and many other resources are
      stored in XML files that are re-usable across applications. Although XML
      is the preferred method for creating resource files, almost anything
      that can be specified in XML can also be specified using the NEF Java
      APIs. If you are not familiar with XML, please visit <ulink
      url="http://www.xml.com/">http://www.xml.com/</ulink> for some training
      materials. NEF uses the JAXP and SAX standards for parsing and
      processing XML files.</para>

      <para>NEF utilizes XML in a declarative, not imperative manner. What
      this means is that XML is not used as yet another imperative programming
      or expression language like Java, C/C++, or Pascal. Instead, it is
      simply used to declare classes, rules, specifications, and other
      application requirements that are automatically parsed, read, cached,
      and executed by one or more NEF components. The dynamic aspects of NEF
      applications comes from Java through the use of <literal>Value Source</literal>
      and <literal>Command</literal> interfaces, not a new programming
      language.</para>

      <section>
        <title>XDM Overview</title>

        <para>XDM is an acronym for &#34;XML Data Model&#34; and is designed
        to help Java programmers construct and configure Java objects using
        XML files without worrying about parsing and error checking. The
        <filename>APP_ROOT/WEB-INF/sparx/project.xml</filename> file uses XDM
        to declare all project components. The primary objective is to declare
        your object&#39;s data and structure in XML and have XDM automatically
        construct the objects and assign the data provided in an XML file with
        almost no performance penalties. XDM does not introduce a new language
        nor does it replace Java classes, methods, or business logic. The main
        use for XDM is to allow you to use resource files (XML) to declare the
        hierarchy and initial data model (state) of your objects. The reason
        there is almost no performance penalty is that the XDM simply reads
        the XML and invokes the exact same constructors and methods in your
        classes exactly as if you had done so by manually writing Java code
        (including inheritance and composition).</para>
      </section>

      <section>
        <title>XDM Features</title>

        <itemizedlist>
          <listitem>
            <para>XDM automatically translates XML tags and attributes to your
            object hierarchy and data model with no manual mapping or
            configuration.</para>
          </listitem>

          <listitem>
            <para>XDM uses simple JavaBeans naming standards and the Java
            Reflection API to instantiate and initialize the objects declared
            in the XML resource files.</para>

            <itemizedlist>
              <listitem>
                <para>XML elements (tags) are instantiated into runtime
                objects exactly as if you called the object constructor in
                Java code.</para>
              </listitem>

              <listitem>
                <para>XML attributes invoke Java class mutator (setter)
                methods exactly as if you called the set method in Java code.</para>
              </listitem>

              <listitem>
                <para>XML element text (PCDATA) may be automatically appended
                using configurable method calls.</para>
              </listitem>

              <listitem>
                <para>XML child elements that have element content can be
                configured to create child objects or call mutator (setter)
                methods. This allows you to use the element or attribute style
                of XML resource files.</para>
              </listitem>

              <listitem>
                <para>Automatic type conversion validates and translates text
                from XML attributes into the proper object&#39;s mutator
                (setter) method parameter types: boolean, int, float, String,
                etc. Automatic error checking will ensure that when your class
                setter method parameter type changes, the XDM will
                automatically validate the new parameter type.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>The translation process is configurable so that you can
            create element or attribute aliases (so that you can create XML
            tag and attribute names that may be mapped to different method
            names in Java than what the JavaBean standards would imply).</para>
          </listitem>

          <listitem>
            <para>XDM templates provide object composition and inheritance
            behavior exactly as Java code.</para>
          </listitem>

          <listitem>
            <para>XDM include files provide the capability to break out large
            object construction tasks into multiple resource files.</para>
          </listitem>

          <listitem>
            <para>XDM transformers provide the capability to filter XML files
            through XSLT or other transformations before object construction
            takes place.</para>
          </listitem>

          <listitem>
            <para>Using the factory design pattern, the XML traversal is
            separated from the object instantiation and method invocation.</para>
          </listitem>

          <listitem>
            <para>Custom handlers allow portions of XML to be handled
            manually.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>XDM Performance</title>

        <para>When engineers first learn about XML and the amount of
        flexibility it affords in both application and data management, they
        jump at the chance to include XML features within their projects.
        However, soon they learn that dealing with XML sometimes means
        sacrificing performance. With NEF, all XML data is cached and only
        read when it changes. Basically, all NEF XML files are read using
        lazy-read approach; meaning, they are read only when needed and even
        then only once. So, the majority of all NEF XML performance impacts
        (if any) occur at the startup of a server-based application. Once the
        application starts all data is cached and shared across users and
        XML-related performance issues are eliminated. Also, NEF relies on the
        SAX programming interface for XML parsing and processing thus
        requiring far less memory and performance overhead than frameworks
        that rely on the DOM interface.</para>
      </section>

      <section>
        <title>XDM Tags versus JSP Tags</title>

        <para>JSP tag libraries are usually used for emitting HTML. They are
        commonly used in the view component of the MVC paradigm. NEF XML tags
        are used to describe and declare all aspects of your application (UI,
        database, security, etc). NEF can use existing JSP tag libraries but
        they are seldom needed because NEF&#39;s Sparx framework will handle
        most tasks within its own, much simpler, and much more powerful XML
        tags.</para>
      </section>

      <section>
        <title>Declaring Project Components using Tags</title>

        <para></para>
      </section>

      <section>
        <title>XDM Tag Reference</title>

        <para></para>
      </section>

      <section>
        <title id="section-xdm-include">Including XML Files into Other XML
        Files</title>

        <para>The <sgmltag class="starttag">xdm:include</sgmltag> tag allows
        you to import to include the contents of other XML files into the
        Project File. The <sgmltag class="starttag">xdm:include</sgmltag> tag
        may also be called recursively. This means that the one file can
        include another file which can include another file and so on.</para>

        <example>
          <title>How to use the <sgmltag class="starttag">xdm:include</sgmltag>
          tag</title>

          <programlisting>&#60;project xmlns:xdm=&#34;http://www.netspective.org/Framework/Commons/XMLDataModel&#34;&#62;

    &#60;xdm:include file=&#34;/some/absolute/file.name&#34;/&#62; <co
id="xdm-include-file-abs" />
    &#60;xdm:include file=&#34;a/relative/file.name&#34;/&#62; <co
id="xdm-include-file-rel" />

    &#60;xdm:include resource=&#34;a/relative/file.name&#34;/&#62; <co
id="xdm-include-res-abs" />
    &#60;xdm:include resource=&#34;a/relative/file.name&#34; relative-to=&#34;my.custom.ClassName&#34;/&#62; <co
id="xdm-include-res-rel" />

    &#60;xdm:include template=&#34;template-name&#34;/&#62; <co
id="xdm-include-template" /></programlisting>
        </example>

        <calloutlist>
          <callout arearefs="xdm-include-file-abs">
            <para>Include the contents of the given file using an abosolute
            path.</para>
          </callout>

          <callout arearefs="xdm-include-file-rel">
            <para>Include the contents of the given file using a relative
            path. When relative paths are provided, the path is relative to
            the parent file.</para>
          </callout>

          <callout arearefs="xdm-include-res-abs">
            <para>Include the contents of the given file name but locate it
            using Java&#39;s resource loading mechanism. Since no <sgmltag
            class="attribute">relative-to</sgmltag> attribute is provided, the
            resource will be located relative to the <classname>com.netspective.sparx.Project</classname>
            class.</para>
          </callout>

          <callout arearefs="xdm-include-res-rel">
            <para>Include the contents of the given file name but locate it
            using Java&#39;s resource loading mechanism. Since the <sgmltag
            class="attribute">relative-to</sgmltag> attribute is provided, the
            resource will be located relative to the class called
            <classname>my.custom.ClassName</classname>.</para>
          </callout>

          <callout arearefs="xdm-include-template">
            <para>See <xref linkend="xdm-templates" />.</para>
          </callout>
        </calloutlist>

        <note>
          <para>The <sgmltag class="attribute">file</sgmltag>, <sgmltag
          class="attribute">resource</sgmltag>, and <sgmltag class="attribute">template</sgmltag>
          attributes are all mutually exclusive meaning if you include a file
          you may not, within the same tag, also include resources or
          templates. However, you can separate them into multiple <sgmltag
          class="starttag">xdm:include</sgmltag> tags.</para>
        </note>
      </section>

      <section>
        <title>Pre-processing XDM Files</title>

        <para>Because most XDM files contain descriptors for classes to be
        instantiated, there are times when an XML file should be pre-processed
        or somehow transformed before NEF processes the file. This allows XSLT
        and other transformations to occur on an XML file before NEF processes
        the files so that objects may be constructed on the fly or allow some
        other automation to occur.</para>

        <example>
          <title>How to Pre-process an XDM file</title>

          <programlisting>&#60;?xml version=&#34;1.0&#34;?&#62;
&#60;?transform --xslt /an/absolute/file.xsl?&#62; <co
id="xdm-pre-process-pi-file-abs" />
&#60;?transform --xslt a/relative/file.xsl?&#62; <co
id="xdm-pre-process-pi-file-rel" />
&#60;?transform --resource --xslt com/netspective/commons/xdm/DataModelSchemaTestTransform.xsl?&#62; <co
id="xdm-pre-process-pi-res-abs" />

&#60;project ...&#62;
    ....
&#60;/project&#62;</programlisting>

          <calloutlist>
            <callout arearefs="xdm-pre-process-pi-file-abs">
              <para>The XDM pre-processing occurs with a processing
              instruction called <sgmltag class="pi">transform</sgmltag>. The
              main parameter, called <literal>--xslt</literal>, provides the
              name of the XSLT file to send the XML file through before
              processing as XDM. In this example it&#39;s an absolute file.</para>
            </callout>

            <callout arearefs="xdm-pre-process-pi-file-rel">
              <para>You can specify relative files for the pre-processor as
              well. If the file is not absolute then it is relative to the
              parent file (the file containing the <sgmltag class="pi">transform</sgmltag>
              instruction.</para>
            </callout>

            <callout arearefs="xdm-pre-process-pi-res-abs">
              <para>Specify <literal>the --resource</literal> parameter If the
              XSLT file should be located using Java&#39;s resource loading
              mechanism then the --resource flag may be specified.</para>
            </callout>
          </calloutlist>
        </example>
      </section>

      <section>
        <title id="xdm-templates">XDM Templates</title>

        <para>XDM Templates are very powerful but easy to use alternatives to
        pre-processing using XSLT. They basically allow defining custom tags
        that are not actually instantiated into obects; instead they are
        stored as a template to be reused by other objects. An example should
        clarify how to create (produce) and use (consume) templates:</para>

        <example>
          <title>How to Use Global XDM Templates</title>

          <programlisting>&#60;xdm:template name=&#34;test-template-1&#34;&#62; <co
id="xdm-template-define" /> <co id="xdm-template-name" />
    &#60;xdm:template-param name=&#34;param1&#34; default=&#34;4234&#34;/&#62; <co
id="xdm-template-param-optional" />
    &#60;xdm:template-param name=&#34;param2&#34; required=&#34;yes&#34;/&#62; <co
id="xdm-template-param-required" />

    &#60;nested1 text=&#34;TestNested1Template&#34; integer=&#34;100&#34;&#62;
        PCDATA in TestNested1Template.
        &#60;nested11 text=&#34;<emphasis role="bold">${params.param1}</emphasis>&#34; integer=&#34;<emphasis
role="bold">${params.param2}</emphasis>&#34;/&#62; <co
id="xdm-template-param-use" />
        &#60;nested11 type=&#34;type-A&#34; text=&#34;TestText12&#34; integer=&#34;12&#34;/&#62;
        &#60;nested11 class=&#34;com.netspective.commons.xdm.DataModelSchemaTest$CustomNested11Test&#34;
                  text=&#34;CustomTestText12&#34;
                  integer=&#34;122&#34;/&#62;
    &#60;/nested1&#62;
&#60;/xdm:template&#62;

<emphasis role="bold">&#60;xdm:include template=&#34;test-template-1&#34; xdm:param-param1=&#34;param1-value&#34;/&#62; </emphasis><co
id="xdm-template-consume-generic" /></programlisting>
        </example>

        <calloutlist>
          <callout arearefs="xdm-template-define">
            <para>A template is created (or <emphasis>produced</emphasis>)
            using the <sgmltag class="starttag">xdm:template</sgmltag> tag or
            with custom tags defined by <emphasis>template producers</emphasis>
            (see <xref linkend="xdm-template-producers" />). Every template is
            contained within a <emphasis>template namespace</emphasis>. If a
            template is <emphasis>produced</emphasis> (defined) using the
            <sgmltag class="starttag">xdm:template</sgmltag> tag, it is
            considered a <emphasis>global</emphasis> template (in the
            <emphasis>global</emphasis> namespace). A template may be defined
            and used within the same files or separated across files (meaning
            defined in one file and used later in another file).</para>
          </callout>

          <callout arearefs="xdm-template-name">
            <para>A template has a name.</para>
          </callout>

          <callout arearefs="xdm-template-param-optional">
            <para>A templates may contain optional parameters that can act as
            simple variable replacements. They are not as powerful as XSLT
            parameters but are much easier to define and use. Parameters must
            specify a <sgmltag>name</sgmltag> attribute and optionally specify
            a <sgmltag class="attribute">default</sgmltag> attribute. Template
            parameter names must be valid Java identifiers because they are
            treated as Java expressions.</para>
          </callout>

          <callout arearefs="xdm-template-param-required">
            <para>A template may contain parameters which are <sgmltag
            class="attribute">required</sgmltag>.</para>
          </callout>

          <callout arearefs="xdm-template-param-use">
            <para>Template parameters are used by enclosing them like this:
            <literal>${params.<replaceable>paramName</replaceable>}</literal>.
            Variable replacements only occur within attribute values and
            PCDATA. The text within <literal>${</literal> and
            <literal>}</literal> may be an expression. So, <literal>${params.param1
            + &#39; &#39; + params.param2}</literal> would be valid.</para>
          </callout>

          <callout arearefs="xdm-template-consume-generic">
            <para>A template is <emphasis>consumed</emphasis> or used by
            supplying the <sgmltag class="starttag">xdm:include</sgmltag> tag
            with an appropriate <sgmltag class="attribute">template</sgmltag>=<sgmltag
            class="attvalue">template-name</sgmltag> attribute or with custom
            tags defined by <emphasis>template consumers </emphasis>(see <xref
            linkend="xdm-template-producers" />). The actual action taken by
            the XDM processor when it encounters a template consumption
            request is to simply take the contents of the template producer,
            perform parameter replacements, and then replace the <sgmltag
            class="starttag">xdm:include</sgmltag> tag with the contents of
            the template producer so that the NEF never even encounters the
            <sgmltag class="starttag">xdm:include</sgmltag> tag.</para>
          </callout>
        </calloutlist>

        <section>
          <title id="xdm-template-producers">Template Producer and Consumer
          Tags</title>

          <para>Although the combination of the <sgmltag class="starttag">xdm:template</sgmltag>
          tag and the <sgmltag class="starttag">xdm:include</sgmltag> tag with
          an appropriate <sgmltag class="attribute">template</sgmltag>=<sgmltag
          class="attvalue">template-name</sgmltag> attribute for
          <emphasis>producing</emphasis> and <emphasis>consuming</emphasis>
          templates works quite well, it&#39;s not very elegant. If you use
          many templates in your XDM source files there may be a great deal of
          line noise and it may lead to unreadable code. For this reason, XDM
          provides two special purpose and customizable tags called
          <emphasis>Template Producers</emphasis> and <emphasis>Template
          Consumers</emphasis>.</para>

          <variablelist>
            <varlistentry>
              <term>Template Producers</term>

              <listitem>
                <para>Template Producers are custom tags that define (or
                <emphasis>produce</emphasis>) templates by providing a
                easier-to-read and understand tag instead of using the
                <sgmltag class="starttag">xdm:include</sgmltag> tag. Template
                Producers have the exact same features and provide the same
                functionality as if defined with the <sgmltag class="starttag">xdm:include</sgmltag>
                tag but custom Template Producers each have their own
                <emphasis>namespace</emphasis>. In the NEF the <sgmltag
                class="starttag">page-type</sgmltag>, <sgmltag
                class="starttag">field-type</sgmltag>, <sgmltag
                class="starttag">dialog-type</sgmltag>, <sgmltag
                class="starttag">data-type</sgmltag>, and <sgmltag
                class="starttag">table-type</sgmltag> tags are all examples of
                Template Producer custom tags. They provide no functionality
                other than defining some type-specific template and not useful
                until they are <emphasis>consumed</emphasis> by a Template
                Consumer.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Template Consumers</term>

              <listitem>
                <para>Template Consumers are custom tags that
                <emphasis>consume</emphasis> (or use) templates by providing
                an easier-to-read and understand tag instead of using the
                <sgmltag class="starttag">xdm:include</sgmltag> tag with an
                appropriate <sgmltag class="attribute">template</sgmltag>=<sgmltag
                class="attvalue">template-name</sgmltag> attribute. Template
                Consumers have the same features and functionality as the
                <sgmltag class="starttag">xdm:include</sgmltag> tag including
                the ability to pass in parameters but Template Consumers point
                to specific Template Producer <emphasis>namespaces</emphasis>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>
    </section>

    <section>
      <title id="section-value-sources">Value Sources</title>

      <para>Value sources are implementations of the <classname>com.netspective.commons.value.ValueSource</classname>
      interface that allows dynamic data to be included in XML without
      creating a programming language inside XML. There are many locations in
      the Project where value sources are used: configuration variables,
      forms/dialogs, form fields, form conditionals, SQL statements, and SQL
      bind parameters. Value sources allow common business logic and
      <emphasis>business values</emphasis> to be stored in shareable instance
      and then used either in XML or Java files where necessary. Value sources
      can be either single or multiple (list context) and are used anywhere
      dynamic data is required. The format of a value source is similar to a
      URL (<literal>name:params</literal>).</para>

      <figure>
        <title>Value Sources Overview</title>

        <mediaobject>
          <imageobject>
            <imagedata
            fileref="./resources/images/project-value-sources-overview.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Using Value Sources</title>

        <para>The best way to learn about Value Sources is to consider some
        examples. Although value sources are used throughout the NEF, some of
        the most common usage patterns will occur in the Sparx presentation
        layer (like Navigation pages and Dialogs) so the following examples
        focus on that layer.</para>

        <programlisting>&#60;dialog heading=&#34;<replaceable>session:myHeading</replaceable>&#34;&#62; <co
id="value-source-eg-1" />
    &#60;field type=&#34;text&#34; name=&#34;text-field&#34; caption=&#34;staticCaption&#34; default=&#34;<replaceable>request:varname</replaceable>&#34;/&#62; <co
id="value-source-eg-2" />
    &#60;field type=&#34;integer&#34; name=&#34;int-field&#34; caption=&#34;<replaceable>request:myCaption</replaceable>&#34; default=&#34;<replaceable>my-rule:some-value</replaceable>&#34;/&#62; <co
id="value-source-eg-3" />
    &#60;field type=&#34;select&#34; name=&#34;files&#34; caption=&#34;Files&#34; choices=&#34;<replaceable>filesystem-entries:/home/all</replaceable>&#34;/&#62; <co
id="value-source-eg-4" />
&#60;/dialog&#62;

&#60;navigation-tree name=&#34;abc&#34;&#62;
    &#60;page name=&#34;def&#34; caption=&#34;something&#34; heading=&#34;<replaceable>session:someVar</replaceable>&#34;/&#62; <co
id="value-source-eg-5" /></programlisting>

        <calloutlist>
          <callout arearefs="value-source-eg-1">
            <para>A dialog specification is defined to have a heading which
            will be dynamically generated at run-time from the value of the
            &#39;myHeading&#39; session attribute.</para>
          </callout>

          <callout arearefs="value-source-eg-2">
            <para>The text field will have a static caption, but its default
            value will come from a request parameter called &#39;varname&#39;.</para>
          </callout>

          <callout arearefs="value-source-eg-3">
            <para>In the integer field example, the caption and default will
            both be dynamic and the default value will actually come from a
            class that has been registered as &#39;my-rule&#39;.</para>
          </callout>

          <callout arearefs="value-source-eg-4">
            <para>In the select field example, this select field fills its
            choices with the files contained in the directory /home/all.</para>
          </callout>

          <callout arearefs="value-source-eg-5">
            <para>In the navigation-tree page example, the caption is static
            but the heading attribute will be dynamically retrieved from a
            session variable called someVar.</para>
          </callout>
        </calloutlist>
      </section>

      <section>
        <title>Catalog and Documentation of Value Sources</title>

        <para>The NEF ships with many built-in value sources and you can
        create as many value sources as you need on your own. To view a list
        of all of the value sources available to your project (including all
        built-in value sources and your own custom value sources) just go to
        Console&#39;s <menuchoice><guimenu>Project</guimenu><guimenuitem>Value
        Sources</guimenuitem></menuchoice> page.<screenshot><graphic
        fileref="./resources/images/screen-console-value-sources-catalog.gif" /></screenshot></para>
      </section>

      <section>
        <title id="value-contexts">Value Contexts</title>

        <para></para>
      </section>

      <section>
        <title>Static Values</title>

        <para>The simplest value source is known as the static value source –
        which is simply a wrapper for the Java String object. So, if an
        attribute accepts a value source, you can always supply a static
        string and it will be wrapped inside a <classname>com.netspective.commons.value.source.StaticValueSource</classname>
        class. For example, the following examples all produce the same
        results:</para>

        <programlisting>&#60;field.text caption=&#34;ABC&#34;/&#62;
&#60;field.text caption=&#34;static:ABC&#34;/&#62;
&#60;field.text caption=&#34;string:ABC&#34;/&#62;
&#60;field.text caption=”&#34;<classname>com.netspective.commons.value.source.StaticValueSource</classname>:ABC&#34;/&#62;</programlisting>
      </section>

      <section>
        <title>Parsing name:params Value Source Specifications</title>

        <para>The <classname>com.netspective.commons.value.ValueSources</classname>
        factory class is responsible for parsing value source specifications.
        The &#34;name&#34; portion of the value source refers to either a
        value source identifier (like &#34;session&#34; or &#34;request&#34;)
        or the full name of a class that exists in your classpath. You can
        escape a value source by using the <literal>\</literal> character in
        front of the <literal>:</literal> token. For example, if you’d like to
        create a string called &#34;<literal>name:params</literal>&#34; and
        not have it treated as a value source, use <literal>&#34;name\:params</literal>&#34;.
        Given a string of the format <literal>name:params</literal>, Sparx
        performs the following steps during the parse:</para>

        <procedure>
          <step>
            <para>Using the &#34;<literal>name</literal>&#34; portion of the
            declaration, check the <classname>com.netspective.commons.value.ValueSources</classname>
            factory class in the to see if it’s a built-in value source or has
            been registered separately by an application (it doesn’t matter if
            it’s a built-in source or one that you create and register
            yourself -- every value source is treated the same way).</para>
          </step>

          <step>
            <para>If the value source identifier (&#34;<literal>name</literal>&#34;)
            is found in the <classname>com.netspective.commons.value.ValueSources</classname>
            factory, get the associated class name (which must be a class that
            implements the <classname>com.netspective.commons.value.ValueSource</classname>
            interface). We will refer to this as the <emphasis>Value Source
            Class</emphasis>.</para>
          </step>

          <step>
            <para>If the value source identifier is not found in
            <classname>com.netspective.commons.value.ValueSources</classname>
            factory check to see if &#34;<literal>name</literal>&#34; is a
            class name by using the <function>Class.forName(&#34;name&#34;)</function>
            method. Assuming a class is found, we will refer to this as the
            <emphasis>Value Source Class</emphasis>.</para>
          </step>

          <step>
            <para>Using the <emphasis>Value Source Class</emphasis> found from
            either step 2 or step 3, check to see if there is already an
            instance created for the class. If there is an existing instance,
            use that instance (so that value sources may be shared). If there
            is no existing instance, instantiate a new object by constructing
            the <emphasis>Value Source Class</emphasis>, calling its
            <function>initializeSource()</function> method and passing in the
            &#34;<literal>params</literal>&#34; portion of the value source
            declaration and cache the object for future use.</para>
          </step>
        </procedure>
      </section>

      <section>
        <title>Registering a Value Source</title>

        <para>The following example shows how you can use the <sgmltag
        class="element">value-source</sgmltag> tag create your own value
        sources and register them so that the NEF will be able to use them.
        Assuming that you have created a class called <literal>MyValueSource</literal>
        that implements the <classname>com.netspective.commons.value.ValueSource</classname>
        inteface and have placed your class in the package <literal>my.value.source</literal>
        you can use the following declartion in your <filename>APP_ROOT/WEB-INF/sparx/project.xml</filename>
        file.</para>

        <programlisting>&#60;project&#62;
    &#60;value-source class=&#34;<replaceable>my.value.source.MyValueSource</replaceable>&#34;/&#62;</programlisting>
      </section>
    </section>

    <section>
      <title>Commands</title>

      <para>Commands are Java classes that implement the
      <classname>com.netspective.commons.command.Command</classname> interface
      and execute arbitrary tasks defined either by you or the framework. They
      are used to encapsulate common logic and reuse that logic across pages
      and dialogs/forms.</para>
    </section>

    <section>
      <title>Ant Build Scripts</title>

      <para>NEF provides a series of scripts that, among other functions,
      allow you to compile your application, generate code, and upgrade NEF
      libraries and components.</para>

      <section>
        <title>Executing Ant Scripts Through Console</title>

        <para></para>
      </section>

      <section>
        <title>Executing Ant Scripts From the Command Line</title>

        <para></para>
      </section>

      <section>
        <title>Automatically Executing Ant Scripts in Navigation Controller</title>

        <para></para>
      </section>
    </section>

    <section>
      <title>Runtime Environments</title>

      <para>NEF supports the notion of <emphasis>runtime environments</emphasis>
      like <literal>Development</literal>, <literal>Testing</literal>, and
      <literal>Production</literal>. When in the <literal>Development</literal>
      environment, XML-based resource files like dialogs, schemas, SQL, and
      others are automatically reloaded. In <literal>Testing</literal> and
      <literal>Production</literal> environments automatic reloading is not
      enabled. Your applications can use the environment setting to make
      appropriate decisions about data sources and other environment-specific
      settings (like throwing exceptions in a development environment but
      e-mailing errors in testing or production). The following environment
      flags are available (they can be mixed but some mixtures won&#39;t make
      sense):</para>

      <variablelist>
        <varlistentry>
          <term>DEVELOPMENT</term>

          <listitem>
            <para>This is the default environment in which all components like
            dialogs, queries, and such are reloaded when their sources change.
            This is the only runtime environment in which files are reloaded.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>TESTING</term>

          <listitem>
            <para>Specifies a test environment.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>TRAINING</term>

          <listitem>
            <para>Specifies a training environment.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>PRODUCTION</term>

          <listitem>
            <para>Specifies a production environment.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>DEMONSTRATION</term>

          <listitem>
            <para>Specifies a demonstration environment.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>UNDERGOING_MAINTENANCE</term>

          <listitem>
            <para>Specifies that whichever environment is currently the active
            one is undergoing maintenance. This is useful so that controller
            servlets don&#39;t allow use of application resources while the
            app is undergoing maintenance.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <section>
        <title>Viewing the Active Runtime Environment</title>

        <para>The active runtime environment may be viewed by going to the
        Console Home Page for the application in question. The current runtime
        environment is available within your Java applications by using the
        <function>ValueContext.getRuntimeEnvironmentFlags()</function> method
        from any value context instance like NavigationContext or
        DialogContext (see <xref linkend="value-contexts" xreflabel="" /> for
        more information).<screenshot><graphic
        fileref="./resources/images/screen-console-home-runtime-env-highlight.gif" /></screenshot></para>
      </section>

      <section>
        <title>Changing the Runtime Environment</title>

        <para>If you&#39;d like to modify the runtime environment flags, do
        the following:</para>

        <procedure>
          <step>
            <para>Open your application&#39;s web.xml file (<filename>WEB-INF/web.xml</filename>).</para>
          </step>

          <step>
            <para>Add or modify the <literal>com.netspective.sparx.navigate.CONTROLLER_SERVLET_OPTIONS</literal>
            servlet init parameter for your application&#39;s navigation
            controller. The parameter may be set to a single value or may
            contain multiple flags separated using the &#39;|&#39; character.</para>

            <example>
              <title>Changing Application Runtime Environment Flags to
              Production</title>

              <programlisting>&#60;web-app&#62;
      ...
    &#60;servlet&#62;
        &#60;servlet-name&#62;SparxNavigationController&#60;/servlet-name&#62;
        &#60;servlet-class&#62;com.netspective.sparx.navigate.NavigationControllerServlet&#60;/servlet-class&#62;
        &#60;init-param&#62;
            &#60;param-name&#62;com.netspective.sparx.navigate.CONTROLLER_SERVLET_OPTIONS&#60;/param-name&#62;
            &#60;param-value&#62;<emphasis role="bold">--runtime-environment=PRODUCTION</emphasis>&#60;/param-value&#62;
        &#60;/init-param&#62;
    &#60;/servlet&#62;
      ...
&#60;/web-app&#62;</programlisting>
            </example>

            <example>
              <title>Changing Application Runtime Environment Flags to
              Production Maintenance</title>

              <programlisting>&#60;web-app&#62;
      ...
    &#60;servlet&#62;
        &#60;servlet-name&#62;SparxNavigationController&#60;/servlet-name&#62;
        &#60;servlet-class&#62;com.netspective.sparx.navigate.NavigationControllerServlet&#60;/servlet-class&#62;
        &#60;init-param&#62;
            &#60;param-name&#62;com.netspective.sparx.navigate.CONTROLLER_SERVLET_OPTIONS&#60;/param-name&#62;
            &#60;param-value&#62;<emphasis role="bold">--runtime-environment=&#34;PRODUCTION | UNDERGOING_MAINTENANCE&#34;</emphasis>&#60;/param-value&#62;
        &#60;/init-param&#62;
    &#60;/servlet&#62;
      ...
&#60;/web-app&#62;</programlisting>
            </example>

            <note>
              <para>To learn more about the other controller servlet options
              allowed by Sparx, visit Console&#39;s <menuchoice><guimenu>Project</guimenu><guimenuitem>Configuration</guimenuitem></menuchoice>
              page.</para>
            </note>
          </step>
        </procedure>
      </section>
    </section>

    <section>
      <title>Sharing of NEF Objects Across Threads</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Project Presentation Layer Declarations</title>

    <para></para>

    <section>
      <title>Navigation</title>

      <para></para>
    </section>

    <section>
      <title>Forms and Dialogs</title>

      <para></para>

      <section id="dialogs">
        <title>Overview</title>

        <para>The first step in developing a web application is giving the
        user the ability to enter data and retrieve data.
        <trademark>Sparx</trademark>&#39;s answer to this is the
        <emphasis>Dialog</emphasis> object; it is through the Dialogs that a
        user can create new data, edit existing data, and remove data. A
        <trademark>Sparx</trademark> Dialog object provides a multitude of
        features such as client-side/server-side data verifications and
        validations, dialog state tracking, and skin association.</para>

        <para>Defining the dialog in the Project File s the first step towards
        creating a dialog. Dialogs are defined with the <emphasis role="bold">&#60;dialog&#62;</emphasis>
        tag and each dialog must belong to a package of dialogs represented by
        <emphasis role="bold">&#60;dialogs&#62;</emphasis> tag. The following
        is a sample dialog entry from the <emphasis>web-cura</emphasis> sample
        application: <programlisting>
    &#60;dialogs package=&#34;train&#34;&#62;
        &#60;dialog name=&#34;test&#34; heading=&#34;Add Account&#34;&#62;
            &#60;field.text name=&#34;org_code&#34; caption=&#34;Account Code&#34; required=&#34;yes&#34; default=&#34;request:myval&#34;/&#62;
            &#60;field.select name=&#34;org_type&#34; caption=&#34;Type&#34; style=&#34;multidual&#34; choices=&#34;query:org.enum-types-all&#34;/&#62;
            &#60;field.integer name=&#34;employees&#34; caption=&#34;Employees&#34; min=&#34;10&#34; max=&#34;20&#34;/&#62;
        &#60;/dialog&#62;
    &#60;/dialogs&#62;
        </programlisting></para>
      </section>

      <section id="Dialogs-DataFields">
        <title>Dialog Fields</title>

        <para>One can think of a dialog as a container/manager object
        consisting of data fields which have their own behaviors and
        properties. These data fields provide the flexibility to create
        customized forms for data processing and it also provides the ability
        to create new fields or modify existing ones. Currently the following
        general fields are available: <itemizedlist><listitem><para>Text</para></listitem><listitem><para>Integer</para></listitem><listitem><para>Float</para></listitem><listitem><para>Date
        and Time</para></listitem><listitem><para>List</para></listitem><listitem><para>Checkbox</para></listitem><listitem><para>Radio
        Buttons</para></listitem></itemizedlist> Based on the fields listed
        above, there are fields which serve a more specific role also:
        <itemizedlist><listitem><para>Blood Pressure</para></listitem><listitem><para>Social
        Security Number</para></listitem><listitem><para>Phone Number</para></listitem></itemizedlist>
        All available fields can be seen in ACE:</para>

        <para>Every type of field available has its own both client-side and
        server-side validation features. For example, an integer field allows
        only numerical values into the field and a social security number
        field only allows dashes and numeric digits. Aside from using the
        built-in fields, <trademark>Sparx</trademark> provides a way to create
        new fields using the <trademark>XAF</trademark>&#39;s Java class
        called <classname>com.xaf.form.DialogField</classname>. The following
        is a sample class definition for creating a dialog field:
        <programlisting>

import com.xaf.form.*;

public class NewField extends com.xaf.form.DialogField
{
    ...
    ..
}

        </programlisting> The following XML entry must be added to the
        dialog&#39;s package so that the dialog can access the field. The
        following is an example of a dialog using the <classname>NewField</classname>:
        <programlisting>

    &#60;dialogs package=&#34;Test&#34;&#62;
        &#60;register-field class=&#34;NewField&#34; tag-name=&#34;field.newfield&#34;/&#62;
        &#60;dialog name=&#34;TestNewField&#34; heading=&#34;Test New Field&#34;&#62;
            &#60;field.newfield name=&#34;new_field&#34; caption=&#34;My New Field&#34; ... /&#62;
            ....
            ...
        &#60;/dialog&#62;
    &#60;/dialogs&#62;

        </programlisting> As shown above, the XML tag <sgmltag
        class="starttag">register-field</sgmltag> is used to register the new
        field. The attribute <sgmltag class="attribute">class</sgmltag> is
        used to define the Java class for the new field and the <sgmltag
        class="attribute">tag-name</sgmltag> attribute is used to define the
        XML tag name. <note><para>Any new field being created must have an XML
        element name that beings with <quote>field.</quote></para></note></para>

        <section>
          <title>Examples</title>

          <para><example><title>Text, Static, Integer, Float, SSN, and Zip
          fields</title><para>The following is an example of a dialog
          containing general fields such as text, static, integer, float and
          specialized fields such as social security number and zip code.
          <programlisting>

&#60;dialog  name=&#34;Test1&#34; heading=&#34;Test Fields&#34; retain-params=&#34;*&#34;&#62;
    &#60;field.separator heading=&#34;Text Fields&#34;/&#62;
    &#60;field.text name=&#34;text_field_hidden&#34; hidden=&#34;yes&#34; default=&#39;request:id&#39;/&#62;
    &#60;field.static name=&#34;static_field&#34; default=&#39;Static Field&#39;/&#62;
    &#60;field.text name=&#34;text_field_required&#34; caption=&#34;Text Required&#34;
        hint=&#34;Text field required&#34; required=&#34;yes&#34;/&#62;
    &#60;field.text name=&#34;text_field&#34; caption=&#34;Text&#34; hint=&#34;Text field optional&#34;
        max-length=&#34;5&#34; uppercase=&#34;yes&#34;/&#62;
    &#60;field.text name=&#34;text_field_email&#34; caption=&#34;Text Email&#34;
        hint=&#34;Text field with regular expression checking&#34;
        validate-pattern=&#34;/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/&#34;
        validate-msg=&#34;Invalid email format.&#34;/&#62;
    &#60;field.email name=&#34;email_field&#34; caption=&#34;Email&#34;/&#62;
    &#60;field.ssn name=&#34;ssn_field&#34; caption=&#34;SSN&#34;/&#62;

    &#60;field.separator heading=&#34;Numeric Fields&#34;/&#62;
    &#60;field.integer name=&#34;integer_field&#34; caption=&#34;Integer Field&#34; hint=&#34;Integer field&#34;/&#62;
    &#60;field.float name=&#34;float_field&#34; caption=&#34;Float Field&#34; hint=&#34;Float field&#34;/&#62;
    &#60;field.zip name=&#34;zip_field&#34; caption=&#34;Zip Field&#34; hint=&#34;Zip code field&#34;/&#62;
    &#60;director submit-caption=&#34;Submit&#34;/&#62;
&#60;/dialog&#62;

                </programlisting> The above example contains multiple fields
          of various types and some of the attributes available for the
          different types. The attribute <sgmltag class="attribute">retain-params</sgmltag>
          of the <sgmltag class="starttag">dialog</sgmltag> tag is useful for
          retaining field values (whether they were entered by the user or
          from value sources) as the dialog goes through its different stages
          before execution. The default values for the dialog fields can be
          empty or they can be specified in the XML file. The attribute
          <sgmltag class="attribute">default</sgmltag> is available for
          specifying the default value and it can either be a static value or
          it can be a value source. In the example above, the hidden text
          field called <emphasis>text_field_hidden</emphasis> gets its value
          from a request parameter value source while the static field called
          <emphasis>static_field</emphasis> gets its value as a plain string.
          Most dialog fields have an attribute called <sgmltag
          class="attribute">hint</sgmltag> which is used to display a helpful
          hint for the user on what to enter into the field. The following is
          a screenshot of how the actual dialog looks like:</para><para><mediaobject><imageobject><imagedata
          fileref="./resources/images/dialogs/test1.jpg" format="JPEG" /></imageobject></mediaobject></para></example>
          <example><title>Memo, Date &#38; Time, Boolean fields</title><para>The
          following is a definition for a dialog which contains a memo field,
          several versions of the date and time field, and several versions of
          the boolean field: <programlisting>

&#60;dialog name=&#34;Test2&#34; heading=&#34;Test Fields&#34; retain-params=&#34;*&#34;&#62;
    &#60;field.separator name=&#34;Memo&#34; heading=&#34;Memo&#34;/&#62;
    &#60;field.memo name=&#34;memo_field_01&#34; caption=&#34;Memo Field&#34;
        max-length=&#34;5&#34;
        hint=&#34;Max length is 5 characters&#34;/&#62;
    &#60;field.separator name=&#34;date_time_section&#34; heading=&#34;Date and Time Fields&#34;/&#62;
    &#60;field.duration name=&#34;duration&#34; caption=&#34;Duration Field&#34;
        hint=&#34;Format is MM/dd/yyyy&#34;/&#62;
    &#60;field.date name=&#34;date_field_strict&#34; caption=&#34;Date (Strict Year)&#34;
        format=&#34;MM-dd-yyyy&#34;
        default=&#34;today&#34;
        hint=&#34;Format is MM-dd-yyyy&#34;/&#62;
    &#60;field.date name=&#34;date_field_nonstrict&#34; caption=&#34;Date (Non-Strict Year)&#34;
        format=&#34;MM/dd/yyyy&#34;
        strict-year=&#34;no&#34;
        default=&#34;today+1&#34;
        hint=&#34;Format is MM/dd/yyyy&#34;/&#62;
    &#60;field.time name=&#34;time_field&#34; caption=&#34;Time&#34;
        initial-focus=&#34;yes&#34;
        default=&#34;now&#34;
        hint=&#34;Format is HH:mm&#34;/&#62;
    &#60;field.separator heading=&#34;Boolean Fields&#34;/&#62;
    &#60;field.boolean name=&#34;bool_field_radio&#34; caption=&#34;Boolean Field (Radio)&#34; style=&#34;radio&#34;/&#62;
    &#60;field.boolean name=&#34;bool_field_alone&#34; caption=&#34;Boolean Field (Alone)&#34; style=&#34;checkalone&#34;/&#62;
    &#60;field.boolean name=&#34;bool_field_combo&#34; caption=&#34;Boolean Field (Combo)&#34; style=&#34;combo&#34;/&#62;
    &#60;director submit-caption=&#34;Submit&#34;/&#62;
&#60;/dialog&#62;

                </programlisting> <variablelist><varlistentry><term><sgmltag
          class="element">field.memo</sgmltag></term><listitem><para>The
          <sgmltag class="starttag">field.memo</sgmltag> is based on the HTML
          TEXTAREA element and the attribute <sgmltag class="attribute">max-length</sgmltag>
          is used to enforce the maximum number of characters allowed in the
          memo field. Javascript client-side validations are done to enforce
          the maximum number of characters allowed.</para></listitem></varlistentry><varlistentry><term><sgmltag
          class="element">field.duration</sgmltag></term><listitem><para>The
          duration field, <sgmltag class="starttag">field.duration</sgmltag>,
          is used to allow entry of a begin date and an end date. It has
          client-side validations to make sure that the date values are valid
          and that beginning date field is before the end date field.</para></listitem></varlistentry><varlistentry><term><sgmltag
          class="element">field.date</sgmltag></term><listitem><para>By
          default date fields, <sgmltag class="starttag">field.date</sgmltag>
          do not allow 2-digit years and this can be changed by setting the
          attribute <sgmltag class="attribute">strict-year=&#34;no&#34;</sgmltag>.
          Also the format of a date field can be specified by setting the
          attribute <sgmltag class="attribute">format</sgmltag>. The value for
          <sgmltag class="attribute">format</sgmltag> is based on the
          <classname>java.text.SimpleDateFormat</classname>&#39;s pattern
          strings. The date field also has a built-n client-side formatting
          feature which will automatically format the user entered value: user
          enters 11021999 and it gets displayed as 11/02/1999. The default
          value of the date field accepts special strings such as &#34;<emphasis>today</emphasis>&#34;
          and &#34;<emphasis>now</emphasis>&#34; and interprets them as
          present date. Any numerical operation defined after the special
          string is used to recalculate the default date (for example, &#34;<emphasis>today+1</emphasis>&#34;
          will display tomorrow&#39;s date)</para></listitem></varlistentry><varlistentry><term><sgmltag
          class="element">field.time</sgmltag></term><listitem><para>The time
          field, <sgmltag class="starttag">field.time</sgmltag>, is used to
          allow entry of a time value. It has client-side validations to make
          sure that the time entered is valid. It also accepts the special
          string &#34;<emphasis>now</emphasis>&#34; as a default value.</para></listitem></varlistentry><varlistentry><term><sgmltag
          class="element">field.boolean</sgmltag></term><listitem><para>The
          boolean field, <sgmltag class="starttag">field.boolean</sgmltag>,
          represents different HTML elements: a single checkbox, a Yes/No
          select list, and a Yes/No radio buttons. These different elements
          are represented by the <sgmltag class="attribute">style</sgmltag>
          attribute with the following values respectively:
          <emphasis>radio</emphasis>, <emphasis>checkalone</emphasis>, and
          <emphasis>combo</emphasis>. A &#34;No&#34; selection submits a value
          of 0 and a &#34;Yes&#34; selection submits a value of 1.</para></listitem></varlistentry></variablelist>
          The XML definition above is shown as:</para><para><mediaobject><imageobject><imagedata
          fileref="./resources/images/dialogs/test2.jpg" format="JPEG" /></imageobject></mediaobject></para></example>
          <example><title>Select fields</title><para>The following is a XML
          definition example to show the different styles available for select
          fields: <programlisting>

&#60;dialog name=&#34;Test3&#34; heading=&#34;Test Fields&#34; retain-params=&#34;*&#34;&#62;
    &#60;field.separator heading=&#34;Select Fields&#34; /&#62;
    &#60;field.select name=&#34;sel_field_combo&#34; read-only=&#34;no&#34; caption=&#34;Select Field (Combo)&#34;
        style=&#34;combo&#34; choices=&#34;Choice 1=A;Choice 2=B;Choice 3=C&#34; prepend-blank=&#34;yes&#34; append-blank=&#34;yes&#34;
        /&#62;
    &#60;field.select name=&#34;sel_field_radio&#34; read-only=&#34;no&#34; caption=&#34;Select Field (Radio)&#34;
        style=&#34;radio&#34; choices=&#34;Choice 1=A;Choice 2=B;Choice 3=C&#34; default=&#34;A&#34;/&#62;
    &#60;field.select name=&#34;sel_field_list&#34; read-only=&#34;no&#34; caption=&#34;Select Field (List)&#34;
        style=&#34;list&#34; size=&#34;5&#34; choices=&#34;Choice 1=A;Choice 2=B;Choice 3=C&#34; default=&#34;A&#34;/&#62;
    &#60;field.select name=&#34;sel_field_multilist&#34; read-only=&#34;no&#34; caption=&#34;Select Field (MultiList)&#34;
        style=&#34;multilist&#34; size=&#34;5&#34; choices=&#34;Choice 1=A;Choice 2=B;Choice 3=C&#34;
        default=&#34;A&#34;/&#62;
    &#60;field.select name=&#34;sel_field_multicheck&#34; read-only=&#34;no&#34; caption=&#34;Select Field (MultiCheck)&#34;
        style=&#34;multicheck&#34; choices=&#34;Choice 1=A;Choice 2=B;Choice 3=C&#34; default=&#34;B&#34;/&#62;
    &#60;field.select name=&#34;sel_field_multidual&#34; read-only=&#34;no&#34; caption=&#34;Select Field (MultiDual)&#34;
        style=&#34;multidual&#34; choices=&#34;Choice 1=A;Choice 2=B;Choice 3=C&#34; caption-left=&#34;Left Caption&#34;
        caption-right=&#34;Right Caption&#34; multi-width=&#34;100&#34;
        default=&#34;A&#34;/&#62;
     &#60;director submit-caption=&#34;Submit&#34;/&#62;
&#60;/dialog&#62;

                    </programlisting> The XML tag, <sgmltag class="starttag">field.select</sgmltag>,
          is based upon the SELECT HTML element. It can be used as a list
          capable of allowing the user to choose one selection or multiple
          selections based on the configuration. There are six styles of
          selection list available (<emphasis>combo</emphasis>,
          <emphasis>radio</emphasis>, <emphasis>list</emphasis>,
          <emphasis>multilist</emphasis>, <emphasis>multicheck</emphasis>, and
          <emphasis>multidual</emphasis>) and they can be defined using the
          <sgmltag class="attribute">style</sgmltag> attribute. The
          <emphasis>multilist</emphasis>, <emphasis>multicheck</emphasis>, and
          <emphasis>multidual</emphasis> styles allow a selection of more than
          one option.</para><para>The choices available for a selection are
          defined by the <sgmltag class="attribute">choices</sgmltag>
          attribute. The syntax for the choices is <emphasis>choice_1=value_1;choice_2=value_2;...</emphasis>
          where the <emphasis>choice_x</emphasis> is the displayed choice and
          the <emphasis>value_x</emphasis> is the actual value that is
          submitted. There is another way to define the choices available for
          a selection and it is by using a value source called
          <emphasis>query</emphasis>. This way builds the option list from the
          result of a static query (the query must be defined elsewhere in the
          Project File). For example, the following SQL can be used as
          <emphasis>choices=&#34;query:test.user_list</emphasis> attribute
          setting: <programlisting>

&#60;sql-statements package=&#34;test&#34;&#62;
    &#60;statement name=&#34;user_list&#34;&#62;
        select
            name,
            id
        from User
    &#60;/statement&#62;
&#60;/sql-statements&#62;

                    </programlisting> The above SQL&#39;s
          <emphasis>name</emphasis> and <emphasis>id</emphasis> result will be
          used to construct a choice list with the <emphasis>name</emphasis>
          entry being the displayed string and the corrsponding
          <emphasis>id</emphasis> being the submitted value. There are two
          other attributes that effect the display of the choices for
          selection and they are <sgmltag class="attribute">prepend-blank</sgmltag>
          and <sgmltag class="attribute">append-blank</sgmltag>. The
          functionality of these two attributes is to prepend a blank to the
          choice list and to append a blank to the choice list respectively.
          The following is a screenshot of the dialog defined above:</para><para><mediaobject><imageobject><imagedata
          fileref="./resources/images/dialogs/test3.jpg" format="JPEG" /></imageobject></mediaobject></para></example>
          <example><title>Conditional fields</title><para><trademark>XAF</trademark>
          provides a dynamic field displaying and hiding functionality which
          is defined by the <sgmltag class="starttag">conditional </sgmltag>
          XML element. The following is an example dialog definition:
          <programlisting>

        &#60;dialog name=&#34;Test6&#34; heading=&#34;Test Conditionals&#34; loop=&#34;yes&#34;&#62;
            &#60;field.select name=&#34;sel_field_list&#34; caption=&#34;Select Field (Combo)&#34; style=&#34;combo&#34;
                size=&#34;5&#34; choices=&#34;-;Choice 1=A;Choice 2=B;Choice 3=C&#34;/&#62;
            &#60;field.text name=&#34;text_field&#34; caption=&#34;Hidden Text&#34; default=&#34;Here I am!&#34;&#62;
                &#60;conditional action=&#34;display&#34; partner=&#34;sel_field_list&#34;
                 js-expr=&#34;control.selectedIndex != 0&#34;/&#62;
            &#60;/field.text&#62;
            &#60;field.boolean name=&#34;checkbox_field&#34; caption=&#34;Checkbox&#34; style=&#34;checkalone&#34; /&#62;
            &#60;field.static name=&#34;static_field2&#34; default=&#34;Checkbox checked!&#34;&#62;
                &#60;conditional action=&#34;display&#34; partner=&#34;checkbox_field&#34;
                 js-expr=&#34;control.checked == true&#34;/&#62;
            &#60;/field.static&#62;
        &#60;/dialog&#62;

                    </programlisting> In the above example, the text field
          named <emphasis>text_field</emphasis> is dependent upon the select
          field named <emphasis>sel_field_list</emphasis>. This is done by
          adding the <sgmltag class="starttag">conditional</sgmltag> element
          as a child node to the text field and setting the attribute <sgmltag
          class="attribute">partner</sgmltag> to the name of the select field.
          The condition for displaying the text field is created by setting
          the <sgmltag class="attribute">js-expr</sgmltag> (Javascript
          expression) attribute. In the definition above, the text field named
          <emphasis>text_field</emphasis> will only be displayed if the
          selected option of the <emphasis>sel_field_list</emphasis> is not
          the first option.</para><para>The second conditional field of the
          dialog is a static field named <emphasis>static_field</emphasis> and
          its&#39; display status is dependent upon the <emphasis>checkbox_field</emphasis>
          being &#34;checked&#34;. The following is a screen shot of the
          initial stage of the dialog:</para><para><mediaobject><imageobject><imagedata
          fileref="./resources/images/dialogs/test6_1.jpg" format="JPEG" /></imageobject></mediaobject></para><para>The
          following is a screen shot of the dialog after the select
          field&#39;s selection has been changed:</para><para><mediaobject><imageobject><imagedata
          fileref="./resources/images/dialogs/test6_2.jpg" format="JPEG" /></imageobject></mediaobject></para><para>The
          following is a screen shot of the dialog after the checkbox has been
          checked:</para><para><mediaobject><imageobject><imagedata
          fileref="./resources/images/dialogs/test6_3.jpg" format="JPEG" /></imageobject></mediaobject></para><para>Aside
          from the <sgmltag class="attribute">action</sgmltag> attribute,
          there are other useful attributes available such as <sgmltag
          class="attribute">apply-flag</sgmltag> and <sgmltag
          class="attribute">clear-flag</sgmltag>. The following values are
          available for these two attributes: For setting or removing these
          flags depend upon other attributes such as <sgmltag
          class="attribute"> data-cmd</sgmltag>, <sgmltag class="attribute">has-permission</sgmltag>,
          and <sgmltag class="attribute">lack-permission</sgmltag>. The
          <sgmltag class="attribute">data-cmd</sgmltag> is used to indicate
          the dialog data mode (add, edit, or delete) in which the defined
          flag should be cleared or set. The <sgmltag class="attribute">has-permission</sgmltag>
          and <sgmltag class="attribute"> lack-permission</sgmltag> attributes
          are used to modify the flag dependent upon the security access level
          of the user. These two attributes can only be used when
          <trademark>XAF</trademark>&#39;s security access control list is
          being used.</para></example> <example><title>Popup field</title><para><trademark>Sparx</trademark>
          provides a feature to display a popup dialog box when a popup icon
          is clicked and values from a selection in the popup can be returned
          to the main window. The following XML definition creates a field
          that has a popup dialog associated with it:
          <programlisting>

    &#60;dialog name=&#34;Test7&#34; heading=&#34;Test Popup&#34; loop=&#34;yes&#34;&#62;
        &#60;field.text name=&#34;text_field_1&#34; caption=&#34;Text Field 1&#34; /&#62;
        &#60;field.text name=&#34;text_field_2&#34; caption=&#34;Text Field 2&#34; read-only=&#34;browser&#34;
            hint=&#34;Click on the icon to select a value&#34;&#62;
            &#60;popup action=&#34;create-app-url:/textJS.html&#34; fill=&#34;text_field_1,text_field_2&#34;/&#62;
        &#60;/field.text&#62;
    &#60;/dialog&#62;

                    </programlisting> The above example displays a dialog with
          a text field named <emphasis>text_field_2</emphasis> which cannot be
          filled in by the user but can only be filled in from a popup box
          associated with it. By clicking on the popup icon (<inlinemediaobject><imageobject><imagedata
          fileref="../../resources/images/dialog/magnifying-glass-sm.gif"
          format="GIF" /></imageobject></inlinemediaobject>) the URL defined
          as the action, <literal>textJS.html</literal>, will be displayed in
          a popup window. The process through a value or multiple values being
          returned into the <emphasis>text_field_2</emphasis> is to invoke a
          Javascript method called <literal>populateValues()</literal>
          provided by <trademark>Sparx</trademark>. The following is an
          example of a HTML string to invoke the Javascript method:
          <programlisting>

    &#60;input type=&#34;button&#34; value=&#34;OK&#34; onClick=&#34;populateValues(&#39;This is the filled in text!&#39;);&#34;/&#62;

                    </programlisting></para></example></para>
        </section>
      </section>

      <section>
        <title>Dialog State Management</title>

        <para></para>

        <section>
          <title>Transactions</title>

          <para>All Sparx dialogs have unique identifiers at both development
          and run-time. Features are provided to prevent duplicate data entry
          through the use of Dialog Transactions (preventing users from
          hitting the &#34;back&#34; button and re-running an older
          transaction).</para>
        </section>
      </section>

      <section>
        <title>Dialog Field Data Binding</title>

        <para>Using Value Sources, Sparx provides automatic SQL, a web
        service, or other data binding to any list controls in HTML or DHTML.
        This allows, for instance a query to be run and automatically create
        text fields, a list box, radio buttons, check boxes, and multi-select
        list boxes. All dialog fields have this dynamic data binding
        capability so that arbitrary data sources can populate dialog contents
        and selections.</para>
      </section>

      <section>
        <title>Dialog Execute Handlers</title>

        <para></para>
      </section>

      <section id="Dialogs-DataCommands">
        <title>Dialog Perspectives</title>

        <para>One of the common usage of dialogs is to create, modify, and
        delete the same data such as users, orders, and contact information.
        The differences between these dialogs are minor in a sense that they
        all tend to display the same fields (but in different modes such as
        read-only or unavailable). To avoid defining the same dialog three
        times (with slight variations in field attributes) just to provide
        create, edit, and delete functionality of the same data, Sparx
        provides a feature called <emphasis>dialog data perspectives</emphasis>.
        A dialog functions differently based upon the data command it
        receives; for example, it can display fields as read only when the
        data command is delete and it can hide some fields when the data
        perspective is add. As hinted above, Sparx ialogs recognizes the
        following data perspectives:</para>

        <variablelist>
          <varlistentry>
            <term>add</term>

            <listitem>
              <para>Indicates that the dialog should be processed for
              adding/inserting records.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>edit</term>

            <listitem>
              <para>Indicates that the dialog should be processed for
              editing/updating records. This perspective will automatically
              make any primary-keys read-only.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>delete</term>

            <listitem>
              <para>Indicates that the dialog should be processed for
              deleting/removing records. This perspective will automatically
              make all fields read-only (for confirmation) and allow
              submission.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>print</term>

            <listitem>
              <para>Indicates that the dialog should be processed for printing
              data. All the items become read-only and a few tweaks are made
              so that the dialog looks more like a report than a form.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>confirm</term>

            <listitem>
              <para>Indicates that the dialog should be processed for
              confirming data. This perspective will automatically make all
              fields read-only (for confirmation) but does not infer a further
              action.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Dialog data perspectives are recognized by the dialog in two
        ways: as a request parameter or as a request attribute called
        <varname>data_cmd</varname>. The dialog behaves in different ways
        according to the data command by changing the name of the submit
        action button and also making all the fields read only for the
        <emphasis>delete</emphasis> mode. By default, there is very little
        difference in the behavior of the dialog when it is in either the
        <emphasis>add</emphasis> or <emphasis>edit</emphasis>. The
        funtionality of the <emphasis>add</emphasis> or <emphasis>edit</emphasis>
        modes are enhanced more through the power of the conditional fields
        assigned to the dialog. Conditional fields can be configured to depend
        upon the mode the dialog is in so that fields can be read-only or
        unavailable.</para>

        <example>
          <title>Conditional fields dependent upon the Dialog&#39;s data mode</title>

          <programlisting>&#60;dialog ...&#62;
    ...
    &#60;field type=&#34;text&#34; name=&#34;text_field_1&#34; caption=&#34;Text Field&#34; size=&#34;50&#34;
           hint=&#34;Read-only when ADD&#34; default=&#34;I guess the perspective is not &#39;add&#39;&#34;&#62;
        &#60;conditional action=&#34;apply-flags&#34; flags=&#34;read-only&#34; perspective=&#34;add&#34;/&#62;
    &#60;/field&#62;

    &#60;field type=&#34;static&#34; name=&#34;static_field_4&#34; default=&#34;The perspective is not &#39;add&#39; or &#39;edit&#39;&#34;&#62;
        &#60;conditional action=&#34;apply-flags&#34; flags=&#34;unavailable&#34; perspective=&#34;add | edit&#34;/&#62;
    &#60;/field&#62;
    ...
&#60;/dialog&#62;   </programlisting>
        </example>

        <para>In the above dialog definition, the select field<sgmltag
        class="attvalue">org_type</sgmltag> and <sgmltag class="attvalue">org_industry</sgmltag>
        has conditions defined based upon the mode of the dialog. When the
        dialog is in edit or delete mode, the <emphasis>unavailable</emphasis>
        flag is applied to the fields. For more information on conditional
        fields, go to <xref linkend="Dialogs-DataFields" />. As mentioned
        before, a data command can be passed to the dialog through a request
        parameter by appending a query string after the URL,
        <literal>http:\\myapp\index.jsp?data_cmd=add</literal>. A request
        attribute can also be used to pass the data command as shown in the
        JSP example below:</para>

        <example>
          <title>Setting a data command</title>

          <programlisting>&#60;%
                    request.setAttribute(&#34;data_cmd&#34;, &#34;add&#34;); %&#62;
                    &#60;xaf:dialog name=&#34;registration&#34; /&#62;</programlisting>
        </example>
      </section>

      <section id="Testing-Dialog">
        <title>Testing the dialog</title>

        <section>
          <title>Unit Testing</title>

          <para>All dialogs defined in the Project File are listed in the
          Console under the <menuchoice role="bold"><guimenu>Presentation</guimenu><guimenuitem>Dialogs</guimenuitem></menuchoice>
          menu item.</para>

          <para><mediaobject><imageobject><imagedata
          fileref="./resources/images/dialogs/ace-dialogs.jpg" format="JPEG" /></imageobject></mediaobject></para>

          <para>Clicking on the Action icon of any dialog displays a test page
          with the dialog in it. Each dialog can be tested by entering values
          for the dialog and then pressing the OK button:</para>

          <para><mediaobject><imageobject><imagedata
          fileref="./resources/images/dialogs/ace-testdialog.jpg"
          format="JPEG" /></imageobject></mediaobject></para>

          <para>This will display the entered values:</para>

          <para><mediaobject><imageobject><imagedata
          fileref="./resources/images/dialogs/ace-testresult.jpg"
          format="JPEG" /></imageobject></mediaobject></para>
        </section>
      </section>

      <section id="Using-Dialog">
        <title>Using the dialog</title>

        <para><trademark>Sparx</trademark> provides convenient yet flexible
        ways to use and enhance the behavior of Dialog objects. The most
        common usage of a dialog is to define the dialog in the
        <filename>WEB-INF/ui/dialog.xml</filename> file and then to use the
        JSP custom tag <emphasis role="bold">&#60;xaf:dialog&#62;</emphasis>
        to invoke the dialog. <programlisting>

    &#60;xaf:dialog name=&#34;test.Test1&#34;/&#62;

            </programlisting> This utilizes the built-in functionality and
        behavior of a <trademark>Sparx</trademark> dialog. The user does not
        need to be concerned with various processes of a HTML form submittal
        such as data validations, verifying the correct stage execution
        (blocking redundant submittals), and processing the form&#39;s action.
        The common way to define an action for a dialog is to insert the
        action items within the dialog&#39;s start and end tags:
        <programlisting>

         &#60;xaf:dialog name=&#34;test.Test1&#34;&#62;
            &#60;xaf:query name=&#34;MyQuery&#34; skin=&#34;report&#34;/&#62;
         &#60;/xaf:dialog&#62;

            </programlisting> The above snippet of JSP code describes a dialog
        which will execute a SQL query when it is submitted. Instead of a
        query, one can also write pure Java code:
        <programlisting>

     &#60;xaf:dialog name=&#34;test.Test1&#34;&#62;
        &#60;%
            response.sendRedirect(&#34;/home&#34;);
        %&#62;
     &#60;/xaf:dialog&#62;

            </programlisting> Everything within the dialog custom tags (HTML,
        Java code, custom tags) are considered the action of the dialog.</para>

        <para>Usually, the action of the dialog is defined outside of the
        definition of the dialog such as in the JSP but there is a way to
        define an action for a dialog within the <filename>WEB-INF/ui/dialog.xml</filename>.
        The following is an example: <programlisting>


    &#60;dialog name=&#34;Test4&#34; heading=&#34;Test Fields&#34; loop=&#34;yes&#34; retain-params=&#34;*&#34;&#62;
        &#60;field.report name=&#34;report_field&#34;&#62;
            &#60;statement name=&#34;list&#34;&#62;
                select 0 as &#34;checkbox&#34;, userid as &#34;ID&#34;, lname as &#34;Name&#34;
                from users

                &#60;report skin=&#34;eimo-report&#34;&#62;
                    &#60;column type=&#34;checkbox&#34; align=&#34;center&#34; field-name=&#34;my_name&#34; field-value=&#34;my_name_row_${1}&#34;/&#62;
                    &#60;column heading=&#34;ID&#34; output=&#34;abc% $ ${2}&#34; format=&#34;%&#34;/&#62;
                    &#60;column heading=&#34;Last Name&#34; url=&#34;create-app-url:/${2}&#34; calc=&#34;count&#34;/&#62;
                &#60;/report&#62;
            &#60;/statement&#62;
        &#60;/field.report&#62;
    &#60;/dialog&#62;

            </programlisting></para>

        <section>
          <title>Using listeners</title>

          <para><trademark>Sparx</trademark> provides a way to implement
          business logic into the behavior of a dialog by providing a feature
          called <emphasis>Listeners</emphasis>. A listener is a Java object
          which is invoked when state changes occur in a dialog. It contains
          various behavior methods such as execution, data validation, and
          data population. All listeners must extend <trademark>XAF</trademark>&#39;s
          listener class <classname>com.xaf.form.DefaultDialogContextListener</classname>.
          The following is an example of a listener used in a JSP:
          <programlisting>

    request.setAttribute
    (&#34;test-listener&#34;, new DefaultDialogContextListener()
        {
            public boolean isDialogValid(DialogContext dc, boolean fieldsAlreadyValidated)
            {
                // insert code here to validate dialog
            }
        }
    );

    &#60;xaf:dialog name=&#34;Test.Test1&#34; listener=&#34;test-listener&#34;/&#62;


            </programlisting> In the example above, the <emphasis>test-listener</emphasis>&#39;s
          <methodname>isDialogValid</methodname> method is called when the
          dialog needs to check validity of data, before the dialog has
          performed its own validation.</para>
        </section>

        <section>
          <title>Defining a customized Java Dialog class</title>

          <para>There could be times when the total built-in behavior of a
          dialog does not satisfy the requirements of a web application; thus
          <trademark>Sparx</trademark> provides a way to create a dialog
          object in Java. A dialog can be created using a Java class which
          must extend the <trademark>XAF</trademark>&#39;s dialog class called
          <classname>com.xaf.form.Dialog</classname>:
          <programlisting>

package Test;

public class Test1  extends com.xaf.form.Dialog
{
    ...
    ..
}

            </programlisting> The behavior of the dialog can then be modified
          by overwriting the methods available or introducing new methods. The
          new dialog class can then be used by associating the class with a
          dialog definition in <filename>WEB-INF/ui/dialog.xml</filename>
          file: <programlisting>

        &#60;dialog name=&#34;TestDialog&#34; heading=&#34;Test Dialog&#34; class=&#34;Test.Test1&#34;&#62;
            ...
            ..
        &#60;/dialog&#62;

            </programlisting></para>
        </section>
      </section>

      <section id="Dialog-Context">
        <title>Dialog Context Beans (Form Beans)</title>

        <para>Acting as a finite state machine, the DialogContext class is the
        only object in the entire dialog processing lifecycle that is created
        for each user. The “form model” (Dialog) and “form view” (skin) are
        created, cached, and reused for each user; however, the DialogContext
        bean or DCB is a new object for each user and each request.</para>

        <section>
          <title>Generating form-specific Dialog Context Beans (DCBs)</title>

          <para></para>
        </section>
      </section>

      <section>
        <title>Server and Client-side Validation</title>

        <para>Sparx provides comprehensive client- and server-side validation
        logic for text, date, numeric, and other user-defined fields. All
        fields in Sparx are object- oriented and know how to draw themselves
        onto HTML and DHTML browsers.</para>

        <section>
          <title>Server-side Validation</title>

          <para></para>
        </section>

        <section>
          <title>Client-side Validation (JavaScript)</title>

          <para>A sophisticated Javascript library accompanies the server-side
          validation functionality that is intrinsic to Sparx (including
          keypress filters for allowing only specific keys to be pressed in
          certain field types likes numeric and date). Using the client-side
          Javascript validation, features like required fields and
          conditionally displayed fields become trivial to implement and test.
          In addition to the basic JavaScript object model, programmers can
          insert (extend) or replace JavaScript feature with their own custom
          functionality. External custom JavaScript files may also be included
          into any dialog or page.</para>

          <example>
            <title>Client-side Validation using JavaScript</title>

            <para>The following example demonstrates a variety of ways that
            Sparx supports client-side validation through JavaScript. You can
            choose to either extend the existing JavaScript functionality or
            override it.<programlisting>&#60;dialog name=&#34;DialogTest_12&#34; heading=&#34;Test Custom Javascript&#34;&#62;
    &#60;client-js href=&#34;create-app-url:/resources/images/scripts/eimo.js&#34;/&#62;

    &#60;field type=&#34;float&#34; name=&#34;float_field&#34; caption=&#34;Float&#34;&#62;
        &#60;client-js event=&#34;is-valid&#34; type=&#34;extends&#34; js-expr=&#34;return testValid(field, control);&#34;/&#62;
        &#60;client-js event=&#34;value-changed&#34; type=&#34;extends&#34; js-expr=&#34;return testNum(field, control);&#34;/&#62;
    &#60;/field&#62;

    &#60;field type=&#34;integer&#34; name=&#34;integer_field&#34; caption=&#34;Integer&#34;&#62;
        &#60;client-js event=&#34;is-valid&#34; type=&#34;override&#34; js-expr=&#34;return testValid(field, control);&#34;/&#62;
        &#60;client-js event=&#34;value-changed&#34; type=&#34;extends&#34; js-expr=&#34;return testNum(field, control);&#34;/&#62;
        &#60;client-js event=&#34;click&#34; type=&#34;extends&#34; js-expr=&#34;alert(&#39;onClick&#39;);return true;&#34;/&#62;
        &#60;client-js event=&#34;get-focus&#34; type=&#34;extends&#34; js-expr=&#34;alert(&#39;onFocus!&#39;);return true;&#34;/&#62;
        &#60;client-js event=&#34;lose-focus&#34; type=&#34;extends&#34; js-expr=&#34;alert(&#39;onBlur!&#39;);return true;&#34;/&#62;
        &#60;client-js event=&#34;key-press&#34; type=&#34;extends&#34; js-expr=&#34;alert(&#39;onKeypress!&#39;);return true;&#34;/&#62;
    &#60;/field&#62;

    &#60;field type=&#34;ssn&#34; name=&#34;ssn_field&#34; caption=&#34;SSN&#34;&#62;
        &#60;client-js event=&#34;is-valid&#34; type=&#34;override&#34; js-expr=&#34;return true;&#34;/&#62;
        &#60;client-js event=&#34;value-changed&#34; type=&#34;override&#34; js-expr=&#34;return true;&#34;/&#62;
    &#60;/field&#62;
&#60;/dialog&#62;</programlisting></para>
          </example>
        </section>
      </section>

      <section>
        <title>Dialogs as Services</title>

        <para>Dialogs allow data to be auto-populated and auto-executed. This
        means that a single dialog can serve multiple purposes: for use as a
        front-end for a user to edit/enter data and for a back-end process to
        enter data through a scripted process and automatically execute the
        same dialog as if a user had entered the data manually. This way, the
        same code can double as both a web-based application UI component and
        as a web service when the need arises.</para>
      </section>

      <section>
        <title>Dialog Processing Overview</title>

        <para>This section discusses the overview of the forms creation,
        caching, state management, and output.</para>

        <figure>
          <title>Sparx Forms Processing Overview</title>

          <mediaobject>
            <imageobject>
              <imagedata
              fileref="./resources/images/sparx-dialog-processing-overview.gif" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <section>
      <title>Themes and Skins</title>

      <para></para>
    </section>

    <section>
      <title>Template Engines</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Project Security Declarations</title>

    <para></para>

    <section>
      <title>Login Managers</title>

      <para></para>
    </section>

    <section>
      <title>Authenticated Users and Personalization</title>

      <para></para>
    </section>

    <section>
      <title>Access Control Lists</title>

      <para></para>
    </section>

    <section>
      <title>Role-based Navigation Trees</title>

      <para></para>
    </section>

    <section>
      <title>Role- and permission-based Forms and Fields</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Project Data Management Declarations</title>

    <para></para>

    <section>
      <title>Static Queries</title>

      <para>The Static Queries package allows all SQL statements and dynamic
      parameters used in a project to be declared in XML. Once defined, a
      single or multiple SQL statements may be used in reports, dialogs
      (forms), Servlets, templates, or JSP-pages. In many cases, SQL statement
      pooling completely replaces simple data-serving beans since data objects
      are automatically created for all SQL statements. Data can be easily
      aggregated from multiple data sources because each SQL statement in the
      statement pool can be specified (either in XML or JSP) to come from a
      variety of pre-defined or dynamic data sources. In addition to to basic
      SQL management (like prepare, bind parameters, and execute) the Sparx
      static queries objects automatically maintain peformance and usage
      statistics.</para>

      <section id="Query">
        <title>Overview</title>

        <para>NEF provides a centralized location to create and store all
        static SQL statements with bind parameters in a single repository: the
        Project File. The XML file also provides the flexibility of defining
        sql statements for multiple data sources in one centralized location.</para>
      </section>

      <section>
        <title>What&#39;s the difference?</title>

        <para>Lets say you want to query a database table and return the
        selected rows as a collection of JAVA objects. Without Axiom, you
        would need to:</para>

        <procedure>
          <step>
            <para>Obtain a database connection</para>
          </step>

          <step>
            <para>Construct appropriate SQL statement</para>
          </step>

          <step>
            <para>Execute SQL statement</para>
          </step>

          <step>
            <para>Loop over Result Set(s)</para>
          </step>

          <step>
            <para>For every row returned from the database, check if column is
            null or not</para>
          </step>

          <step>
            <para>Appropriately set the resulting column value into Objects
            data member</para>
          </step>

          <step>
            <para>Repeat step 6 for every column in the result set</para>
          </step>

          <step>
            <para>Set the resultant object in a collection</para>
          </step>

          <step>
            <para>Repeat steps 4 through 8 for every row in the result</para>
          </step>

          <step>
            <para>Return collection to calling code</para>
          </step>
        </procedure>
      </section>

      <section id="Creating-Query">
        <title>Creating a static query</title>

        <para>All static queries regardless of their data source are defined
        in <filename>WEB-INF/ui/statement.xml</filename>. Each query statement
        must belong to a query package also.</para>

        <section>
          <title>Defining the query</title>

          <para>A static query is defined(with or without bind parameters) by
          using the XML tag, <emphasis role="bold">&#60;statement&#62;</emphasis>.
          It is important to remember that in Sparx, every static query must
          belong to a statement package represented by <emphasis role="bold">&#60;sql-statements&#62;</emphasis>
          XML tag. Two XML tags <emphasis role="bold">&#60;params&#62;</emphasis>
          and <emphasis role="bold">&#60;param&#62;</emphasis> are used to
          indicate the replacement values for the bind parameters. The
          following is an example of a SQL statement with two bind parameters
          belonging to a sql package: <programlisting>
                &#60;sql-statements package=&#34;user&#34;&#62;
                    &#60;statement name=&#34;info&#34;&#62;
                        select
                            name,
                            address,
                            phone,
                            email
                        from
                            Customers
                        where
                            regionid = ? and
                            custid = ?
                        &#60;params&#62;
                            &#60;param value=&#34;request:region_id&#34;/&#62;
                            &#60;param value=&#34;request:cust_id&#34;/&#62;
                        &#60;/params&#62;
                    &#60;/statement&#62;
                &#60;/sql-statements&#62;
                </programlisting> The listing above show that the
          <emphasis>regionid</emphasis> and <emphasis>custid</emphasis>
          columns are defined with bind parameters. In the example, the values
          for the bind parameters are obtained from the HTTP request using the
          <emphasis>request</emphasis> Single Value Source. The order in which
          the bind parameters are defined within the <emphasis role="bold">&#60;params&#62;</emphasis>
          tag must be the same as the order in which they appear in the query
          statement.</para>

          <para>For the case where a SQL IN condition is necessary, a special
          parameter attribute is available. The attribute is called
          <emphasis>param-list</emphasis> and it follows the value source
          format(param-list:paramIndex). For example:
          <programlisting>
        &#60;sql-statements package=&#34;user&#34;&#62;
            &#60;statement name=&#34;info&#34;&#62;
                select
                    name,
                    address,
                    phone,
                    email
                from
                    Customers
                where
                    regionid IN (${param-list:0}) and
                    custid = ?
                &#60;params&#62;
                    &#60;param values=&#34;request:region_id&#34;/&#62;
                    &#60;param value=&#34;request:cust_id&#34;/&#62;
                &#60;/params&#62;
            &#60;/statement&#62;
        &#60;/sql-statements&#62;
                </programlisting> Note that <emphasis>regionid</emphasis>
          values are obtained from the <emphasis>region_id</emphasis> request
          parameter which is returning a list of values. The value attribute
          for the <emphasis role="bold">&#60;param&#62;</emphasis> tag in this
          case is <emphasis>values</emphasis> (to reflect multiple values).</para>
        </section>

        <section>
          <title>Defining the data source</title>

          <para>Within the XML, each SQL statement can specify either no data
          source (meaning the data comes from the default data source), a
          static data source, or a dynamic data source (meaning the data comes
          from a source that will be determined automatically based on some
          rule).</para>
        </section>

        <section>
          <title>Defining alternate SQL for different databases</title>

          <para></para>
        </section>

        <section>
          <title>SQL injection (dynamic replacements in SQL)</title>

          <para>In certain cases there are requirements that specify a SQL
          statement is generally the same except in certain circumstances. For
          these situations, Axiom allows for quasi-dynamic SQL statements that
          have the ability to do macro replacements inside the SQL as well as
          parameters. The SQL statement can have macros that are replaced each
          time the SQL is called and the parameters that may be passed in are
          dynamic (using single-value and list-value sources). The most common
          usage of this feature is to create an IN clause.</para>
        </section>

        <section>
          <title>Defining the report</title>

          <para>The display result of the query execution can be configured
          easily using the <emphasis>&#60;report&#62;</emphasis> XML tag .
          Column names can be assigned and the acutal result itself can be
          aligned or modified as a URL. An example is shown below for adding a
          customized report for the query created above:
          <programlisting>
                &#60;sql-statements package=&#34;user&#34;&#62;
                    &#60;statement name=&#34;info&#34;&#62;
                        select
                            name,
                            address,
                            phone,
                            email
                        from
                            Customers
                        where
                            regionid = ? and
                            custid = ?
                        &#60;params&#62;
                            &#60;param value=&#34;request:region_id&#34;/&#62;
                            &#60;param value=&#34;request:cust_id&#34;/&#62;
                        &#60;/params&#62;
                        &#60;report heading=&#34;Customer Information&#34;&#62;
                            &#60;column index=&#34;0&#34; heading=&#34;Name&#34; align=&#34;left&#34; url=&#34;http://clickme/${0}&#34;/&#62;
                            &#60;column index=&#34;1&#34; heading=&#34;Address&#34; align=&#34;left&#34;/&#62;
                            &#60;column index=&#34;2&#34; heading=&#34;Phone&#34; align=&#34;left&#34;/&#62;
                            &#60;column index=&#34;3&#34; heading=&#34;ID&#34; align=&#34;left&#34;/&#62;
                        &#60;/report&#62;
                    &#60;/statement&#62;
                &#60;/sql-statements&#62;
                </programlisting> Each <emphasis role="bold">&#60;column&#62;</emphasis>
          XML tag of the report corresponds to the query statement&#39;s
          result set column entry though the the attribute
          <emphasis>index</emphasis>. The query above does not specify the
          data source thus giving it the flexibility to be used for multiple
          data sources. If the data source needs to be defined with the
          statement, an attribute called <emphasis>data-src</emphasis> is also
          available for the <emphasis role="bold">&#60;statement&#62;</emphasis>
          tag.</para>
        </section>
      </section>

      <section id="Testing-Query">
        <title>Testing the static query</title>

        <section>
          <title>Unit Testing</title>

          <para>Most static queries can be unit tested using though the
          Application Component Explorer(ACE). The <menuchoice><guimenu>Database</guimenu><guimenu>SQL
          Statements</guimenu></menuchoice> menu entry in ACE displays all the
          SQL statements defined in <filename>web-app/Site/WEB-INF/ui/statement.xml</filename>
          as shown below.</para>

          <para><mediaobject><imageobject><imagedata
          fileref="./resources/images/statements/ace-statements.jpg"
          format="JPEG" /></imageobject></mediaobject> By clicking on the
          execute icon of any of the queries, one can test the execution of
          that SQL query.</para>
        </section>

        <section>
          <title>Integration Testing</title>

          <para>A custom tag called <emphasis role="bold">&#60;xaf:query&#62;</emphasis>
          is available to use a static query within a JSP file. The following
          is an example of using the query defined above inside a JSP:
          <programlisting>
    &#60;xaf:query name=&#34;user.info&#34; skin=&#34;report&#34; debug=&#34;no&#34;/&#62;
                    </programlisting></para>
        </section>
      </section>

      <section id="Using-Query">
        <title>Using the static query</title>

        <section id="Using-Query-Tag">
          <title>Using the query tag</title>

          <para>Static queries can be executed inside a JSP using the custom
          tag <sgmltag class="starttag"> xaf:query</sgmltag>. The execution of
          the query can also be configured in different ways: to display
          reports, to fill in HTML dialogs, or to save the data in arrays
          inside of displaying them.</para>

          <section>
            <title>Used as a report</title>

            <para>By default a static query report can be created by including
            the query within a JSP and describing the report type.</para>

            <programlisting>

    &#60;xaf:query name=&#34;user.info&#34; skin=&#34;report&#34; debug=&#34;no&#34;/&#62;

                    </programlisting>

            <para>The <sgmltag class="attribute">skin</sgmltag> attribute
            determines how the report is displayed on the screen. For example,
            the <programlisting> skin=&#34;report&#34; </programlisting> will
            display the retrieved data in a report format (multiple rows with
            column names as the first row) while
            <programlisting> skin=&#34;text-csv&#34; </programlisting>
            displays the retrieved data as comma seperated variables. A static
            query report can also be created a result of a submit action of a
            dialog. For example, by listing the static query customt tag
            inside the custom dialog tag node, <sgmltag class="starttag">xaf:dialog</sgmltag>
            , one can ensure that the query will only be executed when the
            dialog is submitted:</para>

            <programlisting>

    &#60;xaf:dialog name=&#34;test.test1&#34;&#62;
        &#60;xaf:query name=&#34;user.info&#34; skin=&#34;report&#34; debug=&#34;no&#34;/&#62;
    &#60;/xaf:dialog&#62;

                    </programlisting>
          </section>

          <section>
            <title>Used to fill a dialog</title>

            <para>Instead of printing a report to the screen, the retrieved
            data from the static query can be saved into a proceeding dialog.
            The following JSP sample is an example of this:</para>

            <programlisting>
    &#60;xaf:query name=&#34;user.info&#34; report=&#34;none&#34; store=&#34;form:*&#34; debug=&#34;no&#34;/&#62;
    &#60;xaf:dialog name=&#34;test.test1&#34;/&#62;
                    </programlisting>

            <para>The data retrieved from the query is not displayed but it is
            filled into the dialog through the <emphasis>store=&#34;form:*&#34;</emphasis>
            and <emphasis>report=&#34;none&#34;</emphasis> settings. For this
            to work, the dialog field names must be the same as the column
            names defined in the query statement.</para>
          </section>

          <section>
            <title>Used to create an array variable</title>

            <para>The retrieved data from a static query can be saved into a
            HTTP request attribute or a HTTP session attribute variable. The
            following is an example of saving the data inside a request
            attribute:</para>

            <programlisting>
    &#60;xaf:query name=&#34;user.info&#34;
                report=&#34;none&#34;
                store=&#34;request-attr:userInfo&#34;
                storeType=&#34;row-map&#34;
                debug=&#34;no&#34;/&#62;
    &#60;%
    Map user = (Map)request.getAttribute(&#34;userInfo&#34;);
    %&#62;
                    </programlisting>

            <para>The above example saves the query data inside a request
            attribute called <emphasis>userInfo</emphasis> of
            <emphasis>Map</emphasis> object type.</para>
          </section>
        </section>

        <section id="Using-Query-Java">
          <title>Using Java objects</title>

          <para>NEF provides an alternative way to execute queries within a
          JSP document rather then using a <sgmltag class="starttag">xaf:query</sgmltag>
          custom tag. There are convenience methods provided within
          <classname>com.xaf.sql.StatementManager</classname> class to execute
          SQL queries. These methods can execute queries in the following
          ways:</para>

          <itemizedlist>
            <listitem>
              <para>Executing a static query defined in <filename>statement.xml</filename>
              by using the query id passed to the method as a parameter</para>
            </listitem>

            <listitem>
              <para>Executing a static query which is directly passed to the
              method as a parameter</para>
            </listitem>
          </itemizedlist>

          <example>
            <title>Defined Query</title>

            <para>The following is an example of using the
            <classname>com.xaf.sql.StatementManager</classname> class within a
            JSP to execute a query defined in <filename>statement.xml</filename>:</para>

            <programlisting>

        &#60;%
        DatabaseContext dbContext = DatabaseContextFactory.getSystemContext();
        Map result = StatementManager.executeStmtGetValuesMap(dbContext, pageContext,
            &#34;jdbc/cura&#34;, &#34;org.name-only&#34;, new Object[new String(&#34;123&#34;)]);
        %&#62;

                    </programlisting>

            <para>The above example is doing exactly the same as the following
            JSP snippet using the query custom tag (assuming the query is
            expecting the bind parameter from a request attribute called
            <literal>org_id</literal>):</para>

            <programlisting>

        &#60;%
        request.setAttribute(&#34;org_id&#34;, &#34;123&#34;);
        %&#62;
        &#60;xaf:query name=&#34;org.name-only&#34; dataSource=&#34;jdbc/cura&#34; report=&#34;none&#34;
        store=&#34;request-attr:result&#34;  storeType=&#34;row-map&#34;/&#62;
        &#60;%
        Map result = (Map)request.getAttribute(&#34;result&#34;);
        %&#62;

                    </programlisting>
          </example>

          <example>
            <title>Passed In Query</title>

            <para>The following is an example of using the
            <classname>com.xaf.sql.StatementManager</classname> class within a
            JSP to execute a query which is passed in (not defined in
            <filename>statement.xml</filename>):</para>

            <programlisting>

        &#60;%
        DatabaseContext dbContext = DatabaseContextFactory.getSystemContext();
        Map result = StatementManager.executeSqlGetValuesMap(dbContext, pageContext,
            &#34;jdbc/cura&#34;, &#34;select org_name from org where org_id = ?&#34;, new Object[new String(&#34;123&#34;)]);
        %&#62;

                    </programlisting>
          </example>

          <note>
            <para>It is recommended that all static queries be defined in
            <filename>statement.xml</filename> and this way of exeuting
            queries should be only used for debugging or development purposes.</para>
          </note>
        </section>
      </section>
    </section>

    <section>
      <title>Dynamic Queries</title>

      <para>The Dynamic Queries package (also known as the
      <emphasis>Query Definitions</emphasis> package) allows you to define
      tables, columns, joins, sort orders, and other important data through
      the use of Meta Information about data relationships. Once you create a
      query definition, Sparx allows end-users of your application to use
      simple HTML-based forms to automatically generate accurate SQL and
      performance-tuned statements to create paged reports or export data to
      external sources with very little effort. Instead of defining dynamic
      queries using imperative (if/then/else) Java programming using SQL
      injection, you simply provide rules to Sparx and then the end-user can
      generate SQL automatically by simply filling in some query by example
      forms.</para>

      <section id="Dynamic-Query" xreflabel="Querying Relational Data">
        <title>Overview</title>

        <para>One of Axiom&#39;s powerful features is to generate dynamic SQL
        statements based upon user input. The dynamic SQL generator can also
        generate different output formats such as pageable HTML reports with
        configurable rows per page or comma separated value (CSV) reports. The
        main component of the dynamic queries is the <emphasis>query
        definition dialog</emphasis> which is used to define bind parameters
        of the dynamic SQL statement. Thus, the dynamic query generator can be
        thought of as a combination of <emphasis>Dialog</emphasis> and
        <emphasis>Static Query</emphasis> features.</para>
      </section>

      <section id="Creating-Dynamic-Query">
        <title>Creating a dynamic query</title>

        <para>All dynamic query configurations are stored in the same
        repository as the static queries : <filename>WEB-INF/ui/statement.xml</filename>.
        A dynamic query in Axiom is defined with the <sgmltag class="element">query-defn</sgmltag>
        XML tag. Within this XML element, other XML element representations of
        column data fields, join tables and conditions, query definition
        dialog, conditions, and order fields are defined. The following is a
        sample dynamic query definition: <programlisting>

            &#60;query-defn id=&#34;Organization&#34;&#62;
                &#60;!-- Fields --&#62;
                &#60;field id=&#34;org_id&#34; caption=&#34;Account ID&#34; join=&#34;org&#34; column=&#34;org_id&#34;&#62;
                    &#60;report heading=&#34;ID&#34; url=&#34;create-app-url:/account/home.jsp?org_id=${.}&#34;/&#62;
                &#60;/field&#62;
                ...
                &#60;field id=&#34;org_code&#34; caption=&#34;Account Code&#34; join=&#34;org&#34; column=&#34;org_code&#34;&#62;
                    &#60;report heading=&#34;Code&#34;/&#62;
                &#60;/field&#62;

                &#60;!-- Joins --&#62;
                &#60;join id=&#34;org&#34; table=&#34;org&#34; auto-include=&#34;yes&#34;/&#62;
                &#60;join id=&#34;org_industry&#34; table=&#34;org_industry&#34;
                    condition=&#34;org.org_id = org_industry.org_id (+)&#34;/&#62;

                &#60;select-dialog name=&#34;org_search&#34; allow-debug=&#34;yes&#34; show-output-dests=&#34;no&#34;
                    hide-readonly-hints=&#34;yes&#34; heading=&#34;Search Accounts&#34;&#62;
                    &#60;field.text query-field=&#34;org_code&#34;/&#62;
                    ...
                    ...
                    &#60;select&#62;
                        &#60;display field=&#34;org_id&#34;/&#62;
                        &#60;display field=&#34;org_code&#34;/&#62;
                        ...
                        ...
                        &#60;order-by field=&#34;form:sort_order&#34;/&#62;

                        &#60;condition field=&#34;org_name&#34; allow-null=&#34;no&#34; comparison=&#34;starts-with&#34;
                            value=&#34;form:org_name&#34;
                            connector=&#34;and&#34; bind-expr=&#34;upper(?)&#34;/&#62;
                        &#60;condition field=&#34;org_abbrev&#34; allow-null=&#34;no&#34; comparison=&#34;starts-with&#34;
                            value=&#34;form:org_abbrev&#34;
                            connector=&#34;and&#34; bind-expr=&#34;upper(?)&#34;/&#62;
                        &#60;condition field=&#34;org_industry&#34; allow-null=&#34;no&#34; comparison=&#34;equals&#34;
                            value=&#34;form:org_industry&#34;
                            connector=&#34;and&#34;/&#62;
                    &#60;/select&#62;
                    &#60;director cancel-url=&#34;index.jsp&#34; submit-caption=&#34;Search&#34;/&#62;
                &#60;/select-dialog&#62;

            &#60;/query-defn&#62;

                </programlisting></para>

        <para>The dynamic query definition show above contains various XML
        tags which are summarized below: <variablelist><title>XML Tag
        Definitions</title><varlistentry><term><sgmltag class="starttag">field</sgmltag></term><listitem><para>Represents
        database column names and column expressions used for generating the
        SQL. It is available for setting the report columns (represented by
        the <sgmltag class="element">display</sgmltag> tag) and setting the
        condition strings (represented by the <sgmltag class="element">condition</sgmltag>
        tag). The displayed report column value can be formatted using the
        <sgmltag class="element">report</sgmltag> tag which can be used as a
        child node definition.</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="starttag">report</sgmltag></term><listitem><para>Represents the
        result column formatting. Child node element for the <sgmltag
        class="element">field</sgmltag>. The following attributes are
        available: <itemizedlist><listitem><para><sgmltag class="attribute">type</sgmltag>:&#x00A0;
        The values available are <sgmltag class="attvalue">default</sgmltag>,
        <sgmltag class="attvalue">numeric</sgmltag>, <sgmltag class="attvalue">decimal</sgmltag>,
        and <sgmltag class="attvalue">checkbox</sgmltag>.</para></listitem><listitem><para><sgmltag
        class="attribute">format</sgmltag>:&#x00A0; The values available are
        <sgmltag class="attvalue">plain</sgmltag>, <sgmltag class="attvalue">general</sgmltag>,
        <sgmltag class="attvalue">decimal</sgmltag>, <sgmltag class="attvalue">currency</sgmltag>,
        <sgmltag class="attvalue">percentage</sgmltag>, <sgmltag
        class="attvalue">date</sgmltag>, <sgmltag class="attvalue">datetime</sgmltag>,
        and <sgmltag class="attvalue">time</sgmltag>.</para></listitem></itemizedlist></para></listitem></varlistentry><varlistentry><term><sgmltag
        class="starttag">join</sgmltag></term><listitem><para>Represents
        database tables that are included for the JOIN part of the SQL
        statement. Each element is only included as a join if the
        corresponding <sgmltag class="element">field</sgmltag> element is
        being used or the attribute <sgmltag class="attribute">auto-include</sgmltag>
        is set to &#34;yes&#34;.</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="starttag">select-dialog</sgmltag></term><listitem><para>Represents
        a query definition dialog object containing fields for entering values
        of the bind parameters. The following attributes are available:
        <itemizedlist><listitem><para><sgmltag class="attribute">allow-debug</sgmltag>:&#x00A0;
        when attribute is set to <quote>yes</quote>, the dialog object
        displays a debug check box. When this checkbox is checked and the
        dialog is submitted, the generated SQL with its bind parameters will
        be displayed for debugging purposes instead of execution of the
        generated SQL.</para></listitem><listitem><para><sgmltag
        class="attribute">show-output-dests</sgmltag>: &#x00A0; The attribute
        is used to give the user several output options: HTML output (pageable
        report and row count per page), CSV output format, tab delimited
        format.</para></listitem><listitem><para><sgmltag class="attribute">heading</sgmltag>:
        &#x00A0; The title of the query definition dialog.</para></listitem></itemizedlist></para></listitem></varlistentry><varlistentry><term><sgmltag
        class="starttag">select</sgmltag></term><listitem><para>Represents the
        SQL query which is being generated. It is a parent node for the report
        columns (<sgmltag class="starttag">display</sgmltag>), order-by
        selections (<sgmltag class="starttag">order-by</sgmltag>), and
        condition statements (<sgmltag class="starttag">condition</sgmltag>).
        The following attributes are available: <itemizedlist><listitem><para><sgmltag
        class="attribute">heading</sgmltag>:&#x00A0; The heading of the
        resulting query</para></listitem><listitem><para><sgmltag
        class="attribute">distinct</sgmltag>: &#x00A0; Indicates whether or
        not the SELECT statement is distinct (values are <sgmltag
        class="attvalue">yes</sgmltag> and <sgmltag class="attvalue">no</sgmltag>).
        <important><para>Setting this attribute will insert a
        <emphasis>distinct</emphasis> string into the SQL and it will effect
        all columns!</para></important></para></listitem></itemizedlist></para></listitem></varlistentry><varlistentry><term><sgmltag
        class="starttag">display</sgmltag></term><listitem><para>Represents
        the SQL columns that are retrieved from the database. The following
        attribute is available: <itemizedlist><listitem><para><sgmltag
        class="attribute">field</sgmltag>:&#x00A0; The value for this
        attribute must correspond to one of the fields defined by the <sgmltag
        class="starttag">field</sgmltag>. For example,
        <programlisting>

    &#60;field id=&#34;org_id&#34; caption=&#34;Account ID&#34; join=&#34;org&#34; column=&#34;org_id&#34;/&#62;
    ...
    &#60;select-dialog ..&#62;
        ...
        ...
        &#60;select&#62;
            &#60;display field=&#34;org_id&#34;/&#62;
            ...
        &#60;/select&#62;
    &#60;/select-dialog&#62;

                                    </programlisting></para></listitem></itemizedlist></para></listitem></varlistentry><varlistentry><term><sgmltag
        class="starttag">order-by</sgmltag></term><listitem><para>Represents
        the sort criteria. The following attributes are available:
        <itemizedlist><listitem><para><sgmltag class="attribute">field</sgmltag>:&#x00A0;
        The value for this attribute must correspond to one of the fields
        defined by the <sgmltag class="starttag">field</sgmltag>. For example,
        <programlisting>

    &#60;field id=&#34;org_id&#34; caption=&#34;Account ID&#34; join=&#34;org&#34; column=&#34;org_id&#34;/&#62;
    ...
    &#60;select-dialog ..&#62;
        ...
        ...
        &#60;select&#62;
            &#60;order-by field=&#34;org_id&#34;/&#62;
            ...
        &#60;/select&#62;
    &#60;/select-dialog&#62;

                                    </programlisting></para></listitem><listitem><para><sgmltag
        class="attribute">descending</sgmltag>:&#x00A0; Indicates whether or
        not the sort order should be descending or ascending.</para></listitem></itemizedlist></para></listitem></varlistentry><varlistentry><term><sgmltag
        class="starttag">condition</sgmltag></term><listitem><para>Represents
        the selection criteria. The following attributes are available:</para><itemizedlist><listitem><para><sgmltag
        class="attribute">field</sgmltag>:&#x00A0; The value for this
        attribute must correspond to one of the fields defined by the <sgmltag
        class="starttag">field</sgmltag>.</para></listitem><listitem><para><sgmltag
        class="attribute">allow-null</sgmltag>:&#x00A0; Whether or not to
        allow a NULL value as a valid bind parameter value.</para></listitem><listitem><para><sgmltag
        class="attribute">comparison</sgmltag>:&#x00A0; Describes what kind of
        relational operator to use. The following values are available:
        <sgmltag class="attvalue">starts-with</sgmltag>, <sgmltag
        class="attvalue">in</sgmltag>, <sgmltag class="attvalue">greater-than-equal</sgmltag>,<sgmltag
        class="attvalue">greater-than</sgmltag>, <sgmltag class="attvalue">less-than-equal</sgmltag>,
        <sgmltag class="attvalue">less-than</sgmltag>, <sgmltag
        class="attvalue">equals</sgmltag>, <sgmltag class="attvalue">contains</sgmltag>,
        <sgmltag class="attvalue">is-defined</sgmltag>, <sgmltag
        class="attvalue">starts-with</sgmltag>, <sgmltag class="attvalue">ends-with</sgmltag>,
        and <sgmltag class="attvalue">not-equals</sgmltag>.</para></listitem></itemizedlist><para>For
        example,</para><programlisting>

        &#60;field id=&#34;org_id&#34; caption=&#34;Account ID&#34; join=&#34;org&#34; column=&#34;org_id&#34;/&#62;
        ...
        &#60;select-dialog ..&#62;
        ...
        ...
        &#60;select&#62;
        &#60;condition field=&#34;org_id&#34; allow-null=&#34;no&#34; comparison=&#34;starts-with&#34;
        bind-expr=&#34;upper(?)&#34; value=&#34;form:customer_id&#34; connector=&#34;and&#34;/&#62;
        ...
        &#60;/select&#62;
        &#60;/select-dialog&#62;

                            </programlisting></listitem></varlistentry><varlistentry><term><sgmltag
        class="starttag">director</sgmltag></term><listitem><para>Represents
        the dialog director object which can be used to change the text of the
        action buttons and their respective URLs. The following attributes are
        available: <itemizedlist><listitem><para><sgmltag class="attribute">cancel-url</sgmltag>:&#x00A0;
        Defines what the URL is for the Cancel button.</para></listitem><listitem><para><sgmltag
        class="attribute">cancel-caption</sgmltag>:&#x00A0; Defines what the
        Cancel button should be called.</para></listitem><listitem><para><sgmltag
        class="attribute">submit-caption</sgmltag>:&#x00A0; Defines what
        Submit button should be called.</para></listitem></itemizedlist>
        <programlisting>

    &#60;director submit-caption=&#34;Submit&#34; cancel-caption=&#34;Cancel&#34; cancel-url=&#34;/go&#34;/&#62;

                            </programlisting></para></listitem></varlistentry></variablelist></para>
      </section>

      <section id="Testing-Dynamic-Query">
        <title>Testing the dynamic query</title>

        <section>
          <title>Unit Testing</title>

          <para>All available dynamic query definitions can be viewed in
          Console under the <menuchoice role="bold"><guimenu>Database</guimenu><guimenuitem>SQL
          Query Definitions</guimenuitem></menuchoice> menu item:</para>

          <para><screenshot><graphic
          fileref="./resources/images/statements/ace-querydefs.jpg" /></screenshot></para>

          <para>By clicking on the name of the query definition, all the
          entries of the query definition can be viewed:</para>

          <para><screenshot><graphic
          fileref="./resources/images/statements/ace-querydefs2.jpg" /></screenshot></para>

          <para>Clicking on the Action icon in the Select Table shown above
          displays the query definition dialog represented by the <sgmltag
          class="element">select-dialog</sgmltag> tag.</para>

          <para><screenshot><graphic
          fileref="./resources/images/statements/ace-querydefs3.jpg" /></screenshot></para>

          <para>The debug checkbox is very useful to debug the dynamic query
          which is being generated according to the user&#39;s configuration.</para>
        </section>

        <section>
          <title>Integration Testing</title>

          <para>The query definition dialog can be used in a JSP using the
          custom tag <emphasis role="bold">&#60;xaf:query-select-dialog&#62;</emphasis>.
          For example, the following entry displays a query definition dialog
          inside a JSP: <programlisting>

    &#60;xaf:query-select-dialog source=&#34;Order&#34; name=&#34;region_order_search&#34;/&#62;

                </programlisting></para>
        </section>
      </section>

      <section id="Using-Dynamic-Query">
        <title>Using the dynamic query</title>

        <para>A dynamic query statement is generated from the query definition
        dialog and the resulting report can be configured in different ways.
        <programlisting>

    &#60;xaf:query-select-dialog source=&#34;Order&#34; name=&#34;region_order_search&#34;/&#62;

                </programlisting></para>
      </section>
    </section>

    <section>
      <title>Schemas</title>

      <para>The Schemas package allows almost all standard database schema
      objects like tables, columns, and data types (data dictionaries) to be
      managed in a database-independent XML format. The same XML declarations
      can be used to generate database-specific SQL DDL allowing a single XML
      source schema to work in a variety of SQL relational databases (like
      Oracle, SQL Server, MySQL, etc.). Experienced DBAs are not required to
      create consistent, high-quality SQL DDL during the design and
      construction phases of an application. Database-dependent objects like
      triggers and stored procedures are not managed by Sparx and are created
      using existing means. Because almost all schema resources are defined in
      XML, Sparx allows for re-use of Schemas across applications and
      different database vendors and produces and maintains Schema
      documentation. Sparx encourages the creation and re-use of a set of
      data-types and table-types (the data dictionary) that define standard
      behaviors for columns and tables. Data-types and table-types comprise
      the database dictionary and can easily be inherited and extended. Sparx
      also generates database-independent Java Object-relational classes. This
      is a called the Application DAL (Data Access Layer). Sparx can
      automatically generate a Java Object-relational DAL for an entire
      schema, automating the majority of SQL calls by providing strongly-typed
      Java wrappers for all tables and columns.</para>

      <figure>
        <title>Axiom Schema Artifacts</title>

        <mediaobject>
          <imageobject>
            <imagedata
            fileref="./resources/images/data-mgmt-schema-conversions-overview.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Benefits of Managing the Relational Database Schemas in Axiom</title>

        <itemizedlist>
          <listitem>
            <para>Database Programmers spend time on essential tables and
            schema elements significant to a specific application instead of
            rewriting common schema elements for each application.</para>
          </listitem>

          <listitem>
            <para>Allows for re-use of Schemas across applications and
            produces and maintains Schema documentation. XIF encourages the
            creation and re-use of a set of datatypes and tabletypes that
            define standard behaviors for columns and tables. Datatypes and
            tabletypes comprise the SchemaDoc database dictionary and can
            easily be inherited and extended.</para>
          </listitem>

          <listitem>
            <para>Almost all schema objects like tables, columns, data types,
            etc. are managed in a database-independent XML SchemaDoc. The
            entire schema is managed in XML as an XML document (a SchemaDoc)
            and SQL is generated through XSLT style sheets (the templates).
            The same SchemaDoc can be used to generate database-specific SQL
            DDL allowing a single XML source schema to work in a variety of
            SQL relational databases (like Oracle, SQL Server, MySQL, etc.).</para>
          </listitem>

          <listitem>
            <para>Database-specific SQL DDL is created by applying XSLT style
            sheets to a SchemaDoc. Experienced DBAs are not required to create
            consistent, high-quality SQL DDL during the design and
            construction phases of an application. Database-dependent objects
            like triggers and stored procedures are not managed by the XIF and
            are created using existing means.</para>
          </listitem>

          <listitem>
            <para>Database-independent Java Object-relational classes are
            created by applying XSLT style sheets to a SchemaDoc. This is a
            called the Application DAL (Data Access Layer). XIF can
            automatically generate a Java Object-relational DAL (Data Access
            Layer) for an entire schema, automating the majority of SQL calls
            by providing strongly-typed Java wrappers for all tables and
            columns.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Creating Datatypes</title>

        <para>Datatypes should be considered <quote>column templates</quote>
        that allow a programmer to specify a column type. They are completely
        schema dependent but may be reused across applications. This means
        that the basic templating system (SchemaDoc to XSLT generator) does
        not have any <quote>built-in</quote> datatypes. Datatypes may be
        inherited from other datatypes, allowing better reuse and
        object-orientation in relational databases. They can be easily
        generated and maintains a database-independent data dictionary. The
        XML tag for creating datatypes is <sgmltag class="starttag">datatype</sgmltag>.</para>

        <para>The database schema datatypes are created in one central
        location which is application specific, <filename>Database/schema-src/datatypes.xml</filename>.
        The Axiom DTD is located in <filename>resources/images/dtd/schema-markup.dtd</filename>
        and it needs to be referenced to create datatypes. The following is a
        sample header for <filename>Database/schema-src/datatypes.xml</filename>:
        <programlisting>

    &#60;?xml version=&#34;1.0&#34;?&#62;
    &#60;!DOCTYPE schema SYSTEM &#34;D:/projects/Framework/web-shared/resources/images/dtd/schema-markup.dtd&#34;&#62;

            </programlisting> The data types can be defined within the
        <sgmltag class="element">schema</sgmltag> XML tag. The following is an
        example of several common data types defined for a relational
        database: <programlisting>

    &#60;schema name=&#34;generic-datatypes&#34;&#62;
        &#60;datatype name=&#34;text&#34; test=&#34;1&#34;&#62;
            &#60;sqldefn&#62;varchar2(%size%)&#60;/sqldefn&#62;
            &#60;size&#62;32&#60;/size&#62;
        &#60;/datatype&#62;

        &#60;datatype name=&#34;float&#34;&#62;
            &#60;sqldefn&#62;float&#60;/sqldefn&#62;
        &#60;/datatype&#62;

        &#60;datatype name=&#34;number&#34;&#62;
            &#60;sqldefn&#62;number(%size%)&#60;/sqldefn&#62;
            &#60;size&#62;3&#60;/size&#62;
        &#60;/datatype&#62;

        &#60;datatype name=&#34;integer&#34;&#62;
            &#60;sqldefn&#62;integer&#60;/sqldefn&#62;
        &#60;/datatype&#62;

        &#60;datatype name=&#34;date&#34;&#62;
            &#60;sqldefn&#62;date&#60;/sqldefn&#62;
        &#60;/datatype&#62;

        &#60;datatype name=&#34;duration&#34;&#62;
            &#60;composite&#62;
                &#60;column name=&#34;$name$_begin_date&#34; type=&#34;date&#34;/&#62;
                &#60;column name=&#34;$name$_end_date&#34; type=&#34;date&#34;/&#62;
            &#60;/composite&#62;
        &#60;/datatype&#62;
    &#60;/schema&#62;

            </programlisting> Datatypes provide their SQL DDL using the
        <sgmltag class="element">sqldefn</sgmltag> tag. Datatypes are usually
        simple types like <quote>text</quote>, <quote>integer</quote>, or
        <quote>float</quote>. More complex types like <quote>duration</quote>
        can be created by using the <sgmltag class="element">composite</sgmltag>
        tag allowing a single datatype to automatically generate multiple
        columns in tables.</para>
      </section>

      <section>
        <title>Creating Table Types</title>

        <para>Tabletypes should be considered <quote>table templates</quote>
        that allow a programmer to specify a table type. They are completely
        schema dependent but may be reused across applications. This means
        that the basic templating system (SchemaDoc to XSLT generator) does
        not have any <quote>built-in</quote> tabletypes. Tabletypes may be
        inherited from other tabletypes, allowing better reuse and
        object-orientation in relational databases. They can be created using
        the <sgmltag class="element">tabletype</sgmltag> tag. The following is
        an example of defining tables in <filename>Database/schema-src/tabletypes.xml</filename>:
        <programlisting>

    &#60;?xml version=&#34;1.0&#34;?&#62;
    &#60;!DOCTYPE schema SYSTEM &#34;D:/projects/Framework/web-shared/resources/images/dtd/schema-markup.dtd&#34;&#62;

    &#60;schema name=&#34;tabletypes&#34;&#62;
        &#60;tabletype name=&#34;Default&#34;&#62;
            &#60;column name=&#34;cr_stamp&#34; type=&#34;stamp&#34; required=&#34;dbms&#34; default=&#34;sysdate&#34;/&#62;
            &#60;column name=&#34;cr_person_id&#34; lookupref=&#34;Person.person_id&#34;/&#62;
            &#60;column name=&#34;cr_org_id&#34; lookupref=&#34;Org.org_id&#34;/&#62;
        &#60;/tabletype&#62;
    &#60;/schema&#62;

            </programlisting> The <sgmltag class="element">column</sgmltag>
        element in the <sgmltag class="element">tabletype</sgmltag> elements
        creates actual columns derived from a particular <sgmltag
        class="element">datatype</sgmltag>. The <sgmltag class="element">column</sgmltag>
        elements will automatically maintain all type definitions and links to
        foreign keys automatically. The columns are arguably the most
        important definitions in the entire SchemaDoc. They take abstract
        representations of datatypes and instantiate actual columns in tables.
        The following are attributes for the <sgmltag class="element">column</sgmltag>
        element: <variablelist><varlistentry><term><sgmltag class="attribute">name</sgmltag></term><listitem><para>The
        name of the column. Each column is usually named as a singular noun in
        all lower case with each word inside a name separated by underscores.
        For instance, person_id is a good column name but personid is harder
        to read. If you use the appropriate naming convention, the Data Access
        Layer generator will produce better output.</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="attribute">type</sgmltag></term><listitem><para>The name of
        data-type to inherit. All of the attributes and elements from the
        other data-type will be inherited and any attributes and elements
        defined in this data-type will override those values. You can get an
        idea of all the types available for use with this attribute by looking
        at the datatypes.xml file.</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="attribute">size</sgmltag></term><listitem><para>The size
        attribute of the specified data type. What the size means depends on
        the data type. For example, in text fields, it specifies the number of
        characters used.</para></listitem></varlistentry><varlistentry><term>primary-key</term><listitem><para>Specifies
        whether or not this column is a primary key.</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="attribute">lookup-ref</sgmltag></term><listitem><para>Format is
        Table_X.Column_Y. Specifies a general foreign key relationship from
        the defining column which references the foreign Column_Y of Table_X
        (creates a 1:1 or 1:N relationship between defining column and the
        referenced column). If you use this attribute, the type attribute is
        not required (it’s set to the same type as the referenced column).</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="attribute">parent-ref</sgmltag></term><listitem><para>Format is
        Table_X.Column_Y. Specifies a parent/child foreign key relationship
        which indicates that Table_X is a parent of the defining column using
        Column_Y’s value (creates a 1:N relationship between Table_X and the
        column defining the parentref). If you use this attribute, the type
        attribute is not required (it’s set to the same type as the referenced
        column).</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="attribute">self-ref</sgmltag></term><listitem><para>Format is
        &#34;Table_X.Column_Y&#34;. Specifies a a self-referential foreign key
        relationship which indicates that Table_X Column_Y is used to maintain
        an internal hierarchy (creates a 1:N relationship between itself). If
        you use this attribute, the type attribute is not required (it’s set
        to the same type as the referenced column).</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="attribute">descr</sgmltag></term><listitem><para>Description</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="attribute">required</sgmltag></term><listitem><para>Specifies
        whether or not this column is a required column. If the column is
        required, XIF generates a not null constraint.</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="attribute">default</sgmltag></term><listitem><para>Specifies
        the SQL expression that will be used as the column&#39;s default value
        in the SQL create table statement</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="attribute">unique</sgmltag></term><listitem><para>Specifies
        whether this column&#39;s values should be unique (meaning no two rows
        should share the same value for this column). When this value is set
        to yes, this attribute creates a unique index based on this single
        column. If more than one column needs to be unique (as a composite),
        use the &#60;index&#62; child element of the table element to create a
        unique index based on multiple columns.</para></listitem></varlistentry><varlistentry><term>indexed</term><listitem><para>Specifies
        whether this column&#39;s values should be indexed (for increasing
        search performance). When this value is set to yes, this attribute
        creates a search index based on this single column. If more than one
        column needs to be unique (as a composite), use the &#60;index&#62;
        child element of the table element to create an index based on
        multiple columns.</para></listitem></varlistentry></variablelist></para>
      </section>

      <section>
        <title>Creating Tables</title>

        <para>A table type is a set of one or more column definitions. So when
        you create a table based on a table type, that table will include all
        the columns of the table type as well as its own. Each <sgmltag
        class="element">table</sgmltag> can be based on one or more table
        types as shown in the following example:
        <programlisting>

    &#60;table name=&#34;Person&#34; abbrev=&#34;Per&#34; type=&#34;Default&#34;&#62;
        &#60;description&#62;Any person (client, staff member, etc.)&#60;/description&#62;
        &#60;column name=&#34;person_id&#34; primarykey=&#34;yes&#34; type=&#34;autoinc&#34;/&#62;
        &#60;column name=&#34;name_prefix&#34; type=&#34;text&#34; size=&#34;16&#34;/&#62;
        &#60;column name=&#34;name_first&#34; type=&#34;text&#34; required=&#34;yes&#34; size=&#34;32&#34;/&#62;
        &#60;column name=&#34;name_middle&#34; type=&#34;text&#34; size=&#34;32&#34;/&#62;
        &#60;column name=&#34;name_last&#34; type=&#34;text&#34; required=&#34;yes&#34; size=&#34;32&#34;/&#62;
        &#60;column name=&#34;name_suffix&#34; type=&#34;text&#34; size=&#34;16&#34;/&#62;
        &#60;column name=&#34;short_name&#34; type=&#34;text&#34; required=&#34;dbms&#34; size=&#34;42&#34;/&#62;
        &#60;column name=&#34;simple_name&#34; type=&#34;text&#34; required=&#34;dbms&#34; size=&#34;96&#34;/&#62;
        &#60;column name=&#34;complete_name&#34; type=&#34;text&#34; required=&#34;dbms&#34; size=&#34;128&#34;/&#62;
        &#60;column name=&#34;short_sortable_name&#34; type=&#34;text&#34; required=&#34;dbms&#34; size=&#34;42&#34;/&#62;
        &#60;column name=&#34;complete_sortable_name&#34; type=&#34;text&#34; required=&#34;dbms&#34; size=&#34;128&#34;/&#62;
        &#60;column name=&#34;ssn&#34; indexed=&#34;yes&#34; type=&#34;text&#34; size=&#34;11&#34;/&#62;
        &#60;column name=&#34;gender&#34; lookupref=&#34;Gender&#34; default=&#34;0&#34;/&#62;
        &#60;column name=&#34;marital_status&#34; lookupref=&#34;Marital_Status&#34; default=&#34;0&#34;/&#62;
        &#60;column name=&#34;date_of_birth&#34; type=&#34;date&#34;/&#62;
        &#60;column name=&#34;age&#34; type=&#34;integer&#34;/&#62;
    &#60;/table&#62;

            </programlisting> Using table types, one can quickly and
        consistently create similar tables that are automatically updated
        whenever the tabletypes change. The following attributes are allowed
        for the <sgmltag class="element">table</sgmltag> element:
        <variablelist><varlistentry><term><sgmltag class="attribute">name</sgmltag></term><listitem><para>the
        name of the table</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="attribute">abbrev</sgmltag></term><listitem><para>should be
        kept to 3 or 4 characters to allow constraint names and indexe names
        to be created properly</para></listitem></varlistentry><varlistentry><term><sgmltag
        class="attribute">type</sgmltag></term><listitem><para>the tabletype
        of the table</para></listitem></varlistentry></variablelist></para>
      </section>

      <section>
        <title>Creating Relationships</title>

        <para></para>
      </section>

      <section>
        <title>Managing Enumerations and Lookup Tables</title>

        <para>An enumeration is a special type of table that is generated by
        Sparx. It consists of three fields per record: a unique id which is
        used to relate the enumeration table in a 1:n manner with other
        tables, a non-null caption that is used to provide a short description
        of each value in the enumeration and an optional abbrev(iation) for
        the caption. An enumeration table is always of a fixed length since
        each record that goes into the table must be defined in the XML by
        hand. The syntax of an enumeration table is unlike that of regular
        tables. However, once parsed and interpreted, enumeration tables are
        translated into a set of regular tables for relational integrity
        purposes.</para>

        <para>Using enumeration tables can significantly improve performance
        for static and lookup tables and still allow normal relational logic
        (foreign keys). All lookups in Sparx dialogs using the schema-enum
        value source directly read and cache enumeration XML files instead of
        asking the database for the contents of the database. Since the DDL
        generated by XIF for enumeration tables is normal SQL (using standard
        create table commands), relational logic is maintained but performance
        is significantly improved.</para>

        <para>An enumeration table is used to establish a 1:n relationship
        between an attribute of an object (e.g. the genre of the book in this
        case) and the object itself (in this case, the book). It does this by
        letting the id field of the attribute enumeration table be inserted as
        a foreign key in the table containing records for the object. In this
        particular scenario, the lookupref attribute of the type field in the
        Book_Info table makes that happen.</para>
      </section>

      <section>
        <title>Generating SQL DDL File</title>

        <para>Using Console, a database-independent SchemaDoc XML file becomes
        a database-dependent SQL DDL file. Regenerating SQL DDL is the
        preferred method to modifying DDL during the design and construction
        phases (pre-production) of a web application. In post-production
        usage, the entire SQL is regenerated for changed tables and
        relationships but a experienced DBA should be involved for the
        alteration of live schemas. The main XML file, <filename>Database/schema-src/schema.xml</filename>,
        which is used to generate the SQL DDL contains all the different
        component XML files as shown in the example below:
        <programlisting>

    &#60;?xml version=&#34;1.0&#34;?&#62;
    &#60;!DOCTYPE schema SYSTEM &#34;D:/projects/Framework/web-shared/resources/images/dtd/schema-markup.dtd&#34;&#62;

    &#60;schema name=&#34;db&#34;&#62;

        &#60;include file=&#34;datatypes.xml&#34;/&#62;
        &#60;include file=&#34;tabletypes.xml&#34;/&#62;
        ....
        ...
    &#60;/schema&#62;

            </programlisting> All the schema definitions can be viewed by
        going to Console and selecting the <menuchoice><guimenu>Database</guimenu><guimenuitem>Schema
        (XML)</guimenuitem></menuchoice> menu item. A sample screenshot of the
        page is as shown below:</para>

        <para><mediaobject><imageobject><imagedata
        fileref="./resources/images/db-schema/ace-schema.jpg" format="JPEG" /></imageobject></mediaobject></para>

        <para>The SQL DLL file is generated by going to the
        <menuchoice><guimenu>Database</guimenu><guimenuitem>Generate DDL</guimenuitem></menuchoice>
        menu item in Console and selecting the location of the physical file
        as shown below:</para>

        <para><mediaobject><imageobject><imagedata
        fileref="./resources/images/db-schema/ace-ddl.jpg" format="JPEG" /></imageobject></mediaobject></para>
      </section>
    </section>

    <section>
      <title>Connection Providers</title>

      <para></para>
    </section>

    <section>
      <title>Database Policies</title>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>Creating the Web Application</title>

    <section id="WebApp">
      <title>Overview</title>

      <para>A Web application is a collection of HTML/XML documents, Web
      components (servlets and JSP pages), and other resources such as images
      and scripts in a directory structure. Sparx libraries support using
      different methodologies based on different building blocks such as JSP
      pages, custom tags, JavaBeans components, and servlets to produce a web
      application that delivers dynamically generated content. Based on
      application requirements, developers can pursue a design which is purely
      servlet based or they can pursue a design which is a combination of JSPs
      and servlets (also known as the <quote>Model 2</quote> design). Sparx
      also provides a more XML-centric approach where most business logic can
      be defined with the forms themselves so that the JSPs can purely
      concentrate on the presentation.</para>

      <para>This chapter describes the different approaches described above so
      that developers can choose dependent upon application specific
      requirements. The different approaches have their own benefits and
      failings and it is up to the developer to decide which is the best way
      to use to create and deliver a web application.</para>
    </section>

    <section id="Servlet">
      <title>Servlets</title>

      <para>Although JSP pages can be used for most presentation purposes,
      there are some circumstances such as low-level application functions
      that don&#39;t require frequent modification where servlets are more
      appropriate. Thus Sparx does not restrict the use of Servlets and fully
      supports both servlets and JSPs. Following the common web application
      atchitecture, all custom servlet Java classes must exist under <filename
      class="directory">web-app/Site/WEB-INF/classes</filename> (if JAR files
      are used, they must exist under <filename class="directory">web-app/Site/WEB-INF/lib</filename>
      directory). Servlets are named and mapped in <filename>Site/WEB-INF/web.xml</filename>
      as shown below: <programlisting>

    &#60;servlet&#62;
        &#60;servlet-name&#62;Navigator&#60;/servlet-name&#62;
        &#60;servlet-class&#62;com.xaf.navigate.NavigateFileSystemServlet&#60;/servlet-class&#62;
    &#60;/servlet&#62;
    &#60;servlet-mapping&#62;
        &#60;servlet-name&#62;Navigator&#60;/servlet-name&#62;
        &#60;url-pattern&#62;/navigate/*&#60;/url-pattern&#62;
    &#60;/servlet-mapping&#62;

        </programlisting> The above example is a built-in navigation servlet
      provided by Sparx and can be used to display directory listings.</para>

      <para>Sparx provides an interface called <classname>com.xaf.page.ServletPage</classname>
      and an implementing class called <classname>com.xaf.page.AbstractServletPage</classname>
      to create web pages purely in Java. The <classname>AbstractServletPage</classname>
      class should be extended since it does not define any behavior (the
      methods are empty). For example, Console uses a class called
      <classname>com.xaf.ace.AceServletPage</classname> which overwrites the
      methods defined in <classname>AbstractServletPage</classname> such as
      <methodname>handlePageHeader</methodname> and <methodname>handlePageMetaData</methodname>.
      It also defines other methods such as <methodname>transform</methodname>
      which can be used by other subclasses. Developers should create classes
      extending <classname>com.xaf.page.AbstractServletPage</classname> and
      then overwrite the various methods to define the functionality of each
      page. The following is an example of the dialogs listing page in
      Console: <example><title><classname>com.xaf.ace.AppDialogsPage
      </classname> class</title><para><programlisting>

    public class AppDialogsPage extends AceServletPage
    {
        ...

        public void handlePageBody(PageContext pc) throws ServletException, IOException
        {
            ServletContext context = pc.getServletContext();
            DialogManager manager = DialogManagerFactory.getManager(context);
            manager.addMetaInfoOptions();

            String testItem = getTestCommandItem(pc);
            if(testItem != null)
            {
                ...
            }
            else
            {
                ...
            }
        }
    }

            </programlisting> The example above describes how a web page can
      be created by overwriting the various methods available in
      <classname>com.xaf.ace.AceServletPage</classname> which extends the
      <classname>com.xaf.page.AbstractServletPage</classname>. The
      <classname>com.xaf.ace.AceServletPage</classname> defines the
      functionality common to all pages in Console and the
      <classname>AppDialogsPage</classname> base class extending this class
      can define content specific to the page itself.</para></example></para>

      <para>All pages created using <classname>com.xaf.page.AbstractServletPage</classname>
      as a super class must be registered so that they can be navigated to
      through a servlet. Sparx provides a servlet class called
      <classname>com.xaf.page.PageControllerServlet</classname>. This servlet
      class contains a method called <methodname>registerPages</methodname>
      which is used to register the Java defined web pages. For example,
      Console registers its pages through a servlet called
      <classname>com.xaf.ace.AppComponentsExplorerServlet</classname> and the
      servlet is registered in <filename>web.xml</filename>:
      <programlisting>

    &#60;servlet&#62;
        &#60;servlet-name&#62;AppComponentsExplorer&#60;/servlet-name&#62;
        &#60;servlet-class&#62;com.xaf.ace.AppComponentsExplorerServlet&#60;/servlet-class&#62;
    &#60;/servlet&#62;
    &#60;servlet-mapping&#62;
        &#60;servlet-name&#62;AppComponentsExplorer&#60;/servlet-name&#62;
        &#60;url-pattern&#62;/ace/*&#60;/url-pattern&#62;
    &#60;/servlet-mapping&#62;

        </programlisting></para>
    </section>
  </chapter>
</book>